var bl = Object.defineProperty; var Di = r => { throw TypeError(r) }; var yl = (r, e, t) => e in r ? bl(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t; var L = (r, e, t) => yl(r, typeof e != "symbol" ? e + "" : e, t), xl = (r, e, t) => e.has(r) || Di("Cannot " + t); var Ri = (r, e, t) => e.has(r) ? Di("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t); var ln = (r, e, t) => (xl(r, e, "access private method"), t); function G(r) { this.content = r } G.prototype = { constructor: G, find: function (r) { for (var e = 0; e < this.content.length; e += 2)if (this.content[e] === r) return e; return -1 }, get: function (r) { var e = this.find(r); return e == -1 ? void 0 : this.content[e + 1] }, update: function (r, e, t) { var n = t && t != r ? this.remove(t) : this, i = n.find(r), s = n.content.slice(); return i == -1 ? s.push(t || r, e) : (s[i + 1] = e, t && (s[i] = t)), new G(s) }, remove: function (r) { var e = this.find(r); if (e == -1) return this; var t = this.content.slice(); return t.splice(e, 2), new G(t) }, addToStart: function (r, e) { return new G([r, e].concat(this.remove(r).content)) }, addToEnd: function (r, e) { var t = this.remove(r).content.slice(); return t.push(r, e), new G(t) }, addBefore: function (r, e, t) { var n = this.remove(e), i = n.content.slice(), s = n.find(r); return i.splice(s == -1 ? i.length : s, 0, e, t), new G(i) }, forEach: function (r) { for (var e = 0; e < this.content.length; e += 2)r(this.content[e], this.content[e + 1]) }, prepend: function (r) { return r = G.from(r), r.size ? new G(r.content.concat(this.subtract(r).content)) : this }, append: function (r) { return r = G.from(r), r.size ? new G(this.subtract(r).content.concat(r.content)) : this }, subtract: function (r) { var e = this; r = G.from(r); for (var t = 0; t < r.content.length; t += 2)e = e.remove(r.content[t]); return e }, toObject: function () { var r = {}; return this.forEach(function (e, t) { r[e] = t }), r }, get size() { return this.content.length >> 1 } }; G.from = function (r) { if (r instanceof G) return r; var e = []; if (r) for (var t in r) e.push(t, r[t]); return new G(e) }; function uu(r, e, t) { for (let n = 0; ; n++) { if (n == r.childCount || n == e.childCount) return r.childCount == e.childCount ? null : t; let i = r.child(n), s = e.child(n); if (i == s) { t += i.nodeSize; continue } if (!i.sameMarkup(s)) return t; if (i.isText && i.text != s.text) { for (let u = 0; i.text[u] == s.text[u]; u++)t++; return t } if (i.content.size || s.content.size) { let u = uu(i.content, s.content, t + 1); if (u != null) return u } t += i.nodeSize } } function ou(r, e, t, n) { for (let i = r.childCount, s = e.childCount; ;) { if (i == 0 || s == 0) return i == s ? null : { a: t, b: n }; let u = r.child(--i), o = e.child(--s), l = u.nodeSize; if (u == o) { t -= l, n -= l; continue } if (!u.sameMarkup(o)) return { a: t, b: n }; if (u.isText && u.text != o.text) { let a = 0, c = Math.min(u.text.length, o.text.length); for (; a < c && u.text[u.text.length - a - 1] == o.text[o.text.length - a - 1];)a++, t--, n--; return { a: t, b: n } } if (u.content.size || o.content.size) { let a = ou(u.content, o.content, t - 1, n - 1); if (a) return a } t -= l, n -= l } } class y { constructor(e, t) { if (this.content = e, this.size = t || 0, t == null) for (let n = 0; n < e.length; n++)this.size += e[n].nodeSize } nodesBetween(e, t, n, i = 0, s) { for (let u = 0, o = 0; o < t; u++) { let l = this.content[u], a = o + l.nodeSize; if (a > e && n(l, i + o, s || null, u) !== !1 && l.content.size) { let c = o + 1; l.nodesBetween(Math.max(0, e - c), Math.min(l.content.size, t - c), n, i + c) } o = a } } descendants(e) { this.nodesBetween(0, this.size, e) } textBetween(e, t, n, i) { let s = "", u = !0; return this.nodesBetween(e, t, (o, l) => { let a = o.isText ? o.text.slice(Math.max(e, l) - l, t - l) : o.isLeaf ? i ? typeof i == "function" ? i(o) : i : o.type.spec.leafText ? o.type.spec.leafText(o) : "" : ""; o.isBlock && (o.isLeaf && a || o.isTextblock) && n && (u ? u = !1 : s += n), s += a }, 0), s } append(e) { if (!e.size) return this; if (!this.size) return e; let t = this.lastChild, n = e.firstChild, i = this.content.slice(), s = 0; for (t.isText && t.sameMarkup(n) && (i[i.length - 1] = t.withText(t.text + n.text), s = 1); s < e.content.length; s++)i.push(e.content[s]); return new y(i, this.size + e.size) } cut(e, t = this.size) { if (e == 0 && t == this.size) return this; let n = [], i = 0; if (t > e) for (let s = 0, u = 0; u < t; s++) { let o = this.content[s], l = u + o.nodeSize; l > e && ((u < e || l > t) && (o.isText ? o = o.cut(Math.max(0, e - u), Math.min(o.text.length, t - u)) : o = o.cut(Math.max(0, e - u - 1), Math.min(o.content.size, t - u - 1))), n.push(o), i += o.nodeSize), u = l } return new y(n, i) } cutByIndex(e, t) { return e == t ? y.empty : e == 0 && t == this.content.length ? this : new y(this.content.slice(e, t)) } replaceChild(e, t) { let n = this.content[e]; if (n == t) return this; let i = this.content.slice(), s = this.size + t.nodeSize - n.nodeSize; return i[e] = t, new y(i, s) } addToStart(e) { return new y([e].concat(this.content), this.size + e.nodeSize) } addToEnd(e) { return new y(this.content.concat(e), this.size + e.nodeSize) } eq(e) { if (this.content.length != e.content.length) return !1; for (let t = 0; t < this.content.length; t++)if (!this.content[t].eq(e.content[t])) return !1; return !0 } get firstChild() { return this.content.length ? this.content[0] : null } get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null } get childCount() { return this.content.length } child(e) { let t = this.content[e]; if (!t) throw new RangeError("Index " + e + " out of range for " + this); return t } maybeChild(e) { return this.content[e] || null } forEach(e) { for (let t = 0, n = 0; t < this.content.length; t++) { let i = this.content[t]; e(i, n, t), n += i.nodeSize } } findDiffStart(e, t = 0) { return uu(this, e, t) } findDiffEnd(e, t = this.size, n = e.size) { return ou(this, e, t, n) } findIndex(e) { if (e == 0) return an(0, e); if (e == this.size) return an(this.content.length, e); if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`); for (let t = 0, n = 0; ; t++) { let i = this.child(t), s = n + i.nodeSize; if (s >= e) return s == e ? an(t + 1, s) : an(t, n); n = s } } toString() { return "<" + this.toStringInner() + ">" } toStringInner() { return this.content.join(", ") } toJSON() { return this.content.length ? this.content.map(e => e.toJSON()) : null } static fromJSON(e, t) { if (!t) return y.empty; if (!Array.isArray(t)) throw new RangeError("Invalid input for Fragment.fromJSON"); return new y(t.map(e.nodeFromJSON)) } static fromArray(e) { if (!e.length) return y.empty; let t, n = 0; for (let i = 0; i < e.length; i++) { let s = e[i]; n += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s) } return new y(t || e, n) } static from(e) { if (!e) return y.empty; if (e instanceof y) return e; if (Array.isArray(e)) return this.fromArray(e); if (e.attrs) return new y([e], e.nodeSize); throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : "")) } } y.empty = new y([], 0); const rr = { index: 0, offset: 0 }; function an(r, e) { return rr.index = r, rr.offset = e, rr } function Tn(r, e) { if (r === e) return !0; if (!(r && typeof r == "object") || !(e && typeof e == "object")) return !1; let t = Array.isArray(r); if (Array.isArray(e) != t) return !1; if (t) { if (r.length != e.length) return !1; for (let n = 0; n < r.length; n++)if (!Tn(r[n], e[n])) return !1 } else { for (let n in r) if (!(n in e) || !Tn(r[n], e[n])) return !1; for (let n in e) if (!(n in r)) return !1 } return !0 } let P = class Nr { constructor(e, t) { this.type = e, this.attrs = t } addToSet(e) { let t, n = !1; for (let i = 0; i < e.length; i++) { let s = e[i]; if (this.eq(s)) return e; if (this.type.excludes(s.type)) t || (t = e.slice(0, i)); else { if (s.type.excludes(this.type)) return e; !n && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), n = !0), t && t.push(s) } } return t || (t = e.slice()), n || t.push(this), t } removeFromSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return e.slice(0, t).concat(e.slice(t + 1)); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return !0; return !1 } eq(e) { return this == e || this.type == e.type && Tn(this.attrs, e.attrs) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Mark.fromJSON"); let n = e.marks[t.type]; if (!n) throw new RangeError(`There is no mark type ${t.type} in this schema`); let i = n.create(t.attrs); return n.checkAttrs(i.attrs), i } static sameSet(e, t) { if (e == t) return !0; if (e.length != t.length) return !1; for (let n = 0; n < e.length; n++)if (!e[n].eq(t[n])) return !1; return !0 } static setFrom(e) { if (!e || Array.isArray(e) && e.length == 0) return Nr.none; if (e instanceof Nr) return [e]; let t = e.slice(); return t.sort((n, i) => n.type.rank - i.type.rank), t } }; P.none = []; class En extends Error { } class x { constructor(e, t, n) { this.content = e, this.openStart = t, this.openEnd = n } get size() { return this.content.size - this.openStart - this.openEnd } insertAt(e, t) { let n = au(this.content, e + this.openStart, t); return n && new x(n, this.openStart, this.openEnd) } removeBetween(e, t) { return new x(lu(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd) } eq(e) { return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd } toString() { return this.content + "(" + this.openStart + "," + this.openEnd + ")" } toJSON() { if (!this.content.size) return null; let e = { content: this.content.toJSON() }; return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e } static fromJSON(e, t) { if (!t) return x.empty; let n = t.openStart || 0, i = t.openEnd || 0; if (typeof n != "number" || typeof i != "number") throw new RangeError("Invalid input for Slice.fromJSON"); return new x(y.fromJSON(e, t.content), n, i) } static maxOpen(e, t = !0) { let n = 0, i = 0; for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)n++; for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)i++; return new x(e, n, i) } } x.empty = new x(y.empty, 0, 0); function lu(r, e, t) { let { index: n, offset: i } = r.findIndex(e), s = r.maybeChild(n), { index: u, offset: o } = r.findIndex(t); if (i == e || s.isText) { if (o != t && !r.child(u).isText) throw new RangeError("Removing non-flat range"); return r.cut(0, e).append(r.cut(t)) } if (n != u) throw new RangeError("Removing non-flat range"); return r.replaceChild(n, s.copy(lu(s.content, e - i - 1, t - i - 1))) } function au(r, e, t, n) { let { index: i, offset: s } = r.findIndex(e), u = r.maybeChild(i); if (s == e || u.isText) return r.cut(0, e).append(t).append(r.cut(e)); let o = au(u.content, e - s - 1, t); return o && r.replaceChild(i, u.copy(o)) } function kl(r, e, t) { if (t.openStart > r.depth) throw new En("Inserted content deeper than insertion position"); if (r.depth - t.openStart != e.depth - t.openEnd) throw new En("Inconsistent open depths"); return cu(r, e, t, 0) } function cu(r, e, t, n) { let i = r.index(n), s = r.node(n); if (i == e.index(n) && n < r.depth - t.openStart) { let u = cu(r, e, t, n + 1); return s.copy(s.content.replaceChild(i, u)) } else if (t.content.size) if (!t.openStart && !t.openEnd && r.depth == n && e.depth == n) { let u = r.parent, o = u.content; return ut(u, o.cut(0, r.parentOffset).append(t.content).append(o.cut(e.parentOffset))) } else { let { start: u, end: o } = wl(t, r); return ut(s, fu(r, u, o, e, n)) } else return ut(s, Mn(r, e, n)) } function du(r, e) { if (!e.type.compatibleContent(r.type)) throw new En("Cannot join " + e.type.name + " onto " + r.type.name) } function Ar(r, e, t) { let n = r.node(t); return du(n, e.node(t)), n } function st(r, e) { let t = e.length - 1; t >= 0 && r.isText && r.sameMarkup(e[t]) ? e[t] = r.withText(e[t].text + r.text) : e.push(r) } function Ft(r, e, t, n) { let i = (e || r).node(t), s = 0, u = e ? e.index(t) : i.childCount; r && (s = r.index(t), r.depth > t ? s++ : r.textOffset && (st(r.nodeAfter, n), s++)); for (let o = s; o < u; o++)st(i.child(o), n); e && e.depth == t && e.textOffset && st(e.nodeBefore, n) } function ut(r, e) { return r.type.checkContent(e), r.copy(e) } function fu(r, e, t, n, i) { let s = r.depth > i && Ar(r, e, i + 1), u = n.depth > i && Ar(t, n, i + 1), o = []; return Ft(null, r, i, o), s && u && e.index(i) == t.index(i) ? (du(s, u), st(ut(s, fu(r, e, t, n, i + 1)), o)) : (s && st(ut(s, Mn(r, e, i + 1)), o), Ft(e, t, i, o), u && st(ut(u, Mn(t, n, i + 1)), o)), Ft(n, null, i, o), new y(o) } function Mn(r, e, t) { let n = []; if (Ft(null, r, t, n), r.depth > t) { let i = Ar(r, e, t + 1); st(ut(i, Mn(r, e, t + 1)), n) } return Ft(e, null, t, n), new y(n) } function wl(r, e) { let t = e.depth - r.openStart, i = e.node(t).copy(r.content); for (let s = t - 1; s >= 0; s--)i = e.node(s).copy(y.from(i)); return { start: i.resolveNoCache(r.openStart + t), end: i.resolveNoCache(i.content.size - r.openEnd - t) } } class Ut { constructor(e, t, n) { this.pos = e, this.path = t, this.parentOffset = n, this.depth = t.length / 3 - 1 } resolveDepth(e) { return e == null ? this.depth : e < 0 ? this.depth + e : e } get parent() { return this.node(this.depth) } get doc() { return this.node(0) } node(e) { return this.path[this.resolveDepth(e) * 3] } index(e) { return this.path[this.resolveDepth(e) * 3 + 1] } indexAfter(e) { return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1) } start(e) { return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1 } end(e) { return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size } before(e) { if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position before the top-level node"); return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] } after(e) { if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position after the top-level node"); return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize } get textOffset() { return this.pos - this.path[this.path.length - 1] } get nodeAfter() { let e = this.parent, t = this.index(this.depth); if (t == e.childCount) return null; let n = this.pos - this.path[this.path.length - 1], i = e.child(t); return n ? e.child(t).cut(n) : i } get nodeBefore() { let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1]; return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1) } posAtIndex(e, t) { t = this.resolveDepth(t); let n = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1; for (let s = 0; s < e; s++)i += n.child(s).nodeSize; return i } marks() { let e = this.parent, t = this.index(); if (e.content.size == 0) return P.none; if (this.textOffset) return e.child(t).marks; let n = e.maybeChild(t - 1), i = e.maybeChild(t); if (!n) { let o = n; n = i, i = o } let s = n.marks; for (var u = 0; u < s.length; u++)s[u].type.spec.inclusive === !1 && (!i || !s[u].isInSet(i.marks)) && (s = s[u--].removeFromSet(s)); return s } marksAcross(e) { let t = this.parent.maybeChild(this.index()); if (!t || !t.isInline) return null; let n = t.marks, i = e.parent.maybeChild(e.index()); for (var s = 0; s < n.length; s++)n[s].type.spec.inclusive === !1 && (!i || !n[s].isInSet(i.marks)) && (n = n[s--].removeFromSet(n)); return n } sharedDepth(e) { for (let t = this.depth; t > 0; t--)if (this.start(t) <= e && this.end(t) >= e) return t; return 0 } blockRange(e = this, t) { if (e.pos < this.pos) return e.blockRange(this); for (let n = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); n >= 0; n--)if (e.pos <= this.end(n) && (!t || t(this.node(n)))) return new Nn(this, e, n); return null } sameParent(e) { return this.pos - this.parentOffset == e.pos - e.parentOffset } max(e) { return e.pos > this.pos ? e : this } min(e) { return e.pos < this.pos ? e : this } toString() { let e = ""; for (let t = 1; t <= this.depth; t++)e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1); return e + ":" + this.parentOffset } static resolve(e, t) { if (!(t >= 0 && t <= e.content.size)) throw new RangeError("Position " + t + " out of range"); let n = [], i = 0, s = t; for (let u = e; ;) { let { index: o, offset: l } = u.content.findIndex(s), a = s - l; if (n.push(u, o, i + l), !a || (u = u.child(o), u.isText)) break; s = a - 1, i += l + 1 } return new Ut(t, n, s) } static resolveCached(e, t) { let n = Ii.get(e); if (n) for (let s = 0; s < n.elts.length; s++) { let u = n.elts[s]; if (u.pos == t) return u } else Ii.set(e, n = new Sl); let i = n.elts[n.i] = Ut.resolve(e, t); return n.i = (n.i + 1) % Cl, i } } class Sl { constructor() { this.elts = [], this.i = 0 } } const Cl = 12, Ii = new WeakMap; class Nn { constructor(e, t, n) { this.$from = e, this.$to = t, this.depth = n } get start() { return this.$from.before(this.depth + 1) } get end() { return this.$to.after(this.depth + 1) } get parent() { return this.$from.node(this.depth) } get startIndex() { return this.$from.index(this.depth) } get endIndex() { return this.$to.indexAfter(this.depth) } } const Tl = Object.create(null); let je = class Or { constructor(e, t, n, i = P.none) { this.type = e, this.attrs = t, this.marks = i, this.content = n || y.empty } get children() { return this.content.content } get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size } get childCount() { return this.content.childCount } child(e) { return this.content.child(e) } maybeChild(e) { return this.content.maybeChild(e) } forEach(e) { this.content.forEach(e) } nodesBetween(e, t, n, i = 0) { this.content.nodesBetween(e, t, n, i, this) } descendants(e) { this.nodesBetween(0, this.content.size, e) } get textContent() { return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "") } textBetween(e, t, n, i) { return this.content.textBetween(e, t, n, i) } get firstChild() { return this.content.firstChild } get lastChild() { return this.content.lastChild } eq(e) { return this == e || this.sameMarkup(e) && this.content.eq(e.content) } sameMarkup(e) { return this.hasMarkup(e.type, e.attrs, e.marks) } hasMarkup(e, t, n) { return this.type == e && Tn(this.attrs, t || e.defaultAttrs || Tl) && P.sameSet(this.marks, n || P.none) } copy(e = null) { return e == this.content ? this : new Or(this.type, this.attrs, e, this.marks) } mark(e) { return e == this.marks ? this : new Or(this.type, this.attrs, this.content, e) } cut(e, t = this.content.size) { return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t)) } slice(e, t = this.content.size, n = !1) { if (e == t) return x.empty; let i = this.resolve(e), s = this.resolve(t), u = n ? 0 : i.sharedDepth(t), o = i.start(u), a = i.node(u).content.cut(i.pos - o, s.pos - o); return new x(a, i.depth - u, s.depth - u) } replace(e, t, n) { return kl(this.resolve(e), this.resolve(t), n) } nodeAt(e) { for (let t = this; ;) { let { index: n, offset: i } = t.content.findIndex(e); if (t = t.maybeChild(n), !t) return null; if (i == e || t.isText) return t; e -= i + 1 } } childAfter(e) { let { index: t, offset: n } = this.content.findIndex(e); return { node: this.content.maybeChild(t), index: t, offset: n } } childBefore(e) { if (e == 0) return { node: null, index: 0, offset: 0 }; let { index: t, offset: n } = this.content.findIndex(e); if (n < e) return { node: this.content.child(t), index: t, offset: n }; let i = this.content.child(t - 1); return { node: i, index: t - 1, offset: n - i.nodeSize } } resolve(e) { return Ut.resolveCached(this, e) } resolveNoCache(e) { return Ut.resolve(this, e) } rangeHasMark(e, t, n) { let i = !1; return t > e && this.nodesBetween(e, t, s => (n.isInSet(s.marks) && (i = !0), !i)), i } get isBlock() { return this.type.isBlock } get isTextblock() { return this.type.isTextblock } get inlineContent() { return this.type.inlineContent } get isInline() { return this.type.isInline } get isText() { return this.type.isText } get isLeaf() { return this.type.isLeaf } get isAtom() { return this.type.isAtom } toString() { if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this); let e = this.type.name; return this.content.size && (e += "(" + this.content.toStringInner() + ")"), hu(this.marks, e) } contentMatchAt(e) { let t = this.type.contentMatch.matchFragment(this.content, 0, e); if (!t) throw new Error("Called contentMatchAt on a node with invalid content"); return t } canReplace(e, t, n = y.empty, i = 0, s = n.childCount) { let u = this.contentMatchAt(e).matchFragment(n, i, s), o = u && u.matchFragment(this.content, t); if (!o || !o.validEnd) return !1; for (let l = i; l < s; l++)if (!this.type.allowsMarks(n.child(l).marks)) return !1; return !0 } canReplaceWith(e, t, n, i) { if (i && !this.type.allowsMarks(i)) return !1; let s = this.contentMatchAt(e).matchType(n), u = s && s.matchFragment(this.content, t); return u ? u.validEnd : !1 } canAppend(e) { return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type) } check() { this.type.checkContent(this.content), this.type.checkAttrs(this.attrs); let e = P.none; for (let t = 0; t < this.marks.length; t++) { let n = this.marks[t]; n.type.checkAttrs(n.attrs), e = n.addToSet(e) } if (!P.sameSet(e, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(t => t.type.name)}`); this.content.forEach(t => t.check()) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map(t => t.toJSON())), e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Node.fromJSON"); let n; if (t.marks) { if (!Array.isArray(t.marks)) throw new RangeError("Invalid mark data for Node.fromJSON"); n = t.marks.map(e.markFromJSON) } if (t.type == "text") { if (typeof t.text != "string") throw new RangeError("Invalid text node in JSON"); return e.text(t.text, n) } let i = y.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i, n); return s.type.checkAttrs(s.attrs), s } }; je.prototype.text = void 0; class An extends je { constructor(e, t, n, i) { if (super(e, t, null, i), !n) throw new RangeError("Empty text nodes are not allowed"); this.text = n } toString() { return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : hu(this.marks, JSON.stringify(this.text)) } get textContent() { return this.text } textBetween(e, t) { return this.text.slice(e, t) } get nodeSize() { return this.text.length } mark(e) { return e == this.marks ? this : new An(this.type, this.attrs, this.text, e) } withText(e) { return e == this.text ? this : new An(this.type, this.attrs, e, this.marks) } cut(e = 0, t = this.text.length) { return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t)) } eq(e) { return this.sameMarkup(e) && this.text == e.text } toJSON() { let e = super.toJSON(); return e.text = this.text, e } } function hu(r, e) { for (let t = r.length - 1; t >= 0; t--)e = r[t].type.name + "(" + e + ")"; return e } class ct {
    constructor(e) { this.validEnd = e, this.next = [], this.wrapCache = [] } static parse(e, t) { let n = new El(e, t); if (n.next == null) return ct.empty; let i = pu(n); n.next && n.err("Unexpected trailing text"); let s = Rl(Dl(i)); return Il(s, n), s } matchType(e) { for (let t = 0; t < this.next.length; t++)if (this.next[t].type == e) return this.next[t].next; return null } matchFragment(e, t = 0, n = e.childCount) { let i = this; for (let s = t; i && s < n; s++)i = i.matchType(e.child(s).type); return i } get inlineContent() { return this.next.length != 0 && this.next[0].type.isInline } get defaultType() { for (let e = 0; e < this.next.length; e++) { let { type: t } = this.next[e]; if (!(t.isText || t.hasRequiredAttrs())) return t } return null } compatible(e) { for (let t = 0; t < this.next.length; t++)for (let n = 0; n < e.next.length; n++)if (this.next[t].type == e.next[n].type) return !0; return !1 } fillBefore(e, t = !1, n = 0) { let i = [this]; function s(u, o) { let l = u.matchFragment(e, n); if (l && (!t || l.validEnd)) return y.from(o.map(a => a.createAndFill())); for (let a = 0; a < u.next.length; a++) { let { type: c, next: d } = u.next[a]; if (!(c.isText || c.hasRequiredAttrs()) && i.indexOf(d) == -1) { i.push(d); let f = s(d, o.concat(c)); if (f) return f } } return null } return s(this, []) } findWrapping(e) { for (let n = 0; n < this.wrapCache.length; n += 2)if (this.wrapCache[n] == e) return this.wrapCache[n + 1]; let t = this.computeWrapping(e); return this.wrapCache.push(e, t), t } computeWrapping(e) { let t = Object.create(null), n = [{ match: this, type: null, via: null }]; for (; n.length;) { let i = n.shift(), s = i.match; if (s.matchType(e)) { let u = []; for (let o = i; o.type; o = o.via)u.push(o.type); return u.reverse() } for (let u = 0; u < s.next.length; u++) { let { type: o, next: l } = s.next[u]; !o.isLeaf && !o.hasRequiredAttrs() && !(o.name in t) && (!i.type || l.validEnd) && (n.push({ match: o.contentMatch, type: o, via: i }), t[o.name] = !0) } } return null } get edgeCount() { return this.next.length } edge(e) { if (e >= this.next.length) throw new RangeError(`There's no ${e}th edge in this content match`); return this.next[e] } toString() {
        let e = []; function t(n) { e.push(n); for (let i = 0; i < n.next.length; i++)e.indexOf(n.next[i].next) == -1 && t(n.next[i].next) } return t(this), e.map((n, i) => { let s = i + (n.validEnd ? "*" : " ") + " "; for (let u = 0; u < n.next.length; u++)s += (u ? ", " : "") + n.next[u].type.name + "->" + e.indexOf(n.next[u].next); return s }).join(`
`)
    }
} ct.empty = new ct(!0); class El { constructor(e, t) { this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift() } get next() { return this.tokens[this.pos] } eat(e) { return this.next == e && (this.pos++ || !0) } err(e) { throw new SyntaxError(e + " (in content expression '" + this.string + "')") } } function pu(r) { let e = []; do e.push(Ml(r)); while (r.eat("|")); return e.length == 1 ? e[0] : { type: "choice", exprs: e } } function Ml(r) { let e = []; do e.push(Nl(r)); while (r.next && r.next != ")" && r.next != "|"); return e.length == 1 ? e[0] : { type: "seq", exprs: e } } function Nl(r) { let e = vl(r); for (; ;)if (r.eat("+")) e = { type: "plus", expr: e }; else if (r.eat("*")) e = { type: "star", expr: e }; else if (r.eat("?")) e = { type: "opt", expr: e }; else if (r.eat("{")) e = Al(r, e); else break; return e } function Pi(r) { /\D/.test(r.next) && r.err("Expected number, got '" + r.next + "'"); let e = Number(r.next); return r.pos++, e } function Al(r, e) { let t = Pi(r), n = t; return r.eat(",") && (r.next != "}" ? n = Pi(r) : n = -1), r.eat("}") || r.err("Unclosed braced range"), { type: "range", min: t, max: n, expr: e } } function Ol(r, e) { let t = r.nodeTypes, n = t[e]; if (n) return [n]; let i = []; for (let s in t) { let u = t[s]; u.isInGroup(e) && i.push(u) } return i.length == 0 && r.err("No node type or group '" + e + "' found"), i } function vl(r) { if (r.eat("(")) { let e = pu(r); return r.eat(")") || r.err("Missing closing paren"), e } else if (/\W/.test(r.next)) r.err("Unexpected token '" + r.next + "'"); else { let e = Ol(r, r.next).map(t => (r.inline == null ? r.inline = t.isInline : r.inline != t.isInline && r.err("Mixing inline and block content"), { type: "name", value: t })); return r.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e } } } function Dl(r) { let e = [[]]; return i(s(r, 0), t()), e; function t() { return e.push([]) - 1 } function n(u, o, l) { let a = { term: l, to: o }; return e[u].push(a), a } function i(u, o) { u.forEach(l => l.to = o) } function s(u, o) { if (u.type == "choice") return u.exprs.reduce((l, a) => l.concat(s(a, o)), []); if (u.type == "seq") for (let l = 0; ; l++) { let a = s(u.exprs[l], o); if (l == u.exprs.length - 1) return a; i(a, o = t()) } else if (u.type == "star") { let l = t(); return n(o, l), i(s(u.expr, l), l), [n(l)] } else if (u.type == "plus") { let l = t(); return i(s(u.expr, o), l), i(s(u.expr, l), l), [n(l)] } else { if (u.type == "opt") return [n(o)].concat(s(u.expr, o)); if (u.type == "range") { let l = o; for (let a = 0; a < u.min; a++) { let c = t(); i(s(u.expr, l), c), l = c } if (u.max == -1) i(s(u.expr, l), l); else for (let a = u.min; a < u.max; a++) { let c = t(); n(l, c), i(s(u.expr, l), c), l = c } return [n(l)] } else { if (u.type == "name") return [n(o, void 0, u.value)]; throw new Error("Unknown expr type") } } } } function mu(r, e) { return e - r } function Li(r, e) { let t = []; return n(e), t.sort(mu); function n(i) { let s = r[i]; if (s.length == 1 && !s[0].term) return n(s[0].to); t.push(i); for (let u = 0; u < s.length; u++) { let { term: o, to: l } = s[u]; !o && t.indexOf(l) == -1 && n(l) } } } function Rl(r) { let e = Object.create(null); return t(Li(r, 0)); function t(n) { let i = []; n.forEach(u => { r[u].forEach(({ term: o, to: l }) => { if (!o) return; let a; for (let c = 0; c < i.length; c++)i[c][0] == o && (a = i[c][1]); Li(r, l).forEach(c => { a || i.push([o, a = []]), a.indexOf(c) == -1 && a.push(c) }) }) }); let s = e[n.join(",")] = new ct(n.indexOf(r.length - 1) > -1); for (let u = 0; u < i.length; u++) { let o = i[u][1].sort(mu); s.next.push({ type: i[u][0], next: e[o.join(",")] || t(o) }) } return s } } function Il(r, e) { for (let t = 0, n = [r]; t < n.length; t++) { let i = n[t], s = !i.validEnd, u = []; for (let o = 0; o < i.next.length; o++) { let { type: l, next: a } = i.next[o]; u.push(l.name), s && !(l.isText || l.hasRequiredAttrs()) && (s = !1), n.indexOf(a) == -1 && n.push(a) } s && e.err("Only non-generatable nodes (" + u.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)") } } function gu(r) { let e = Object.create(null); for (let t in r) { let n = r[t]; if (!n.hasDefault) return null; e[t] = n.default } return e } function bu(r, e) { let t = Object.create(null); for (let n in r) { let i = e && e[n]; if (i === void 0) { let s = r[n]; if (s.hasDefault) i = s.default; else throw new RangeError("No value supplied for attribute " + n) } t[n] = i } return t } function yu(r, e, t, n) { for (let i in e) if (!(i in r)) throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`); for (let i in r) { let s = r[i]; s.validate && s.validate(e[i]) } } function xu(r, e) { let t = Object.create(null); if (e) for (let n in e) t[n] = new Ll(r, n, e[n]); return t } let Bi = class ku { constructor(e, t, n) { this.name = e, this.schema = t, this.spec = n, this.markSet = null, this.groups = n.group ? n.group.split(" ") : [], this.attrs = xu(e, n.attrs), this.defaultAttrs = gu(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(n.inline || e == "text"), this.isText = e == "text" } get isInline() { return !this.isBlock } get isTextblock() { return this.isBlock && this.inlineContent } get isLeaf() { return this.contentMatch == ct.empty } get isAtom() { return this.isLeaf || !!this.spec.atom } isInGroup(e) { return this.groups.indexOf(e) > -1 } get whitespace() { return this.spec.whitespace || (this.spec.code ? "pre" : "normal") } hasRequiredAttrs() { for (let e in this.attrs) if (this.attrs[e].isRequired) return !0; return !1 } compatibleContent(e) { return this == e || this.contentMatch.compatible(e.contentMatch) } computeAttrs(e) { return !e && this.defaultAttrs ? this.defaultAttrs : bu(this.attrs, e) } create(e = null, t, n) { if (this.isText) throw new Error("NodeType.create can't construct text nodes"); return new je(this, this.computeAttrs(e), y.from(t), P.setFrom(n)) } createChecked(e = null, t, n) { return t = y.from(t), this.checkContent(t), new je(this, this.computeAttrs(e), t, P.setFrom(n)) } createAndFill(e = null, t, n) { if (e = this.computeAttrs(e), t = y.from(t), t.size) { let u = this.contentMatch.fillBefore(t); if (!u) return null; t = u.append(t) } let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(y.empty, !0); return s ? new je(this, e, t.append(s), P.setFrom(n)) : null } validContent(e) { let t = this.contentMatch.matchFragment(e); if (!t || !t.validEnd) return !1; for (let n = 0; n < e.childCount; n++)if (!this.allowsMarks(e.child(n).marks)) return !1; return !0 } checkContent(e) { if (!this.validContent(e)) throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`) } checkAttrs(e) { yu(this.attrs, e, "node", this.name) } allowsMarkType(e) { return this.markSet == null || this.markSet.indexOf(e) > -1 } allowsMarks(e) { if (this.markSet == null) return !0; for (let t = 0; t < e.length; t++)if (!this.allowsMarkType(e[t].type)) return !1; return !0 } allowedMarks(e) { if (this.markSet == null) return e; let t; for (let n = 0; n < e.length; n++)this.allowsMarkType(e[n].type) ? t && t.push(e[n]) : t || (t = e.slice(0, n)); return t ? t.length ? t : P.none : e } static compile(e, t) { let n = Object.create(null); e.forEach((s, u) => n[s] = new ku(s, t, u)); let i = t.spec.topNode || "doc"; if (!n[i]) throw new RangeError("Schema is missing its top node type ('" + i + "')"); if (!n.text) throw new RangeError("Every schema needs a 'text' type"); for (let s in n.text.attrs) throw new RangeError("The text node type should not have attributes"); return n } }; function Pl(r, e, t) { let n = t.split("|"); return i => { let s = i === null ? "null" : typeof i; if (n.indexOf(s) < 0) throw new RangeError(`Expected value of type ${n} for attribute ${e} on type ${r}, got ${s}`) } } class Ll { constructor(e, t, n) { this.hasDefault = Object.prototype.hasOwnProperty.call(n, "default"), this.default = n.default, this.validate = typeof n.validate == "string" ? Pl(e, t, n.validate) : n.validate } get isRequired() { return !this.hasDefault } } class Vn { constructor(e, t, n, i) { this.name = e, this.rank = t, this.schema = n, this.spec = i, this.attrs = xu(e, i.attrs), this.excluded = null; let s = gu(this.attrs); this.instance = s ? new P(this, s) : null } create(e = null) { return !e && this.instance ? this.instance : new P(this, bu(this.attrs, e)) } static compile(e, t) { let n = Object.create(null), i = 0; return e.forEach((s, u) => n[s] = new Vn(s, i++, t, u)), n } removeFromSet(e) { for (var t = 0; t < e.length; t++)e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (e[t].type == this) return e[t] } checkAttrs(e) { yu(this.attrs, e, "mark", this.name) } excludes(e) { return this.excluded.indexOf(e) > -1 } } class wu { constructor(e) { this.linebreakReplacement = null, this.cached = Object.create(null); let t = this.spec = {}; for (let i in e) t[i] = e[i]; t.nodes = G.from(e.nodes), t.marks = G.from(e.marks || {}), this.nodes = Bi.compile(this.spec.nodes, this), this.marks = Vn.compile(this.spec.marks, this); let n = Object.create(null); for (let i in this.nodes) { if (i in this.marks) throw new RangeError(i + " can not be both a node and a mark"); let s = this.nodes[i], u = s.spec.content || "", o = s.spec.marks; if (s.contentMatch = n[u] || (n[u] = ct.parse(u, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) { if (this.linebreakReplacement) throw new RangeError("Multiple linebreak nodes defined"); if (!s.isInline || !s.isLeaf) throw new RangeError("Linebreak replacement nodes must be inline leaf nodes"); this.linebreakReplacement = s } s.markSet = o == "_" ? null : o ? zi(this, o.split(" ")) : o == "" || !s.inlineContent ? [] : null } for (let i in this.marks) { let s = this.marks[i], u = s.spec.excludes; s.excluded = u == null ? [s] : u == "" ? [] : zi(this, u.split(" ")) } this.nodeFromJSON = i => je.fromJSON(this, i), this.markFromJSON = i => P.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = Object.create(null) } node(e, t = null, n, i) { if (typeof e == "string") e = this.nodeType(e); else if (e instanceof Bi) { if (e.schema != this) throw new RangeError("Node type from different schema used (" + e.name + ")") } else throw new RangeError("Invalid node type: " + e); return e.createChecked(t, n, i) } text(e, t) { let n = this.nodes.text; return new An(n, n.defaultAttrs, e, P.setFrom(t)) } mark(e, t) { return typeof e == "string" && (e = this.marks[e]), e.create(t) } nodeType(e) { let t = this.nodes[e]; if (!t) throw new RangeError("Unknown node type: " + e); return t } } function zi(r, e) { let t = []; for (let n = 0; n < e.length; n++) { let i = e[n], s = r.marks[i], u = s; if (s) t.push(s); else for (let o in r.marks) { let l = r.marks[o]; (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && t.push(u = l) } if (!u) throw new SyntaxError("Unknown mark type: '" + e[n] + "'") } return t } function Bl(r) { return r.tag != null } function zl(r) { return r.style != null } class We { constructor(e, t) { this.schema = e, this.rules = t, this.tags = [], this.styles = []; let n = this.matchedStyles = []; t.forEach(i => { if (Bl(i)) this.tags.push(i); else if (zl(i)) { let s = /[^=]*/.exec(i.style)[0]; n.indexOf(s) < 0 && n.push(s), this.styles.push(i) } }), this.normalizeLists = !this.tags.some(i => { if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return !1; let s = e.nodes[i.node]; return s.contentMatch.matchType(s) }) } parse(e, t = {}) { let n = new _i(this, t, !1); return n.addAll(e, P.none, t.from, t.to), n.finish() } parseSlice(e, t = {}) { let n = new _i(this, t, !0); return n.addAll(e, P.none, t.from, t.to), x.maxOpen(n.finish()) } matchTag(e, t, n) { for (let i = n ? this.tags.indexOf(n) + 1 : 0; i < this.tags.length; i++) { let s = this.tags[i]; if (Fl(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) { if (s.getAttrs) { let u = s.getAttrs(e); if (u === !1) continue; s.attrs = u || void 0 } return s } } } matchStyle(e, t, n, i) { for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) { let u = this.styles[s], o = u.style; if (!(o.indexOf(e) != 0 || u.context && !n.matchesContext(u.context) || o.length > e.length && (o.charCodeAt(e.length) != 61 || o.slice(e.length + 1) != t))) { if (u.getAttrs) { let l = u.getAttrs(t); if (l === !1) continue; u.attrs = l || void 0 } return u } } } static schemaRules(e) { let t = []; function n(i) { let s = i.priority == null ? 50 : i.priority, u = 0; for (; u < t.length; u++) { let o = t[u]; if ((o.priority == null ? 50 : o.priority) < s) break } t.splice(u, 0, i) } for (let i in e.marks) { let s = e.marks[i].spec.parseDOM; s && s.forEach(u => { n(u = Fi(u)), u.mark || u.ignore || u.clearMark || (u.mark = i) }) } for (let i in e.nodes) { let s = e.nodes[i].spec.parseDOM; s && s.forEach(u => { n(u = Fi(u)), u.node || u.ignore || u.mark || (u.node = i) }) } return t } static fromSchema(e) { return e.cached.domParser || (e.cached.domParser = new We(e, We.schemaRules(e))) } } const Su = { address: !0, article: !0, aside: !0, blockquote: !0, canvas: !0, dd: !0, div: !0, dl: !0, fieldset: !0, figcaption: !0, figure: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, li: !0, noscript: !0, ol: !0, output: !0, p: !0, pre: !0, section: !0, table: !0, tfoot: !0, ul: !0 }, $l = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 }, Cu = { ol: !0, ul: !0 }, Jt = 1, vr = 2, Vt = 4; function $i(r, e, t) { return e != null ? (e ? Jt : 0) | (e === "full" ? vr : 0) : r && r.whitespace == "pre" ? Jt | vr : t & ~Vt } class cn { constructor(e, t, n, i, s, u) { this.type = e, this.attrs = t, this.marks = n, this.solid = i, this.options = u, this.content = [], this.activeMarks = P.none, this.match = s || (u & Vt ? null : e.contentMatch) } findWrapping(e) { if (!this.match) { if (!this.type) return []; let t = this.type.contentMatch.fillBefore(y.from(e)); if (t) this.match = this.type.contentMatch.matchFragment(t); else { let n = this.type.contentMatch, i; return (i = n.findWrapping(e.type)) ? (this.match = n, i) : null } } return this.match.findWrapping(e.type) } finish(e) { if (!(this.options & Jt)) { let n = this.content[this.content.length - 1], i; if (n && n.isText && (i = /[ \t\r\n\u000c]+$/.exec(n.text))) { let s = n; n.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length)) } } let t = y.from(this.content); return !e && this.match && (t = t.append(this.match.fillBefore(y.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t } inlineContext(e) { return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Su.hasOwnProperty(e.parentNode.nodeName.toLowerCase()) } } class _i {
    constructor(e, t, n) { this.parser = e, this.options = t, this.isOpen = n, this.open = 0, this.localPreserveWS = !1; let i = t.topNode, s, u = $i(null, t.preserveWhitespace, 0) | (n ? Vt : 0); i ? s = new cn(i.type, i.attrs, P.none, !0, t.topMatch || i.type.contentMatch, u) : n ? s = new cn(null, null, P.none, !0, null, u) : s = new cn(e.schema.topNodeType, null, P.none, !0, null, u), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1 } get top() { return this.nodes[this.open] } addDOM(e, t) { e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t) } addTextNode(e, t) {
        let n = e.nodeValue, i = this.top, s = i.options & vr ? "full" : this.localPreserveWS || (i.options & Jt) > 0; if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
            if (s) s !== "full" ? n = n.replace(/\r?\n|\r/g, " ") : n = n.replace(/\r\n?/g, `
`); else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) { let u = i.content[i.content.length - 1], o = e.previousSibling; (!u || o && o.nodeName == "BR" || u.isText && /[ \t\r\n\u000c]$/.test(u.text)) && (n = n.slice(1)) } n && this.insertNode(this.parser.schema.text(n), t, !/\S/.test(n)), this.findInText(e)
        } else this.findInside(e)
    } addElement(e, t, n) { let i = this.localPreserveWS, s = this.top; (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0); let u = e.nodeName.toLowerCase(), o; Cu.hasOwnProperty(u) && this.parser.normalizeLists && _l(e); let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (o = this.parser.matchTag(e, this, n)); e: if (l ? l.ignore : $l.hasOwnProperty(u)) this.findInside(e), this.ignoreFallback(e, t); else if (!l || l.skip || l.closeParent) { l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip); let a, c = this.needsBlock; if (Su.hasOwnProperty(u)) s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), a = !0, s.type || (this.needsBlock = !0); else if (!e.firstChild) { this.leafFallback(e, t); break e } let d = l && l.skip ? t : this.readStyles(e, t); d && this.addAll(e, d), a && this.sync(s), this.needsBlock = c } else { let a = this.readStyles(e, t); a && this.addElementByRule(e, l, a, l.consuming === !1 ? o : void 0) } this.localPreserveWS = i } leafFallback(e, t) {
        e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t)
    } ignoreFallback(e, t) { e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0) } readStyles(e, t) { let n = e.style; if (n && n.length) for (let i = 0; i < this.parser.matchedStyles.length; i++) { let s = this.parser.matchedStyles[i], u = n.getPropertyValue(s); if (u) for (let o = void 0; ;) { let l = this.parser.matchStyle(s, u, this, o); if (!l) break; if (l.ignore) return null; if (l.clearMark ? t = t.filter(a => !l.clearMark(a)) : t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1) o = l; else break } } return t } addElementByRule(e, t, n, i) { let s, u; if (t.node) if (u = this.parser.schema.nodes[t.node], u.isLeaf) this.insertNode(u.create(t.attrs), n, e.nodeName == "BR") || this.leafFallback(e, n); else { let l = this.enter(u, t.attrs || null, n, t.preserveWhitespace); l && (s = !0, n = l) } else { let l = this.parser.schema.marks[t.mark]; n = n.concat(l.create(t.attrs)) } let o = this.top; if (u && u.isLeaf) this.findInside(e); else if (i) this.addElement(e, n, i); else if (t.getContent) this.findInside(e), t.getContent(e, this.parser.schema).forEach(l => this.insertNode(l, n, !1)); else { let l = e; typeof t.contentElement == "string" ? l = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? l = t.contentElement(e) : t.contentElement && (l = t.contentElement), this.findAround(e, l, !0), this.addAll(l, n), this.findAround(e, l, !1) } s && this.sync(o) && this.open-- } addAll(e, t, n, i) { let s = n || 0; for (let u = n ? e.childNodes[n] : e.firstChild, o = i == null ? null : e.childNodes[i]; u != o; u = u.nextSibling, ++s)this.findAtPoint(e, s), this.addDOM(u, t); this.findAtPoint(e, s) } findPlace(e, t, n) { let i, s; for (let u = this.open, o = 0; u >= 0; u--) { let l = this.nodes[u], a = l.findWrapping(e); if (a && (!i || i.length > a.length + o) && (i = a, s = l, !a.length)) break; if (l.solid) { if (n) break; o += 2 } } if (!i) return null; this.sync(s); for (let u = 0; u < i.length; u++)t = this.enterInner(i[u], null, t, !1); return t } insertNode(e, t, n) { if (e.isInline && this.needsBlock && !this.top.type) { let s = this.textblockFromContext(); s && (t = this.enterInner(s, null, t)) } let i = this.findPlace(e, t, n); if (i) { this.closeExtra(); let s = this.top; s.match && (s.match = s.match.matchType(e.type)); let u = P.none; for (let o of i.concat(e.marks)) (s.type ? s.type.allowsMarkType(o.type) : Vi(o.type, e.type)) && (u = o.addToSet(u)); return s.content.push(e.mark(u)), !0 } return !1 } enter(e, t, n, i) { let s = this.findPlace(e.create(t), n, !1); return s && (s = this.enterInner(e, t, n, !0, i)), s } enterInner(e, t, n, i = !1, s) { this.closeExtra(); let u = this.top; u.match = u.match && u.match.matchType(e); let o = $i(e, s, u.options); u.options & Vt && u.content.length == 0 && (o |= Vt); let l = P.none; return n = n.filter(a => (u.type ? u.type.allowsMarkType(a.type) : Vi(a.type, e)) ? (l = a.addToSet(l), !1) : !0), this.nodes.push(new cn(e, t, l, i, null, o)), this.open++, n } closeExtra(e = !1) { let t = this.nodes.length - 1; if (t > this.open) { for (; t > this.open; t--)this.nodes[t - 1].content.push(this.nodes[t].finish(e)); this.nodes.length = this.open + 1 } } finish() { return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen)) } sync(e) { for (let t = this.open; t >= 0; t--) { if (this.nodes[t] == e) return this.open = t, !0; this.localPreserveWS && (this.nodes[t].options |= Jt) } return !1 } get currentPos() { this.closeExtra(); let e = 0; for (let t = this.open; t >= 0; t--) { let n = this.nodes[t].content; for (let i = n.length - 1; i >= 0; i--)e += n[i].nodeSize; t && e++ } return e } findAtPoint(e, t) { if (this.find) for (let n = 0; n < this.find.length; n++)this.find[n].node == e && this.find[n].offset == t && (this.find[n].pos = this.currentPos) } findInside(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos) } findAround(e, t, n) { if (e != t && this.find) for (let i = 0; i < this.find.length; i++)this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (n ? 2 : 4) && (this.find[i].pos = this.currentPos) } findInText(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset)) } matchesContext(e) { if (e.indexOf("|") > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this); let t = e.split("/"), n = this.options.context, i = !this.isOpen && (!n || n.parent.type == this.nodes[0].type), s = -(n ? n.depth + 1 : 0) + (i ? 0 : 1), u = (o, l) => { for (; o >= 0; o--) { let a = t[o]; if (a == "") { if (o == t.length - 1 || o == 0) continue; for (; l >= s; l--)if (u(o - 1, l)) return !0; return !1 } else { let c = l > 0 || l == 0 && i ? this.nodes[l].type : n && l >= s ? n.node(l - s).type : null; if (!c || c.name != a && !c.isInGroup(a)) return !1; l-- } } return !0 }; return u(t.length - 1, this.open) } textblockFromContext() { let e = this.options.context; if (e) for (let t = e.depth; t >= 0; t--) { let n = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType; if (n && n.isTextblock && n.defaultAttrs) return n } for (let t in this.parser.schema.nodes) { let n = this.parser.schema.nodes[t]; if (n.isTextblock && n.defaultAttrs) return n } }
} function _l(r) { for (let e = r.firstChild, t = null; e; e = e.nextSibling) { let n = e.nodeType == 1 ? e.nodeName.toLowerCase() : null; n && Cu.hasOwnProperty(n) && t ? (t.appendChild(e), e = t) : n == "li" ? t = e : n && (t = null) } } function Fl(r, e) { return (r.matches || r.msMatchesSelector || r.webkitMatchesSelector || r.mozMatchesSelector).call(r, e) } function Fi(r) { let e = {}; for (let t in r) e[t] = r[t]; return e } function Vi(r, e) { let t = e.schema.nodes; for (let n in t) { let i = t[n]; if (!i.allowsMarkType(r)) continue; let s = [], u = o => { s.push(o); for (let l = 0; l < o.edgeCount; l++) { let { type: a, next: c } = o.edge(l); if (a == e || s.indexOf(c) < 0 && u(c)) return !0 } }; if (u(i.contentMatch)) return !0 } } class gt { constructor(e, t) { this.nodes = e, this.marks = t } serializeFragment(e, t = {}, n) { n || (n = ir(t).createDocumentFragment()); let i = n, s = []; return e.forEach(u => { if (s.length || u.marks.length) { let o = 0, l = 0; for (; o < s.length && l < u.marks.length;) { let a = u.marks[l]; if (!this.marks[a.type.name]) { l++; continue } if (!a.eq(s[o][0]) || a.type.spec.spanning === !1) break; o++, l++ } for (; o < s.length;)i = s.pop()[1]; for (; l < u.marks.length;) { let a = u.marks[l++], c = this.serializeMark(a, u.isInline, t); c && (s.push([a, i]), i.appendChild(c.dom), i = c.contentDOM || c.dom) } } i.appendChild(this.serializeNodeInner(u, t)) }), n } serializeNodeInner(e, t) { let { dom: n, contentDOM: i } = xn(ir(t), this.nodes[e.type.name](e), null, e.attrs); if (i) { if (e.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec"); this.serializeFragment(e.content, t, i) } return n } serializeNode(e, t = {}) { let n = this.serializeNodeInner(e, t); for (let i = e.marks.length - 1; i >= 0; i--) { let s = this.serializeMark(e.marks[i], e.isInline, t); s && ((s.contentDOM || s.dom).appendChild(n), n = s.dom) } return n } serializeMark(e, t, n = {}) { let i = this.marks[e.type.name]; return i && xn(ir(n), i(e, t), null, e.attrs) } static renderSpec(e, t, n = null, i) { return xn(e, t, n, i) } static fromSchema(e) { return e.cached.domSerializer || (e.cached.domSerializer = new gt(this.nodesFromSchema(e), this.marksFromSchema(e))) } static nodesFromSchema(e) { let t = qi(e.nodes); return t.text || (t.text = n => n.text), t } static marksFromSchema(e) { return qi(e.marks) } } function qi(r) { let e = {}; for (let t in r) { let n = r[t].spec.toDOM; n && (e[t] = n) } return e } function ir(r) { return r.document || window.document } const Hi = new WeakMap; function Vl(r) { let e = Hi.get(r); return e === void 0 && Hi.set(r, e = ql(r)), e } function ql(r) { let e = null; function t(n) { if (n && typeof n == "object") if (Array.isArray(n)) if (typeof n[0] == "string") e || (e = []), e.push(n); else for (let i = 0; i < n.length; i++)t(n[i]); else for (let i in n) t(n[i]) } return t(r), e } function xn(r, e, t, n) { if (typeof e == "string") return { dom: r.createTextNode(e) }; if (e.nodeType != null) return { dom: e }; if (e.dom && e.dom.nodeType != null) return e; let i = e[0], s; if (typeof i != "string") throw new RangeError("Invalid array passed to renderSpec"); if (n && (s = Vl(n)) && s.indexOf(e) > -1) throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack."); let u = i.indexOf(" "); u > 0 && (t = i.slice(0, u), i = i.slice(u + 1)); let o, l = t ? r.createElementNS(t, i) : r.createElement(i), a = e[1], c = 1; if (a && typeof a == "object" && a.nodeType == null && !Array.isArray(a)) { c = 2; for (let d in a) if (a[d] != null) { let f = d.indexOf(" "); f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), a[d]) : d == "style" && l.style ? l.style.cssText = a[d] : l.setAttribute(d, a[d]) } } for (let d = c; d < e.length; d++) { let f = e[d]; if (f === 0) { if (d < e.length - 1 || d > c) throw new RangeError("Content hole must be the only child of its parent node"); return { dom: l, contentDOM: l } } else { let { dom: h, contentDOM: p } = xn(r, f, t, n); if (l.appendChild(h), p) { if (o) throw new RangeError("Multiple content holes"); o = p } } } return { dom: l, contentDOM: o } } const Tu = 65535, Eu = Math.pow(2, 16); function Hl(r, e) { return r + e * Eu } function ji(r) { return r & Tu } function jl(r) { return (r - (r & Tu)) / Eu } const Mu = 1, Nu = 2, kn = 4, Au = 8; class Dr { constructor(e, t, n) { this.pos = e, this.delInfo = t, this.recover = n } get deleted() { return (this.delInfo & Au) > 0 } get deletedBefore() { return (this.delInfo & (Mu | kn)) > 0 } get deletedAfter() { return (this.delInfo & (Nu | kn)) > 0 } get deletedAcross() { return (this.delInfo & kn) > 0 } } class de { constructor(e, t = !1) { if (this.ranges = e, this.inverted = t, !e.length && de.empty) return de.empty } recover(e) { let t = 0, n = ji(e); if (!this.inverted) for (let i = 0; i < n; i++)t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; return this.ranges[n * 3] + t + jl(e) } mapResult(e, t = 1) { return this._map(e, t, !1) } map(e, t = 1) { return this._map(e, t, !0) } _map(e, t, n) { let i = 0, s = this.inverted ? 2 : 1, u = this.inverted ? 1 : 2; for (let o = 0; o < this.ranges.length; o += 3) { let l = this.ranges[o] - (this.inverted ? i : 0); if (l > e) break; let a = this.ranges[o + s], c = this.ranges[o + u], d = l + a; if (e <= d) { let f = a ? e == l ? -1 : e == d ? 1 : t : t, h = l + i + (f < 0 ? 0 : c); if (n) return h; let p = e == (t < 0 ? l : d) ? null : Hl(o / 3, e - l), m = e == l ? Nu : e == d ? Mu : kn; return (t < 0 ? e != l : e != d) && (m |= Au), new Dr(h, m, p) } i += c - a } return n ? e + i : new Dr(e + i, 0, null) } touches(e, t) { let n = 0, i = ji(t), s = this.inverted ? 2 : 1, u = this.inverted ? 1 : 2; for (let o = 0; o < this.ranges.length; o += 3) { let l = this.ranges[o] - (this.inverted ? n : 0); if (l > e) break; let a = this.ranges[o + s], c = l + a; if (e <= c && o == i * 3) return !0; n += this.ranges[o + u] - a } return !1 } forEach(e) { let t = this.inverted ? 2 : 1, n = this.inverted ? 1 : 2; for (let i = 0, s = 0; i < this.ranges.length; i += 3) { let u = this.ranges[i], o = u - (this.inverted ? s : 0), l = u + (this.inverted ? 0 : s), a = this.ranges[i + t], c = this.ranges[i + n]; e(o, o + a, l, l + c), s += c - a } } invert() { return new de(this.ranges, !this.inverted) } toString() { return (this.inverted ? "-" : "") + JSON.stringify(this.ranges) } static offset(e) { return e == 0 ? de.empty : new de(e < 0 ? [0, -e, 0] : [0, 0, e]) } } de.empty = new de([]); class Kt { constructor(e, t, n = 0, i = e ? e.length : 0) { this.mirror = t, this.from = n, this.to = i, this._maps = e || [], this.ownData = !(e || t) } get maps() { return this._maps } slice(e = 0, t = this.maps.length) { return new Kt(this._maps, this.mirror, e, t) } appendMap(e, t) { this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t) } appendMapping(e) { for (let t = 0, n = this._maps.length; t < e._maps.length; t++) { let i = e.getMirror(t); this.appendMap(e._maps[t], i != null && i < t ? n + i : void 0) } } getMirror(e) { if (this.mirror) { for (let t = 0; t < this.mirror.length; t++)if (this.mirror[t] == e) return this.mirror[t + (t % 2 ? -1 : 1)] } } setMirror(e, t) { this.mirror || (this.mirror = []), this.mirror.push(e, t) } appendMappingInverted(e) { for (let t = e.maps.length - 1, n = this._maps.length + e._maps.length; t >= 0; t--) { let i = e.getMirror(t); this.appendMap(e._maps[t].invert(), i != null && i > t ? n - i - 1 : void 0) } } invert() { let e = new Kt; return e.appendMappingInverted(this), e } map(e, t = 1) { if (this.mirror) return this._map(e, t, !0); for (let n = this.from; n < this.to; n++)e = this._maps[n].map(e, t); return e } mapResult(e, t = 1) { return this._map(e, t, !1) } _map(e, t, n) { let i = 0; for (let s = this.from; s < this.to; s++) { let u = this._maps[s], o = u.mapResult(e, t); if (o.recover != null) { let l = this.getMirror(s); if (l != null && l > s && l < this.to) { s = l, e = this._maps[l].recover(o.recover); continue } } i |= o.delInfo, e = o.pos } return n ? e : new Dr(e, i, null) } } const sr = Object.create(null); class te { getMap() { return de.empty } merge(e) { return null } static fromJSON(e, t) { if (!t || !t.stepType) throw new RangeError("Invalid input for Step.fromJSON"); let n = sr[t.stepType]; if (!n) throw new RangeError(`No step type ${t.stepType} defined`); return n.fromJSON(e, t) } static jsonID(e, t) { if (e in sr) throw new RangeError("Duplicate use of step JSON ID " + e); return sr[e] = t, t.prototype.jsonID = e, t } } class F { constructor(e, t) { this.doc = e, this.failed = t } static ok(e) { return new F(e, null) } static fail(e) { return new F(null, e) } static fromReplace(e, t, n, i) { try { return F.ok(e.replace(t, n, i)) } catch (s) { if (s instanceof En) return F.fail(s.message); throw s } } } function Yr(r, e, t) { let n = []; for (let i = 0; i < r.childCount; i++) { let s = r.child(i); s.content.size && (s = s.copy(Yr(s.content, e, s))), s.isInline && (s = e(s, t, i)), n.push(s) } return y.fromArray(n) } class Fe extends te { constructor(e, t, n) { super(), this.from = e, this.to = t, this.mark = n } apply(e) { let t = e.slice(this.from, this.to), n = e.resolve(this.from), i = n.node(n.sharedDepth(this.to)), s = new x(Yr(t.content, (u, o) => !u.isAtom || !o.type.allowsMarkType(this.mark.type) ? u : u.mark(this.mark.addToSet(u.marks)), i), t.openStart, t.openEnd); return F.fromReplace(e, this.from, this.to, s) } invert() { return new Te(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1); return t.deleted && n.deleted || t.pos >= n.pos ? null : new Fe(t.pos, n.pos, this.mark) } merge(e) { return e instanceof Fe && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Fe(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "addMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON"); return new Fe(t.from, t.to, e.markFromJSON(t.mark)) } } te.jsonID("addMark", Fe); class Te extends te { constructor(e, t, n) { super(), this.from = e, this.to = t, this.mark = n } apply(e) { let t = e.slice(this.from, this.to), n = new x(Yr(t.content, i => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd); return F.fromReplace(e, this.from, this.to, n) } invert() { return new Fe(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1); return t.deleted && n.deleted || t.pos >= n.pos ? null : new Te(t.pos, n.pos, this.mark) } merge(e) { return e instanceof Te && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Te(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "removeMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON"); return new Te(t.from, t.to, e.markFromJSON(t.mark)) } } te.jsonID("removeMark", Te); class Ve extends te { constructor(e, t) { super(), this.pos = e, this.mark = t } apply(e) { let t = e.nodeAt(this.pos); if (!t) return F.fail("No node at mark step's position"); let n = t.type.create(t.attrs, null, this.mark.addToSet(t.marks)); return F.fromReplace(e, this.pos, this.pos + 1, new x(y.from(n), 0, t.isLeaf ? 0 : 1)) } invert(e) { let t = e.nodeAt(this.pos); if (t) { let n = this.mark.addToSet(t.marks); if (n.length == t.marks.length) { for (let i = 0; i < t.marks.length; i++)if (!t.marks[i].isInSet(n)) return new Ve(this.pos, t.marks[i]); return new Ve(this.pos, this.mark) } } return new dt(this.pos, this.mark) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new Ve(t.pos, this.mark) } toJSON() { return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, t) { if (typeof t.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON"); return new Ve(t.pos, e.markFromJSON(t.mark)) } } te.jsonID("addNodeMark", Ve); class dt extends te { constructor(e, t) { super(), this.pos = e, this.mark = t } apply(e) { let t = e.nodeAt(this.pos); if (!t) return F.fail("No node at mark step's position"); let n = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks)); return F.fromReplace(e, this.pos, this.pos + 1, new x(y.from(n), 0, t.isLeaf ? 0 : 1)) } invert(e) { let t = e.nodeAt(this.pos); return !t || !this.mark.isInSet(t.marks) ? this : new Ve(this.pos, this.mark) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new dt(t.pos, this.mark) } toJSON() { return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, t) { if (typeof t.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON"); return new dt(t.pos, e.markFromJSON(t.mark)) } } te.jsonID("removeNodeMark", dt); class q extends te { constructor(e, t, n, i = !1) { super(), this.from = e, this.to = t, this.slice = n, this.structure = i } apply(e) { return this.structure && Rr(e, this.from, this.to) ? F.fail("Structure replace would overwrite content") : F.fromReplace(e, this.from, this.to, this.slice) } getMap() { return new de([this.from, this.to - this.from, this.slice.size]) } invert(e) { return new q(this.from, this.from + this.slice.size, e.slice(this.from, this.to)) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1); return t.deletedAcross && n.deletedAcross ? null : new q(t.pos, Math.max(t.pos, n.pos), this.slice, this.structure) } merge(e) { if (!(e instanceof q) || e.structure || this.structure) return null; if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) { let t = this.slice.size + e.slice.size == 0 ? x.empty : new x(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd); return new q(this.from, this.to + (e.to - e.from), t, this.structure) } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) { let t = this.slice.size + e.slice.size == 0 ? x.empty : new x(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd); return new q(e.from, this.to, t, this.structure) } else return null } toJSON() { let e = { stepType: "replace", from: this.from, to: this.to }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON"); return new q(t.from, t.to, x.fromJSON(e, t.slice), !!t.structure) } } te.jsonID("replace", q); class j extends te { constructor(e, t, n, i, s, u, o = !1) { super(), this.from = e, this.to = t, this.gapFrom = n, this.gapTo = i, this.slice = s, this.insert = u, this.structure = o } apply(e) { if (this.structure && (Rr(e, this.from, this.gapFrom) || Rr(e, this.gapTo, this.to))) return F.fail("Structure gap-replace would overwrite content"); let t = e.slice(this.gapFrom, this.gapTo); if (t.openStart || t.openEnd) return F.fail("Gap is not a flat range"); let n = this.slice.insertAt(this.insert, t.content); return n ? F.fromReplace(e, this.from, this.to, n) : F.fail("Content does not fit in gap") } getMap() { return new de([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]) } invert(e) { let t = this.gapTo - this.gapFrom; return new j(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? n.pos : e.map(this.gapTo, 1); return t.deletedAcross && n.deletedAcross || i < t.pos || s > n.pos ? null : new j(t.pos, n.pos, i, s, this.slice, this.insert, this.structure) } toJSON() { let e = { stepType: "replaceAround", from: this.from, to: this.to, gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON"); return new j(t.from, t.to, t.gapFrom, t.gapTo, x.fromJSON(e, t.slice), t.insert, !!t.structure) } } te.jsonID("replaceAround", j); function Rr(r, e, t) { let n = r.resolve(e), i = t - e, s = n.depth; for (; i > 0 && s > 0 && n.indexAfter(s) == n.node(s).childCount;)s--, i--; if (i > 0) { let u = n.node(s).maybeChild(n.indexAfter(s)); for (; i > 0;) { if (!u || u.isLeaf) return !0; u = u.firstChild, i-- } } return !1 } function Wl(r, e, t, n) { let i = [], s = [], u, o; r.doc.nodesBetween(e, t, (l, a, c) => { if (!l.isInline) return; let d = l.marks; if (!n.isInSet(d) && c.type.allowsMarkType(n.type)) { let f = Math.max(a, e), h = Math.min(a + l.nodeSize, t), p = n.addToSet(d); for (let m = 0; m < d.length; m++)d[m].isInSet(p) || (u && u.to == f && u.mark.eq(d[m]) ? u.to = h : i.push(u = new Te(f, h, d[m]))); o && o.to == f ? o.to = h : s.push(o = new Fe(f, h, n)) } }), i.forEach(l => r.step(l)), s.forEach(l => r.step(l)) } function Ul(r, e, t, n) { let i = [], s = 0; r.doc.nodesBetween(e, t, (u, o) => { if (!u.isInline) return; s++; let l = null; if (n instanceof Vn) { let a = u.marks, c; for (; c = n.isInSet(a);)(l || (l = [])).push(c), a = c.removeFromSet(a) } else n ? n.isInSet(u.marks) && (l = [n]) : l = u.marks; if (l && l.length) { let a = Math.min(o + u.nodeSize, t); for (let c = 0; c < l.length; c++) { let d = l[c], f; for (let h = 0; h < i.length; h++) { let p = i[h]; p.step == s - 1 && d.eq(i[h].style) && (f = p) } f ? (f.to = a, f.step = s) : i.push({ style: d, from: Math.max(o, e), to: a, step: s }) } } }), i.forEach(u => r.step(new Te(u.from, u.to, u.style))) } function Xr(r, e, t, n = t.contentMatch, i = !0) { let s = r.doc.nodeAt(e), u = [], o = e + 1; for (let l = 0; l < s.childCount; l++) { let a = s.child(l), c = o + a.nodeSize, d = n.matchType(a.type); if (!d) u.push(new q(o, c, x.empty)); else { n = d; for (let f = 0; f < a.marks.length; f++)t.allowsMarkType(a.marks[f].type) || r.step(new Te(o, c, a.marks[f])); if (i && a.isText && t.whitespace != "pre") { let f, h = /\r?\n|\r/g, p; for (; f = h.exec(a.text);)p || (p = new x(y.from(t.schema.text(" ", t.allowedMarks(a.marks))), 0, 0)), u.push(new q(o + f.index, o + f.index + f[0].length, p)) } } o = c } if (!n.validEnd) { let l = n.fillBefore(y.empty, !0); r.replace(o, o, new x(l, 0, 0)) } for (let l = u.length - 1; l >= 0; l--)r.step(u[l]) } function Jl(r, e, t) { return (e == 0 || r.canReplace(e, r.childCount)) && (t == r.childCount || r.canReplace(0, t)) } function It(r) { let t = r.parent.content.cutByIndex(r.startIndex, r.endIndex); for (let n = r.depth; ; --n) { let i = r.$from.node(n), s = r.$from.index(n), u = r.$to.indexAfter(n); if (n < r.depth && i.canReplace(s, u, t)) return n; if (n == 0 || i.type.spec.isolating || !Jl(i, s, u)) break } return null } function Kl(r, e, t) { let { $from: n, $to: i, depth: s } = e, u = n.before(s + 1), o = i.after(s + 1), l = u, a = o, c = y.empty, d = 0; for (let p = s, m = !1; p > t; p--)m || n.index(p) > 0 ? (m = !0, c = y.from(n.node(p).copy(c)), d++) : l--; let f = y.empty, h = 0; for (let p = s, m = !1; p > t; p--)m || i.after(p + 1) < i.end(p) ? (m = !0, f = y.from(i.node(p).copy(f)), h++) : a++; r.step(new j(l, a, u, o, new x(c.append(f), d, h), c.size - d, !0)) } function ei(r, e, t = null, n = r) { let i = Gl(r, e), s = i && Zl(n, e); return s ? i.map(Wi).concat({ type: e, attrs: t }).concat(s.map(Wi)) : null } function Wi(r) { return { type: r, attrs: null } } function Gl(r, e) { let { parent: t, startIndex: n, endIndex: i } = r, s = t.contentMatchAt(n).findWrapping(e); if (!s) return null; let u = s.length ? s[0] : e; return t.canReplaceWith(n, i, u) ? s : null } function Zl(r, e) { let { parent: t, startIndex: n, endIndex: i } = r, s = t.child(n), u = e.contentMatch.findWrapping(s.type); if (!u) return null; let l = (u.length ? u[u.length - 1] : e).contentMatch; for (let a = n; l && a < i; a++)l = l.matchType(t.child(a).type); return !l || !l.validEnd ? null : u } function Ql(r, e, t) { let n = y.empty; for (let u = t.length - 1; u >= 0; u--) { if (n.size) { let o = t[u].type.contentMatch.matchFragment(n); if (!o || !o.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper") } n = y.from(t[u].type.create(t[u].attrs, n)) } let i = e.start, s = e.end; r.step(new j(i, s, i, s, new x(n, 0, 0), t.length, !0)) } function Yl(r, e, t, n, i) { if (!n.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock"); let s = r.steps.length; r.doc.nodesBetween(e, t, (u, o) => { let l = typeof i == "function" ? i(u) : i; if (u.isTextblock && !u.hasMarkup(n, l) && Xl(r.doc, r.mapping.slice(s).map(o), n)) { let a = null; if (n.schema.linebreakReplacement) { let h = n.whitespace == "pre", p = !!n.contentMatch.matchType(n.schema.linebreakReplacement); h && !p ? a = !1 : !h && p && (a = !0) } a === !1 && vu(r, u, o, s), Xr(r, r.mapping.slice(s).map(o, 1), n, void 0, a === null); let c = r.mapping.slice(s), d = c.map(o, 1), f = c.map(o + u.nodeSize, 1); return r.step(new j(d, f, d + 1, f - 1, new x(y.from(n.create(l, null, u.marks)), 0, 0), 1, !0)), a === !0 && Ou(r, u, o, s), !1 } }) } function Ou(r, e, t, n) { e.forEach((i, s) => { if (i.isText) { let u, o = /\r?\n|\r/g; for (; u = o.exec(i.text);) { let l = r.mapping.slice(n).map(t + 1 + s + u.index); r.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create()) } } }) } function vu(r, e, t, n) {
    e.forEach((i, s) => {
        if (i.type == i.type.schema.linebreakReplacement) {
            let u = r.mapping.slice(n).map(t + 1 + s); r.replaceWith(u, u + 1, e.type.schema.text(`
`))
        }
    })
} function Xl(r, e, t) { let n = r.resolve(e), i = n.index(); return n.parent.canReplaceWith(i, i + 1, t) } function ea(r, e, t, n, i) { let s = r.doc.nodeAt(e); if (!s) throw new RangeError("No node at given position"); t || (t = s.type); let u = t.create(n, null, i || s.marks); if (s.isLeaf) return r.replaceWith(e, e + s.nodeSize, u); if (!t.validContent(s.content)) throw new RangeError("Invalid content for node type " + t.name); r.step(new j(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new x(y.from(u), 0, 0), 1, !0)) } function Re(r, e, t = 1, n) { let i = r.resolve(e), s = i.depth - t, u = n && n[n.length - 1] || i.parent; if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !u.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))) return !1; for (let a = i.depth - 1, c = t - 2; a > s; a--, c--) { let d = i.node(a), f = i.index(a); if (d.type.spec.isolating) return !1; let h = d.content.cutByIndex(f, d.childCount), p = n && n[c + 1]; p && (h = h.replaceChild(0, p.type.create(p.attrs))); let m = n && n[c] || d; if (!d.canReplace(f + 1, d.childCount) || !m.type.validContent(h)) return !1 } let o = i.indexAfter(s), l = n && n[0]; return i.node(s).canReplaceWith(o, o, l ? l.type : i.node(s + 1).type) } function ta(r, e, t = 1, n) { let i = r.doc.resolve(e), s = y.empty, u = y.empty; for (let o = i.depth, l = i.depth - t, a = t - 1; o > l; o--, a--) { s = y.from(i.node(o).copy(s)); let c = n && n[a]; u = y.from(c ? c.type.create(c.attrs, u) : i.node(o).copy(u)) } r.step(new q(e, e, new x(s.append(u), t, t), !0)) } function Qe(r, e) { let t = r.resolve(e), n = t.index(); return Du(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(n, n + 1) } function na(r, e) { e.content.size || r.type.compatibleContent(e.type); let t = r.contentMatchAt(r.childCount), { linebreakReplacement: n } = r.type.schema; for (let i = 0; i < e.childCount; i++) { let s = e.child(i), u = s.type == n ? r.type.schema.nodes.text : s.type; if (t = t.matchType(u), !t || !r.type.allowsMarks(s.marks)) return !1 } return t.validEnd } function Du(r, e) { return !!(r && e && !r.isLeaf && na(r, e)) } function qn(r, e, t = -1) { let n = r.resolve(e); for (let i = n.depth; ; i--) { let s, u, o = n.index(i); if (i == n.depth ? (s = n.nodeBefore, u = n.nodeAfter) : t > 0 ? (s = n.node(i + 1), o++, u = n.node(i).maybeChild(o)) : (s = n.node(i).maybeChild(o - 1), u = n.node(i + 1)), s && !s.isTextblock && Du(s, u) && n.node(i).canReplace(o, o + 1)) return e; if (i == 0) break; e = t < 0 ? n.before(i) : n.after(i) } } function ra(r, e, t) { let n = null, { linebreakReplacement: i } = r.doc.type.schema, s = r.doc.resolve(e - t), u = s.node().type; if (i && u.inlineContent) { let c = u.whitespace == "pre", d = !!u.contentMatch.matchType(i); c && !d ? n = !1 : !c && d && (n = !0) } let o = r.steps.length; if (n === !1) { let c = r.doc.resolve(e + t); vu(r, c.node(), c.before(), o) } u.inlineContent && Xr(r, e + t - 1, u, s.node().contentMatchAt(s.index()), n == null); let l = r.mapping.slice(o), a = l.map(e - t); if (r.step(new q(a, l.map(e + t, -1), x.empty, !0)), n === !0) { let c = r.doc.resolve(a); Ou(r, c.node(), c.before(), r.steps.length) } return r } function ia(r, e, t) { let n = r.resolve(e); if (n.parent.canReplaceWith(n.index(), n.index(), t)) return e; if (n.parentOffset == 0) for (let i = n.depth - 1; i >= 0; i--) { let s = n.index(i); if (n.node(i).canReplaceWith(s, s, t)) return n.before(i + 1); if (s > 0) return null } if (n.parentOffset == n.parent.content.size) for (let i = n.depth - 1; i >= 0; i--) { let s = n.indexAfter(i); if (n.node(i).canReplaceWith(s, s, t)) return n.after(i + 1); if (s < n.node(i).childCount) return null } return null } function Ru(r, e, t) { let n = r.resolve(e); if (!t.content.size) return e; let i = t.content; for (let s = 0; s < t.openStart; s++)i = i.firstChild.content; for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)for (let u = n.depth; u >= 0; u--) { let o = u == n.depth ? 0 : n.pos <= (n.start(u + 1) + n.end(u + 1)) / 2 ? -1 : 1, l = n.index(u) + (o > 0 ? 1 : 0), a = n.node(u), c = !1; if (s == 1) c = a.canReplace(l, l, i); else { let d = a.contentMatchAt(l).findWrapping(i.firstChild.type); c = d && a.canReplaceWith(l, l, d[0]) } if (c) return o == 0 ? n.pos : o < 0 ? n.before(u + 1) : n.after(u + 1) } return null } function Hn(r, e, t = e, n = x.empty) { if (e == t && !n.size) return null; let i = r.resolve(e), s = r.resolve(t); return Iu(i, s, n) ? new q(e, t, n) : new sa(i, s, n).fit() } function Iu(r, e, t) { return !t.openStart && !t.openEnd && r.start() == e.start() && r.parent.canReplace(r.index(), e.index(), t.content) } class sa { constructor(e, t, n) { this.$from = e, this.$to = t, this.unplaced = n, this.frontier = [], this.placed = y.empty; for (let i = 0; i <= e.depth; i++) { let s = e.node(i); this.frontier.push({ type: s.type, match: s.contentMatchAt(e.indexAfter(i)) }) } for (let i = e.depth; i > 0; i--)this.placed = y.from(e.node(i).copy(this.placed)) } get depth() { return this.frontier.length - 1 } fit() { for (; this.unplaced.size;) { let a = this.findFittable(); a ? this.placeNodes(a) : this.openMore() || this.dropNode() } let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, n = this.$from, i = this.close(e < 0 ? this.$to : n.doc.resolve(e)); if (!i) return null; let s = this.placed, u = n.depth, o = i.depth; for (; u && o && s.childCount == 1;)s = s.firstChild.content, u--, o--; let l = new x(s, u, o); return e > -1 ? new j(n.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || n.pos != this.$to.pos ? new q(n.pos, i.pos, l) : null } findFittable() { let e = this.unplaced.openStart; for (let t = this.unplaced.content, n = 0, i = this.unplaced.openEnd; n < e; n++) { let s = t.firstChild; if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= n) { e = n; break } t = s.content } for (let t = 1; t <= 2; t++)for (let n = t == 1 ? e : this.unplaced.openStart; n >= 0; n--) { let i, s = null; n ? (s = ur(this.unplaced.content, n - 1).firstChild, i = s.content) : i = this.unplaced.content; let u = i.firstChild; for (let o = this.depth; o >= 0; o--) { let { type: l, match: a } = this.frontier[o], c, d = null; if (t == 1 && (u ? a.matchType(u.type) || (d = a.fillBefore(y.from(u), !1)) : s && l.compatibleContent(s.type))) return { sliceDepth: n, frontierDepth: o, parent: s, inject: d }; if (t == 2 && u && (c = a.findWrapping(u.type))) return { sliceDepth: n, frontierDepth: o, parent: s, wrap: c }; if (s && a.matchType(s.type)) break } } } openMore() { let { content: e, openStart: t, openEnd: n } = this.unplaced, i = ur(e, t); return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new x(e, t + 1, Math.max(n, i.size + t >= e.size - n ? t + 1 : 0)), !0) } dropNode() { let { content: e, openStart: t, openEnd: n } = this.unplaced, i = ur(e, t); if (i.childCount <= 1 && t > 0) { let s = e.size - t <= t + i.size; this.unplaced = new x(zt(e, t - 1, 1), t - 1, s ? t - 1 : n) } else this.unplaced = new x(zt(e, t, 1), t, n) } placeNodes({ sliceDepth: e, frontierDepth: t, parent: n, inject: i, wrap: s }) { for (; this.depth > t;)this.closeFrontierNode(); if (s) for (let m = 0; m < s.length; m++)this.openFrontierNode(s[m]); let u = this.unplaced, o = n ? n.content : u.content, l = u.openStart - e, a = 0, c = [], { match: d, type: f } = this.frontier[t]; if (i) { for (let m = 0; m < i.childCount; m++)c.push(i.child(m)); d = d.matchFragment(i) } let h = o.size + e - (u.content.size - u.openEnd); for (; a < o.childCount;) { let m = o.child(a), g = d.matchType(m.type); if (!g) break; a++, (a > 1 || l == 0 || m.content.size) && (d = g, c.push(Pu(m.mark(f.allowedMarks(m.marks)), a == 1 ? l : 0, a == o.childCount ? h : -1))) } let p = a == o.childCount; p || (h = -1), this.placed = $t(this.placed, t, y.from(c)), this.frontier[t].match = d, p && h < 0 && n && n.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode(); for (let m = 0, g = o; m < h; m++) { let b = g.lastChild; this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content } this.unplaced = p ? e == 0 ? x.empty : new x(zt(u.content, e - 1, 1), e - 1, h < 0 ? u.openEnd : e - 1) : new x(zt(u.content, e, a), u.openStart, u.openEnd) } mustMoveInline() { if (!this.$to.parent.isTextblock) return -1; let e = this.frontier[this.depth], t; if (!e.type.isTextblock || !or(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth) return -1; let { depth: n } = this.$to, i = this.$to.after(n); for (; n > 1 && i == this.$to.end(--n);)++i; return i } findCloseLevel(e) { e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) { let { match: n, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), u = or(e, t, i, n, s); if (u) { for (let o = t - 1; o >= 0; o--) { let { match: l, type: a } = this.frontier[o], c = or(e, o, a, l, !0); if (!c || c.childCount) continue e } return { depth: t, fit: u, move: s ? e.doc.resolve(e.after(t + 1)) : e } } } } close(e) { let t = this.findCloseLevel(e); if (!t) return null; for (; this.depth > t.depth;)this.closeFrontierNode(); t.fit.childCount && (this.placed = $t(this.placed, t.depth, t.fit)), e = t.move; for (let n = t.depth + 1; n <= e.depth; n++) { let i = e.node(n), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(n)); this.openFrontierNode(i.type, i.attrs, s) } return e } openFrontierNode(e, t = null, n) { let i = this.frontier[this.depth]; i.match = i.match.matchType(e), this.placed = $t(this.placed, this.depth, y.from(e.create(t, n))), this.frontier.push({ type: e, match: e.contentMatch }) } closeFrontierNode() { let t = this.frontier.pop().match.fillBefore(y.empty, !0); t.childCount && (this.placed = $t(this.placed, this.frontier.length, t)) } } function zt(r, e, t) { return e == 0 ? r.cutByIndex(t, r.childCount) : r.replaceChild(0, r.firstChild.copy(zt(r.firstChild.content, e - 1, t))) } function $t(r, e, t) { return e == 0 ? r.append(t) : r.replaceChild(r.childCount - 1, r.lastChild.copy($t(r.lastChild.content, e - 1, t))) } function ur(r, e) { for (let t = 0; t < e; t++)r = r.firstChild.content; return r } function Pu(r, e, t) { if (e <= 0) return r; let n = r.content; return e > 1 && (n = n.replaceChild(0, Pu(n.firstChild, e - 1, n.childCount == 1 ? t - 1 : 0))), e > 0 && (n = r.type.contentMatch.fillBefore(n).append(n), t <= 0 && (n = n.append(r.type.contentMatch.matchFragment(n).fillBefore(y.empty, !0)))), r.copy(n) } function or(r, e, t, n, i) { let s = r.node(e), u = i ? r.indexAfter(e) : r.index(e); if (u == s.childCount && !t.compatibleContent(s.type)) return null; let o = n.fillBefore(s.content, !0, u); return o && !ua(t, s.content, u) ? o : null } function ua(r, e, t) { for (let n = t; n < e.childCount; n++)if (!r.allowsMarks(e.child(n).marks)) return !0; return !1 } function oa(r) { return r.spec.defining || r.spec.definingForContent } function la(r, e, t, n) { if (!n.size) return r.deleteRange(e, t); let i = r.doc.resolve(e), s = r.doc.resolve(t); if (Iu(i, s, n)) return r.step(new q(e, t, n)); let u = Bu(i, r.doc.resolve(t)); u[u.length - 1] == 0 && u.pop(); let o = -(i.depth + 1); u.unshift(o); for (let f = i.depth, h = i.pos - 1; f > 0; f--, h--) { let p = i.node(f).type.spec; if (p.defining || p.definingAsContext || p.isolating) break; u.indexOf(f) > -1 ? o = f : i.before(f) == h && u.splice(1, 0, -f) } let l = u.indexOf(o), a = [], c = n.openStart; for (let f = n.content, h = 0; ; h++) { let p = f.firstChild; if (a.push(p), h == n.openStart) break; f = p.content } for (let f = c - 1; f >= 0; f--) { let h = a[f], p = oa(h.type); if (p && !h.sameMarkup(i.node(Math.abs(o) - 1))) c = f; else if (p || !h.type.isTextblock) break } for (let f = n.openStart; f >= 0; f--) { let h = (f + c + 1) % (n.openStart + 1), p = a[h]; if (p) for (let m = 0; m < u.length; m++) { let g = u[(m + l) % u.length], b = !0; g < 0 && (b = !1, g = -g); let w = i.node(g - 1), C = i.index(g - 1); if (w.canReplaceWith(C, C, p.type, p.marks)) return r.replace(i.before(g), b ? s.after(g) : t, new x(Lu(n.content, 0, n.openStart, h), h, n.openEnd)) } } let d = r.steps.length; for (let f = u.length - 1; f >= 0 && (r.replace(e, t, n), !(r.steps.length > d)); f--) { let h = u[f]; h < 0 || (e = i.before(h), t = s.after(h)) } } function Lu(r, e, t, n, i) { if (e < t) { let s = r.firstChild; r = r.replaceChild(0, s.copy(Lu(s.content, e + 1, t, n, s))) } if (e > n) { let s = i.contentMatchAt(0), u = s.fillBefore(r).append(r); r = u.append(s.matchFragment(u).fillBefore(y.empty, !0)) } return r } function aa(r, e, t, n) { if (!n.isInline && e == t && r.doc.resolve(e).parent.content.size) { let i = ia(r.doc, e, n.type); i != null && (e = t = i) } r.replaceRange(e, t, new x(y.from(n), 0, 0)) } function ca(r, e, t) { let n = r.doc.resolve(e), i = r.doc.resolve(t), s = Bu(n, i); for (let u = 0; u < s.length; u++) { let o = s[u], l = u == s.length - 1; if (l && o == 0 || n.node(o).type.contentMatch.validEnd) return r.delete(n.start(o), i.end(o)); if (o > 0 && (l || n.node(o - 1).canReplace(n.index(o - 1), i.indexAfter(o - 1)))) return r.delete(n.before(o), i.after(o)) } for (let u = 1; u <= n.depth && u <= i.depth; u++)if (e - n.start(u) == n.depth - u && t > n.end(u) && i.end(u) - t != i.depth - u && n.start(u - 1) == i.start(u - 1) && n.node(u - 1).canReplace(n.index(u - 1), i.index(u - 1))) return r.delete(n.before(u), t); r.delete(e, t) } function Bu(r, e) { let t = [], n = Math.min(r.depth, e.depth); for (let i = n; i >= 0; i--) { let s = r.start(i); if (s < r.pos - (r.depth - i) || e.end(i) > e.pos + (e.depth - i) || r.node(i).type.spec.isolating || e.node(i).type.spec.isolating) break; (s == e.start(i) || i == r.depth && i == e.depth && r.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i) } return t } class Et extends te { constructor(e, t, n) { super(), this.pos = e, this.attr = t, this.value = n } apply(e) { let t = e.nodeAt(this.pos); if (!t) return F.fail("No node at attribute step's position"); let n = Object.create(null); for (let s in t.attrs) n[s] = t.attrs[s]; n[this.attr] = this.value; let i = t.type.create(n, null, t.marks); return F.fromReplace(e, this.pos, this.pos + 1, new x(y.from(i), 0, t.isLeaf ? 0 : 1)) } getMap() { return de.empty } invert(e) { return new Et(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new Et(t.pos, this.attr, this.value) } toJSON() { return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value } } static fromJSON(e, t) { if (typeof t.pos != "number" || typeof t.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON"); return new Et(t.pos, t.attr, t.value) } } te.jsonID("attr", Et); class Gt extends te { constructor(e, t) { super(), this.attr = e, this.value = t } apply(e) { let t = Object.create(null); for (let i in e.attrs) t[i] = e.attrs[i]; t[this.attr] = this.value; let n = e.type.create(t, e.content, e.marks); return F.ok(n) } getMap() { return de.empty } invert(e) { return new Gt(this.attr, e.attrs[this.attr]) } map(e) { return this } toJSON() { return { stepType: "docAttr", attr: this.attr, value: this.value } } static fromJSON(e, t) { if (typeof t.attr != "string") throw new RangeError("Invalid input for DocAttrStep.fromJSON"); return new Gt(t.attr, t.value) } } te.jsonID("docAttr", Gt); let Nt = class extends Error { }; Nt = function r(e) { let t = Error.call(this, e); return t.__proto__ = r.prototype, t }; Nt.prototype = Object.create(Error.prototype); Nt.prototype.constructor = Nt; Nt.prototype.name = "TransformError"; class da { constructor(e) { this.doc = e, this.steps = [], this.docs = [], this.mapping = new Kt } get before() { return this.docs.length ? this.docs[0] : this.doc } step(e) { let t = this.maybeStep(e); if (t.failed) throw new Nt(t.failed); return this } maybeStep(e) { let t = e.apply(this.doc); return t.failed || this.addStep(e, t.doc), t } get docChanged() { return this.steps.length > 0 } addStep(e, t) { this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t } replace(e, t = e, n = x.empty) { let i = Hn(this.doc, e, t, n); return i && this.step(i), this } replaceWith(e, t, n) { return this.replace(e, t, new x(y.from(n), 0, 0)) } delete(e, t) { return this.replace(e, t, x.empty) } insert(e, t) { return this.replaceWith(e, e, t) } replaceRange(e, t, n) { return la(this, e, t, n), this } replaceRangeWith(e, t, n) { return aa(this, e, t, n), this } deleteRange(e, t) { return ca(this, e, t), this } lift(e, t) { return Kl(this, e, t), this } join(e, t = 1) { return ra(this, e, t), this } wrap(e, t) { return Ql(this, e, t), this } setBlockType(e, t = e, n, i = null) { return Yl(this, e, t, n, i), this } setNodeMarkup(e, t, n = null, i) { return ea(this, e, t, n, i), this } setNodeAttribute(e, t, n) { return this.step(new Et(e, t, n)), this } setDocAttribute(e, t) { return this.step(new Gt(e, t)), this } addNodeMark(e, t) { return this.step(new Ve(e, t)), this } removeNodeMark(e, t) { let n = this.doc.nodeAt(e); if (!n) throw new RangeError("No node at position " + e); if (t instanceof P) t.isInSet(n.marks) && this.step(new dt(e, t)); else { let i = n.marks, s, u = []; for (; s = t.isInSet(i);)u.push(new dt(e, s)), i = s.removeFromSet(i); for (let o = u.length - 1; o >= 0; o--)this.step(u[o]) } return this } split(e, t = 1, n) { return ta(this, e, t, n), this } addMark(e, t, n) { return Wl(this, e, t, n), this } removeMark(e, t, n) { return Ul(this, e, t, n), this } clearIncompatible(e, t, n) { return Xr(this, e, t, n), this } } const lr = Object.create(null); class M { constructor(e, t, n) { this.$anchor = e, this.$head = t, this.ranges = n || [new fa(e.min(t), e.max(t))] } get anchor() { return this.$anchor.pos } get head() { return this.$head.pos } get from() { return this.$from.pos } get to() { return this.$to.pos } get $from() { return this.ranges[0].$from } get $to() { return this.ranges[0].$to } get empty() { let e = this.ranges; for (let t = 0; t < e.length; t++)if (e[t].$from.pos != e[t].$to.pos) return !1; return !0 } content() { return this.$from.doc.slice(this.from, this.to, !0) } replace(e, t = x.empty) { let n = t.content.lastChild, i = null; for (let o = 0; o < t.openEnd; o++)i = n, n = n.lastChild; let s = e.steps.length, u = this.ranges; for (let o = 0; o < u.length; o++) { let { $from: l, $to: a } = u[o], c = e.mapping.slice(s); e.replaceRange(c.map(l.pos), c.map(a.pos), o ? x.empty : t), o == 0 && Ki(e, s, (n ? n.isInline : i && i.isTextblock) ? -1 : 1) } } replaceWith(e, t) { let n = e.steps.length, i = this.ranges; for (let s = 0; s < i.length; s++) { let { $from: u, $to: o } = i[s], l = e.mapping.slice(n), a = l.map(u.pos), c = l.map(o.pos); s ? e.deleteRange(a, c) : (e.replaceRangeWith(a, c, t), Ki(e, n, t.isInline ? -1 : 1)) } } static findFrom(e, t, n = !1) { let i = e.parent.inlineContent ? new T(e) : kt(e.node(0), e.parent, e.pos, e.index(), t, n); if (i) return i; for (let s = e.depth - 1; s >= 0; s--) { let u = t < 0 ? kt(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, n) : kt(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, n); if (u) return u } return null } static near(e, t = 1) { return this.findFrom(e, t) || this.findFrom(e, -t) || new he(e.node(0)) } static atStart(e) { return kt(e, e, 0, 0, 1) || new he(e) } static atEnd(e) { return kt(e, e, e.content.size, e.childCount, -1) || new he(e) } static fromJSON(e, t) { if (!t || !t.type) throw new RangeError("Invalid input for Selection.fromJSON"); let n = lr[t.type]; if (!n) throw new RangeError(`No selection type ${t.type} defined`); return n.fromJSON(e, t) } static jsonID(e, t) { if (e in lr) throw new RangeError("Duplicate use of selection JSON ID " + e); return lr[e] = t, t.prototype.jsonID = e, t } getBookmark() { return T.between(this.$anchor, this.$head).getBookmark() } } M.prototype.visible = !0; class fa { constructor(e, t) { this.$from = e, this.$to = t } } let Ui = !1; function Ji(r) { !Ui && !r.parent.inlineContent && (Ui = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + r.parent.type.name + ")")) } class T extends M { constructor(e, t = e) { Ji(e), Ji(t), super(e, t) } get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null } map(e, t) { let n = e.resolve(t.map(this.head)); if (!n.parent.inlineContent) return M.near(n); let i = e.resolve(t.map(this.anchor)); return new T(i.parent.inlineContent ? i : n, n) } replace(e, t = x.empty) { if (super.replace(e, t), t == x.empty) { let n = this.$from.marksAcross(this.$to); n && e.ensureMarks(n) } } eq(e) { return e instanceof T && e.anchor == this.anchor && e.head == this.head } getBookmark() { return new jn(this.anchor, this.head) } toJSON() { return { type: "text", anchor: this.anchor, head: this.head } } static fromJSON(e, t) { if (typeof t.anchor != "number" || typeof t.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON"); return new T(e.resolve(t.anchor), e.resolve(t.head)) } static create(e, t, n = t) { let i = e.resolve(t); return new this(i, n == t ? i : e.resolve(n)) } static between(e, t, n) { let i = e.pos - t.pos; if ((!n || i) && (n = i >= 0 ? 1 : -1), !t.parent.inlineContent) { let s = M.findFrom(t, n, !0) || M.findFrom(t, -n, !0); if (s) t = s.$head; else return M.near(t, n) } return e.parent.inlineContent || (i == 0 ? e = t : (e = (M.findFrom(e, -n, !0) || M.findFrom(e, n, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new T(e, t) } } M.jsonID("text", T); class jn { constructor(e, t) { this.anchor = e, this.head = t } map(e) { return new jn(e.map(this.anchor), e.map(this.head)) } resolve(e) { return T.between(e.resolve(this.anchor), e.resolve(this.head)) } } class S extends M { constructor(e) { let t = e.nodeAfter, n = e.node(0).resolve(e.pos + t.nodeSize); super(e, n), this.node = t } map(e, t) { let { deleted: n, pos: i } = t.mapResult(this.anchor), s = e.resolve(i); return n ? M.near(s) : new S(s) } content() { return new x(y.from(this.node), 0, 0) } eq(e) { return e instanceof S && e.anchor == this.anchor } toJSON() { return { type: "node", anchor: this.anchor } } getBookmark() { return new ti(this.anchor) } static fromJSON(e, t) { if (typeof t.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON"); return new S(e.resolve(t.anchor)) } static create(e, t) { return new S(e.resolve(t)) } static isSelectable(e) { return !e.isText && e.type.spec.selectable !== !1 } } S.prototype.visible = !1; M.jsonID("node", S); class ti { constructor(e) { this.anchor = e } map(e) { let { deleted: t, pos: n } = e.mapResult(this.anchor); return t ? new jn(n, n) : new ti(n) } resolve(e) { let t = e.resolve(this.anchor), n = t.nodeAfter; return n && S.isSelectable(n) ? new S(t) : M.near(t) } } class he extends M { constructor(e) { super(e.resolve(0), e.resolve(e.content.size)) } replace(e, t = x.empty) { if (t == x.empty) { e.delete(0, e.doc.content.size); let n = M.atStart(e.doc); n.eq(e.selection) || e.setSelection(n) } else super.replace(e, t) } toJSON() { return { type: "all" } } static fromJSON(e) { return new he(e) } map(e) { return new he(e) } eq(e) { return e instanceof he } getBookmark() { return ha } } M.jsonID("all", he); const ha = { map() { return this }, resolve(r) { return new he(r) } }; function kt(r, e, t, n, i, s = !1) { if (e.inlineContent) return T.create(r, t); for (let u = n - (i > 0 ? 0 : 1); i > 0 ? u < e.childCount : u >= 0; u += i) { let o = e.child(u); if (o.isAtom) { if (!s && S.isSelectable(o)) return S.create(r, t - (i < 0 ? o.nodeSize : 0)) } else { let l = kt(r, o, t + i, i < 0 ? o.childCount : 0, i, s); if (l) return l } t += o.nodeSize * i } return null } function Ki(r, e, t) { let n = r.steps.length - 1; if (n < e) return; let i = r.steps[n]; if (!(i instanceof q || i instanceof j)) return; let s = r.mapping.maps[n], u; s.forEach((o, l, a, c) => { u == null && (u = c) }), r.setSelection(M.near(r.doc.resolve(u), t)) } const Gi = 1, dn = 2, Zi = 4; class pa extends da { constructor(e) { super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks } get selection() { return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection } setSelection(e) { if (e.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document"); return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Gi) & ~dn, this.storedMarks = null, this } get selectionSet() { return (this.updated & Gi) > 0 } setStoredMarks(e) { return this.storedMarks = e, this.updated |= dn, this } ensureMarks(e) { return P.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this } addStoredMark(e) { return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks())) } removeStoredMark(e) { return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks())) } get storedMarksSet() { return (this.updated & dn) > 0 } addStep(e, t) { super.addStep(e, t), this.updated = this.updated & ~dn, this.storedMarks = null } setTime(e) { return this.time = e, this } replaceSelection(e) { return this.selection.replace(this, e), this } replaceSelectionWith(e, t = !0) { let n = this.selection; return t && (e = e.mark(this.storedMarks || (n.empty ? n.$from.marks() : n.$from.marksAcross(n.$to) || P.none))), n.replaceWith(this, e), this } deleteSelection() { return this.selection.replace(this), this } insertText(e, t, n) { let i = this.doc.type.schema; if (t == null) return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection(); { if (n == null && (n = t), n = n ?? t, !e) return this.deleteRange(t, n); let s = this.storedMarks; if (!s) { let u = this.doc.resolve(t); s = n == t ? u.marks() : u.marksAcross(this.doc.resolve(n)) } return this.replaceRangeWith(t, n, i.text(e, s)), this.selection.empty || this.setSelection(M.near(this.selection.$to)), this } } setMeta(e, t) { return this.meta[typeof e == "string" ? e : e.key] = t, this } getMeta(e) { return this.meta[typeof e == "string" ? e : e.key] } get isGeneric() { for (let e in this.meta) return !1; return !0 } scrollIntoView() { return this.updated |= Zi, this } get scrolledIntoView() { return (this.updated & Zi) > 0 } } function Qi(r, e) { return !e || !r ? r : r.bind(e) } class _t { constructor(e, t, n) { this.name = e, this.init = Qi(t.init, n), this.apply = Qi(t.apply, n) } } const ma = [new _t("doc", { init(r) { return r.doc || r.schema.topNodeType.createAndFill() }, apply(r) { return r.doc } }), new _t("selection", { init(r, e) { return r.selection || M.atStart(e.doc) }, apply(r) { return r.selection } }), new _t("storedMarks", { init(r) { return r.storedMarks || null }, apply(r, e, t, n) { return n.selection.$cursor ? r.storedMarks : null } }), new _t("scrollToSelection", { init() { return 0 }, apply(r, e) { return r.scrolledIntoView ? e + 1 : e } })]; class ar { constructor(e, t) { this.schema = e, this.plugins = [], this.pluginsByKey = Object.create(null), this.fields = ma.slice(), t && t.forEach(n => { if (this.pluginsByKey[n.key]) throw new RangeError("Adding different instances of a keyed plugin (" + n.key + ")"); this.plugins.push(n), this.pluginsByKey[n.key] = n, n.spec.state && this.fields.push(new _t(n.key, n.spec.state, n)) }) } } class St { constructor(e) { this.config = e } get schema() { return this.config.schema } get plugins() { return this.config.plugins } apply(e) { return this.applyTransaction(e).state } filterTransaction(e, t = -1) { for (let n = 0; n < this.config.plugins.length; n++)if (n != t) { let i = this.config.plugins[n]; if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this)) return !1 } return !0 } applyTransaction(e) { if (!this.filterTransaction(e)) return { state: this, transactions: [] }; let t = [e], n = this.applyInner(e), i = null; for (; ;) { let s = !1; for (let u = 0; u < this.config.plugins.length; u++) { let o = this.config.plugins[u]; if (o.spec.appendTransaction) { let l = i ? i[u].n : 0, a = i ? i[u].state : this, c = l < t.length && o.spec.appendTransaction.call(o, l ? t.slice(l) : t, a, n); if (c && n.filterTransaction(c, u)) { if (c.setMeta("appendedTransaction", e), !i) { i = []; for (let d = 0; d < this.config.plugins.length; d++)i.push(d < u ? { state: n, n: t.length } : { state: this, n: 0 }) } t.push(c), n = n.applyInner(c), s = !0 } i && (i[u] = { state: n, n: t.length }) } } if (!s) return { state: n, transactions: t } } } applyInner(e) { if (!e.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction"); let t = new St(this.config), n = this.config.fields; for (let i = 0; i < n.length; i++) { let s = n[i]; t[s.name] = s.apply(e, this[s.name], this, t) } return t } get tr() { return new pa(this) } static create(e) { let t = new ar(e.doc ? e.doc.type.schema : e.schema, e.plugins), n = new St(t); for (let i = 0; i < t.fields.length; i++)n[t.fields[i].name] = t.fields[i].init(e, n); return n } reconfigure(e) { let t = new ar(this.schema, e.plugins), n = t.fields, i = new St(t); for (let s = 0; s < n.length; s++) { let u = n[s].name; i[u] = this.hasOwnProperty(u) ? this[u] : n[s].init(e, i) } return i } toJSON(e) { let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }; if (this.storedMarks && (t.storedMarks = this.storedMarks.map(n => n.toJSON())), e && typeof e == "object") for (let n in e) { if (n == "doc" || n == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved"); let i = e[n], s = i.spec.state; s && s.toJSON && (t[n] = s.toJSON.call(i, this[i.key])) } return t } static fromJSON(e, t, n) { if (!t) throw new RangeError("Invalid input for EditorState.fromJSON"); if (!e.schema) throw new RangeError("Required config field 'schema' missing"); let i = new ar(e.schema, e.plugins), s = new St(i); return i.fields.forEach(u => { if (u.name == "doc") s.doc = je.fromJSON(e.schema, t.doc); else if (u.name == "selection") s.selection = M.fromJSON(s.doc, t.selection); else if (u.name == "storedMarks") t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON)); else { if (n) for (let o in n) { let l = n[o], a = l.spec.state; if (l.key == u.name && a && a.fromJSON && Object.prototype.hasOwnProperty.call(t, o)) { s[u.name] = a.fromJSON.call(l, e, t[o], s); return } } s[u.name] = u.init(e, s) } }), s } } function zu(r, e, t) { for (let n in r) { let i = r[n]; i instanceof Function ? i = i.bind(e) : n == "handleDOMEvents" && (i = zu(i, e, {})), t[n] = i } return t } class ue { constructor(e) { this.spec = e, this.props = {}, e.props && zu(e.props, this, this.props), this.key = e.key ? e.key.key : $u("plugin") } getState(e) { return e[this.key] } } const cr = Object.create(null); function $u(r) { return r in cr ? r + "$" + ++cr[r] : (cr[r] = 0, r + "$") } class Se { constructor(e = "key") { this.key = $u(e) } get(e) { return e.config.pluginsByKey[this.key] } getState(e) { return e[this.key] } } const Z = function (r) { for (var e = 0; ; e++)if (r = r.previousSibling, !r) return e }, At = function (r) { let e = r.assignedSlot || r.parentNode; return e && e.nodeType == 11 ? e.host : e }; let Ir = null; const ve = function (r, e, t) { let n = Ir || (Ir = document.createRange()); return n.setEnd(r, t ?? r.nodeValue.length), n.setStart(r, e || 0), n }, ga = function () { Ir = null }, ft = function (r, e, t, n) { return t && (Yi(r, e, t, n, -1) || Yi(r, e, t, n, 1)) }, ba = /^(img|br|input|textarea|hr)$/i; function Yi(r, e, t, n, i) { for (var s; ;) { if (r == t && e == n) return !0; if (e == (i < 0 ? 0 : ge(r))) { let u = r.parentNode; if (!u || u.nodeType != 1 || nn(r) || ba.test(r.nodeName) || r.contentEditable == "false") return !1; e = Z(r) + (i < 0 ? 0 : 1), r = u } else if (r.nodeType == 1) { let u = r.childNodes[e + (i < 0 ? -1 : 0)]; if (u.nodeType == 1 && u.contentEditable == "false") if (!((s = u.pmViewDesc) === null || s === void 0) && s.ignoreForSelection) e += i; else return !1; else r = u, e = i < 0 ? ge(r) : 0 } else return !1 } } function ge(r) { return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length } function ya(r, e) { for (; ;) { if (r.nodeType == 3 && e) return r; if (r.nodeType == 1 && e > 0) { if (r.contentEditable == "false") return null; r = r.childNodes[e - 1], e = ge(r) } else if (r.parentNode && !nn(r)) e = Z(r), r = r.parentNode; else return null } } function xa(r, e) { for (; ;) { if (r.nodeType == 3 && e < r.nodeValue.length) return r; if (r.nodeType == 1 && e < r.childNodes.length) { if (r.contentEditable == "false") return null; r = r.childNodes[e], e = 0 } else if (r.parentNode && !nn(r)) e = Z(r) + 1, r = r.parentNode; else return null } } function ka(r, e, t) { for (let n = e == 0, i = e == ge(r); n || i;) { if (r == t) return !0; let s = Z(r); if (r = r.parentNode, !r) return !1; n = n && s == 0, i = i && s == ge(r) } } function nn(r) { let e; for (let t = r; t && !(e = t.pmViewDesc); t = t.parentNode); return e && e.node && e.node.isBlock && (e.dom == r || e.contentDOM == r) } const Wn = function (r) { return r.focusNode && ft(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) }; function et(r, e) { let t = document.createEvent("Event"); return t.initEvent("keydown", !0, !0), t.keyCode = r, t.key = t.code = e, t } function wa(r) { let e = r.activeElement; for (; e && e.shadowRoot;)e = e.shadowRoot.activeElement; return e } function Sa(r, e, t) { if (r.caretPositionFromPoint) try { let n = r.caretPositionFromPoint(e, t); if (n) return { node: n.offsetNode, offset: Math.min(ge(n.offsetNode), n.offset) } } catch { } if (r.caretRangeFromPoint) { let n = r.caretRangeFromPoint(e, t); if (n) return { node: n.startContainer, offset: Math.min(ge(n.startContainer), n.startOffset) } } } const Ne = typeof navigator < "u" ? navigator : null, Xi = typeof document < "u" ? document : null, Ye = Ne && Ne.userAgent || "", Pr = /Edge\/(\d+)/.exec(Ye), _u = /MSIE \d/.exec(Ye), Lr = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ye), le = !!(_u || Lr || Pr), Ue = _u ? document.documentMode : Lr ? +Lr[1] : Pr ? +Pr[1] : 0, ke = !le && /gecko\/(\d+)/i.test(Ye); ke && +(/Firefox\/(\d+)/.exec(Ye) || [0, 0])[1]; const Br = !le && /Chrome\/(\d+)/.exec(Ye), ee = !!Br, Fu = Br ? +Br[1] : 0, re = !le && !!Ne && /Apple Computer/.test(Ne.vendor), Ot = re && (/Mobile\/\w+/.test(Ye) || !!Ne && Ne.maxTouchPoints > 2), pe = Ot || (Ne ? /Mac/.test(Ne.platform) : !1), Ca = Ne ? /Win/.test(Ne.platform) : !1, De = /Android \d/.test(Ye), rn = !!Xi && "webkitFontSmoothing" in Xi.documentElement.style, Ta = rn ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0; function Ea(r) { let e = r.defaultView && r.defaultView.visualViewport; return e ? { left: 0, right: e.width, top: 0, bottom: e.height } : { left: 0, right: r.documentElement.clientWidth, top: 0, bottom: r.documentElement.clientHeight } } function Oe(r, e) { return typeof r == "number" ? r : r[e] } function Ma(r) { let e = r.getBoundingClientRect(), t = e.width / r.offsetWidth || 1, n = e.height / r.offsetHeight || 1; return { left: e.left, right: e.left + r.clientWidth * t, top: e.top, bottom: e.top + r.clientHeight * n } } function es(r, e, t) { let n = r.someProp("scrollThreshold") || 0, i = r.someProp("scrollMargin") || 5, s = r.dom.ownerDocument; for (let u = t || r.dom; u;) { if (u.nodeType != 1) { u = At(u); continue } let o = u, l = o == s.body, a = l ? Ea(s) : Ma(o), c = 0, d = 0; if (e.top < a.top + Oe(n, "top") ? d = -(a.top - e.top + Oe(i, "top")) : e.bottom > a.bottom - Oe(n, "bottom") && (d = e.bottom - e.top > a.bottom - a.top ? e.top + Oe(i, "top") - a.top : e.bottom - a.bottom + Oe(i, "bottom")), e.left < a.left + Oe(n, "left") ? c = -(a.left - e.left + Oe(i, "left")) : e.right > a.right - Oe(n, "right") && (c = e.right - a.right + Oe(i, "right")), c || d) if (l) s.defaultView.scrollBy(c, d); else { let h = o.scrollLeft, p = o.scrollTop; d && (o.scrollTop += d), c && (o.scrollLeft += c); let m = o.scrollLeft - h, g = o.scrollTop - p; e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g } } let f = l ? "fixed" : getComputedStyle(u).position; if (/^(fixed|sticky)$/.test(f)) break; u = f == "absolute" ? u.offsetParent : At(u) } } function Na(r) { let e = r.dom.getBoundingClientRect(), t = Math.max(0, e.top), n, i; for (let s = (e.left + e.right) / 2, u = t + 1; u < Math.min(innerHeight, e.bottom); u += 5) { let o = r.root.elementFromPoint(s, u); if (!o || o == r.dom || !r.dom.contains(o)) continue; let l = o.getBoundingClientRect(); if (l.top >= t - 20) { n = o, i = l.top; break } } return { refDOM: n, refTop: i, stack: Vu(r.dom) } } function Vu(r) { let e = [], t = r.ownerDocument; for (let n = r; n && (e.push({ dom: n, top: n.scrollTop, left: n.scrollLeft }), r != t); n = At(n)); return e } function Aa({ refDOM: r, refTop: e, stack: t }) { let n = r ? r.getBoundingClientRect().top : 0; qu(t, n == 0 ? 0 : n - e) } function qu(r, e) { for (let t = 0; t < r.length; t++) { let { dom: n, top: i, left: s } = r[t]; n.scrollTop != i + e && (n.scrollTop = i + e), n.scrollLeft != s && (n.scrollLeft = s) } } let yt = null; function Oa(r) { if (r.setActive) return r.setActive(); if (yt) return r.focus(yt); let e = Vu(r); r.focus(yt == null ? { get preventScroll() { return yt = { preventScroll: !0 }, !0 } } : void 0), yt || (yt = !1, qu(e, 0)) } function Hu(r, e) { let t, n = 2e8, i, s = 0, u = e.top, o = e.top, l, a; for (let c = r.firstChild, d = 0; c; c = c.nextSibling, d++) { let f; if (c.nodeType == 1) f = c.getClientRects(); else if (c.nodeType == 3) f = ve(c).getClientRects(); else continue; for (let h = 0; h < f.length; h++) { let p = f[h]; if (p.top <= u && p.bottom >= o) { u = Math.max(p.bottom, u), o = Math.min(p.top, o); let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0; if (m < n) { t = c, n = m, i = m && t.nodeType == 3 ? { left: p.right < e.left ? p.right : p.left, top: e.top } : e, c.nodeType == 1 && m && (s = d + (e.left >= (p.left + p.right) / 2 ? 1 : 0)); continue } } else p.top > e.top && !l && p.left <= e.left && p.right >= e.left && (l = c, a = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top }); !t && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (s = d + 1) } } return !t && l && (t = l, i = a, n = 0), t && t.nodeType == 3 ? va(t, i) : !t || n && t.nodeType == 1 ? { node: r, offset: s } : Hu(t, i) } function va(r, e) { let t = r.nodeValue.length, n = document.createRange(); for (let i = 0; i < t; i++) { n.setEnd(r, i + 1), n.setStart(r, i); let s = Le(n, 1); if (s.top != s.bottom && ni(e, s)) return { node: r, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) } } return { node: r, offset: 0 } } function ni(r, e) { return r.left >= e.left - 1 && r.left <= e.right + 1 && r.top >= e.top - 1 && r.top <= e.bottom + 1 } function Da(r, e) { let t = r.parentNode; return t && /^li$/i.test(t.nodeName) && e.left < r.getBoundingClientRect().left ? t : r } function Ra(r, e, t) { let { node: n, offset: i } = Hu(e, t), s = -1; if (n.nodeType == 1 && !n.firstChild) { let u = n.getBoundingClientRect(); s = u.left != u.right && t.left > (u.left + u.right) / 2 ? 1 : -1 } return r.docView.posFromDOM(n, i, s) } function Ia(r, e, t, n) { let i = -1; for (let s = e, u = !1; s != r.dom;) { let o = r.docView.nearestDesc(s, !0), l; if (!o) return null; if (o.dom.nodeType == 1 && (o.node.isBlock && o.parent || !o.contentDOM) && ((l = o.dom.getBoundingClientRect()).width || l.height) && (o.node.isBlock && o.parent && (!u && l.left > n.left || l.top > n.top ? i = o.posBefore : (!u && l.right < n.left || l.bottom < n.top) && (i = o.posAfter), u = !0), !o.contentDOM && i < 0 && !o.node.isText)) return (o.node.isBlock ? n.top < (l.top + l.bottom) / 2 : n.left < (l.left + l.right) / 2) ? o.posBefore : o.posAfter; s = o.dom.parentNode } return i > -1 ? i : r.docView.posFromDOM(e, t, -1) } function ju(r, e, t) { let n = r.childNodes.length; if (n && t.top < t.bottom) for (let i = Math.max(0, Math.min(n - 1, Math.floor(n * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ;) { let u = r.childNodes[s]; if (u.nodeType == 1) { let o = u.getClientRects(); for (let l = 0; l < o.length; l++) { let a = o[l]; if (ni(e, a)) return ju(u, e, a) } } if ((s = (s + 1) % n) == i) break } return r } function Pa(r, e) { let t = r.dom.ownerDocument, n, i = 0, s = Sa(t, e.left, e.top); s && ({ node: n, offset: i } = s); let u = (r.root.elementFromPoint ? r.root : t).elementFromPoint(e.left, e.top), o; if (!u || !r.dom.contains(u.nodeType != 1 ? u.parentNode : u)) { let a = r.dom.getBoundingClientRect(); if (!ni(e, a) || (u = ju(r.dom, e, a), !u)) return null } if (re) for (let a = u; n && a; a = At(a))a.draggable && (n = void 0); if (u = Da(u, e), n) { if (ke && n.nodeType == 1 && (i = Math.min(i, n.childNodes.length), i < n.childNodes.length)) { let c = n.childNodes[i], d; c.nodeName == "IMG" && (d = c.getBoundingClientRect()).right <= e.left && d.bottom > e.top && i++ } let a; rn && i && n.nodeType == 1 && (a = n.childNodes[i - 1]).nodeType == 1 && a.contentEditable == "false" && a.getBoundingClientRect().top >= e.top && i--, n == r.dom && i == n.childNodes.length - 1 && n.lastChild.nodeType == 1 && e.top > n.lastChild.getBoundingClientRect().bottom ? o = r.state.doc.content.size : (i == 0 || n.nodeType != 1 || n.childNodes[i - 1].nodeName != "BR") && (o = Ia(r, n, i, e)) } o == null && (o = Ra(r, u, e)); let l = r.docView.nearestDesc(u, !0); return { pos: o, inside: l ? l.posAtStart - l.border : -1 } } function ts(r) { return r.top < r.bottom || r.left < r.right } function Le(r, e) { let t = r.getClientRects(); if (t.length) { let n = t[e < 0 ? 0 : t.length - 1]; if (ts(n)) return n } return Array.prototype.find.call(t, ts) || r.getBoundingClientRect() } const La = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/; function Wu(r, e, t) { let { node: n, offset: i, atom: s } = r.docView.domFromPos(e, t < 0 ? -1 : 1), u = rn || ke; if (n.nodeType == 3) if (u && (La.test(n.nodeValue) || (t < 0 ? !i : i == n.nodeValue.length))) { let l = Le(ve(n, i, i), t); if (ke && i && /\s/.test(n.nodeValue[i - 1]) && i < n.nodeValue.length) { let a = Le(ve(n, i - 1, i - 1), -1); if (a.top == l.top) { let c = Le(ve(n, i, i + 1), -1); if (c.top != l.top) return Pt(c, c.left < a.left) } } return l } else { let l = i, a = i, c = t < 0 ? 1 : -1; return t < 0 && !i ? (a++, c = -1) : t >= 0 && i == n.nodeValue.length ? (l--, c = 1) : t < 0 ? l-- : a++, Pt(Le(ve(n, l, a), c), c < 0) } if (!r.state.doc.resolve(e - (s || 0)).parent.inlineContent) { if (s == null && i && (t < 0 || i == ge(n))) { let l = n.childNodes[i - 1]; if (l.nodeType == 1) return dr(l.getBoundingClientRect(), !1) } if (s == null && i < ge(n)) { let l = n.childNodes[i]; if (l.nodeType == 1) return dr(l.getBoundingClientRect(), !0) } return dr(n.getBoundingClientRect(), t >= 0) } if (s == null && i && (t < 0 || i == ge(n))) { let l = n.childNodes[i - 1], a = l.nodeType == 3 ? ve(l, ge(l) - (u ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null; if (a) return Pt(Le(a, 1), !1) } if (s == null && i < ge(n)) { let l = n.childNodes[i]; for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords;)l = l.nextSibling; let a = l ? l.nodeType == 3 ? ve(l, 0, u ? 0 : 1) : l.nodeType == 1 ? l : null : null; if (a) return Pt(Le(a, -1), !0) } return Pt(Le(n.nodeType == 3 ? ve(n) : n, -t), t >= 0) } function Pt(r, e) { if (r.width == 0) return r; let t = e ? r.left : r.right; return { top: r.top, bottom: r.bottom, left: t, right: t } } function dr(r, e) { if (r.height == 0) return r; let t = e ? r.top : r.bottom; return { top: t, bottom: t, left: r.left, right: r.right } } function Uu(r, e, t) { let n = r.state, i = r.root.activeElement; n != e && r.updateState(e), i != r.dom && r.focus(); try { return t() } finally { n != e && r.updateState(n), i != r.dom && i && i.focus() } } function Ba(r, e, t) { let n = e.selection, i = t == "up" ? n.$from : n.$to; return Uu(r, e, () => { let { node: s } = r.docView.domFromPos(i.pos, t == "up" ? -1 : 1); for (; ;) { let o = r.docView.nearestDesc(s, !0); if (!o) break; if (o.node.isBlock) { s = o.contentDOM || o.dom; break } s = o.dom.parentNode } let u = Wu(r, i.pos, 1); for (let o = s.firstChild; o; o = o.nextSibling) { let l; if (o.nodeType == 1) l = o.getClientRects(); else if (o.nodeType == 3) l = ve(o, 0, o.nodeValue.length).getClientRects(); else continue; for (let a = 0; a < l.length; a++) { let c = l[a]; if (c.bottom > c.top + 1 && (t == "up" ? u.top - c.top > (c.bottom - u.top) * 2 : c.bottom - u.bottom > (u.bottom - c.top) * 2)) return !1 } } return !0 }) } const za = /[\u0590-\u08ac]/; function $a(r, e, t) { let { $head: n } = e.selection; if (!n.parent.isTextblock) return !1; let i = n.parentOffset, s = !i, u = i == n.parent.content.size, o = r.domSelection(); return o ? !za.test(n.parent.textContent) || !o.modify ? t == "left" || t == "backward" ? s : u : Uu(r, e, () => { let { focusNode: l, focusOffset: a, anchorNode: c, anchorOffset: d } = r.domSelectionRange(), f = o.caretBidiLevel; o.modify("move", t, "character"); let h = n.depth ? r.docView.domAfterPos(n.before()) : r.dom, { focusNode: p, focusOffset: m } = r.domSelectionRange(), g = p && !h.contains(p.nodeType == 1 ? p : p.parentNode) || l == p && a == m; try { o.collapse(c, d), l && (l != c || a != d) && o.extend && o.extend(l, a) } catch { } return f != null && (o.caretBidiLevel = f), g }) : n.pos == n.start() || n.pos == n.end() } let ns = null, rs = null, is = !1; function _a(r, e, t) { return ns == e && rs == t ? is : (ns = e, rs = t, is = t == "up" || t == "down" ? Ba(r, e, t) : $a(r, e, t)) } const be = 0, ss = 1, nt = 2, Ae = 3; class sn {
    constructor(e, t, n, i) { this.parent = e, this.children = t, this.dom = n, this.contentDOM = i, this.dirty = be, n.pmViewDesc = this } matchesWidget(e) { return !1 } matchesMark(e) { return !1 } matchesNode(e, t, n) { return !1 } matchesHack(e) { return !1 } parseRule() { return null } stopEvent(e) { return !1 } get size() { let e = 0; for (let t = 0; t < this.children.length; t++)e += this.children[t].size; return e } get border() { return 0 } destroy() { this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0); for (let e = 0; e < this.children.length; e++)this.children[e].destroy() } posBeforeChild(e) { for (let t = 0, n = this.posAtStart; ; t++) { let i = this.children[t]; if (i == e) return n; n += i.size } } get posBefore() { return this.parent.posBeforeChild(this) } get posAtStart() { return this.parent ? this.parent.posBeforeChild(this) + this.border : 0 } get posAfter() { return this.posBefore + this.size } get posAtEnd() { return this.posAtStart + this.size - 2 * this.border } localPosFromDOM(e, t, n) { if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)) if (n < 0) { let s, u; if (e == this.contentDOM) s = e.childNodes[t - 1]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; s = e.previousSibling } for (; s && !((u = s.pmViewDesc) && u.parent == this);)s = s.previousSibling; return s ? this.posBeforeChild(u) + u.size : this.posAtStart } else { let s, u; if (e == this.contentDOM) s = e.childNodes[t]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; s = e.nextSibling } for (; s && !((u = s.pmViewDesc) && u.parent == this);)s = s.nextSibling; return s ? this.posBeforeChild(u) : this.posAtEnd } let i; if (e == this.dom && this.contentDOM) i = t > Z(this.contentDOM); else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) i = e.compareDocumentPosition(this.contentDOM) & 2; else if (this.dom.firstChild) { if (t == 0) for (let s = e; ; s = s.parentNode) { if (s == this.dom) { i = !1; break } if (s.previousSibling) break } if (i == null && t == e.childNodes.length) for (let s = e; ; s = s.parentNode) { if (s == this.dom) { i = !0; break } if (s.nextSibling) break } } return i ?? n > 0 ? this.posAtEnd : this.posAtStart } nearestDesc(e, t = !1) { for (let n = !0, i = e; i; i = i.parentNode) { let s = this.getDesc(i), u; if (s && (!t || s.node)) if (n && (u = s.nodeDOM) && !(u.nodeType == 1 ? u.contains(e.nodeType == 1 ? e : e.parentNode) : u == e)) n = !1; else return s } } getDesc(e) { let t = e.pmViewDesc; for (let n = t; n; n = n.parent)if (n == this) return t } posFromDOM(e, t, n) { for (let i = e; i; i = i.parentNode) { let s = this.getDesc(i); if (s) return s.localPosFromDOM(e, t, n) } return -1 } descAt(e) { for (let t = 0, n = 0; t < this.children.length; t++) { let i = this.children[t], s = n + i.size; if (n == e && s != n) { for (; !i.border && i.children.length;)for (let u = 0; u < i.children.length; u++) { let o = i.children[u]; if (o.size) { i = o; break } } return i } if (e < s) return i.descAt(e - n - i.border); n = s } } domFromPos(e, t) { if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 }; let n = 0, i = 0; for (let s = 0; n < this.children.length; n++) { let u = this.children[n], o = s + u.size; if (o > e || u instanceof Ku) { i = e - s; break } s = o } if (i) return this.children[n].domFromPos(i - this.children[n].border, t); for (let s; n && !(s = this.children[n - 1]).size && s instanceof Ju && s.side >= 0; n--); if (t <= 0) { let s, u = !0; for (; s = n ? this.children[n - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); n--, u = !1); return s && t && u && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? Z(s.dom) + 1 : 0 } } else { let s, u = !0; for (; s = n < this.children.length ? this.children[n] : null, !(!s || s.dom.parentNode == this.contentDOM); n++, u = !1); return s && u && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? Z(s.dom) : this.contentDOM.childNodes.length } } } parseRange(e, t, n = 0) { if (this.children.length == 0) return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length }; let i = -1, s = -1; for (let u = n, o = 0; ; o++) { let l = this.children[o], a = u + l.size; if (i == -1 && e <= a) { let c = u + l.border; if (e >= c && t <= a - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM)) return l.parseRange(e, t, c); e = u; for (let d = o; d > 0; d--) { let f = this.children[d - 1]; if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) { i = Z(f.dom) + 1; break } e -= f.size } i == -1 && (i = 0) } if (i > -1 && (a > t || o == this.children.length - 1)) { t = a; for (let c = o + 1; c < this.children.length; c++) { let d = this.children[c]; if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) { s = Z(d.dom); break } t += d.size } s == -1 && (s = this.contentDOM.childNodes.length); break } u = a } return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: s } } emptyChildAt(e) { if (this.border || !this.contentDOM || !this.children.length) return !1; let t = this.children[e < 0 ? 0 : this.children.length - 1]; return t.size == 0 || t.emptyChildAt(e) } domAfterPos(e) { let { node: t, offset: n } = this.domFromPos(e, 0); if (t.nodeType != 1 || n == t.childNodes.length) throw new RangeError("No node after pos " + e); return t.childNodes[n] } setSelection(e, t, n, i = !1) {
        let s = Math.min(e, t), u = Math.max(e, t); for (let h = 0, p = 0; h < this.children.length; h++) { let m = this.children[h], g = p + m.size; if (s > p && u < g) return m.setSelection(e - p - m.border, t - p - m.border, n, i); p = g } let o = this.domFromPos(e, e ? -1 : 1), l = t == e ? o : this.domFromPos(t, t ? -1 : 1), a = n.root.getSelection(), c = n.domSelectionRange(), d = !1; if ((ke || re) && e == t) {
            let { node: h, offset: p } = o; if (h.nodeType == 3) {
                if (d = !!(p && h.nodeValue[p - 1] == `
`), d && p == h.nodeValue.length) for (let m = h, g; m; m = m.parentNode) { if (g = m.nextSibling) { g.nodeName == "BR" && (o = l = { node: g.parentNode, offset: Z(g) + 1 }); break } let b = m.pmViewDesc; if (b && b.node && b.node.isBlock) break }
            } else { let m = h.childNodes[p - 1]; d = m && (m.nodeName == "BR" || m.contentEditable == "false") }
        } if (ke && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) { let h = c.focusNode.childNodes[c.focusOffset]; h && h.contentEditable == "false" && (i = !0) } if (!(i || d && re) && ft(o.node, o.offset, c.anchorNode, c.anchorOffset) && ft(l.node, l.offset, c.focusNode, c.focusOffset)) return; let f = !1; if ((a.extend || e == t) && !d) { a.collapse(o.node, o.offset); try { e != t && a.extend(l.node, l.offset), f = !0 } catch { } } if (!f) { if (e > t) { let p = o; o = l, l = p } let h = document.createRange(); h.setEnd(l.node, l.offset), h.setStart(o.node, o.offset), a.removeAllRanges(), a.addRange(h) }
    } ignoreMutation(e) { return !this.contentDOM && e.type != "selection" } get contentLost() { return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM) } markDirty(e, t) { for (let n = 0, i = 0; i < this.children.length; i++) { let s = this.children[i], u = n + s.size; if (n == u ? e <= u && t >= n : e < u && t > n) { let o = n + s.border, l = u - s.border; if (e >= o && t <= l) { this.dirty = e == n || t == u ? nt : ss, e == o && t == l && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = Ae : s.markDirty(e - o, t - o); return } else s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? nt : Ae } n = u } this.dirty = nt } markParentsDirty() { let e = 1; for (let t = this.parent; t; t = t.parent, e++) { let n = e == 1 ? nt : ss; t.dirty < n && (t.dirty = n) } } get domAtom() { return !1 } get ignoreForCoords() { return !1 } get ignoreForSelection() { return !1 } isText(e) { return !1 }
} class Ju extends sn { constructor(e, t, n, i) { let s, u = t.type.toDOM; if (typeof u == "function" && (u = u(n, () => { if (!s) return i; if (s.parent) return s.parent.posBeforeChild(s) })), !t.type.spec.raw) { if (u.nodeType != 1) { let o = document.createElement("span"); o.appendChild(u), u = o } u.contentEditable = "false", u.classList.add("ProseMirror-widget") } super(e, [], u, null), this.widget = t, this.widget = t, s = this } matchesWidget(e) { return this.dirty == be && e.type.eq(this.widget.type) } parseRule() { return { ignore: !0 } } stopEvent(e) { let t = this.widget.spec.stopEvent; return t ? t(e) : !1 } ignoreMutation(e) { return e.type != "selection" || this.widget.spec.ignoreSelection } destroy() { this.widget.type.destroy(this.dom), super.destroy() } get domAtom() { return !0 } get ignoreForSelection() { return !!this.widget.type.spec.relaxedSide } get side() { return this.widget.type.side } } class Fa extends sn { constructor(e, t, n, i) { super(e, [], t, null), this.textDOM = n, this.text = i } get size() { return this.text.length } localPosFromDOM(e, t) { return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t } domFromPos(e) { return { node: this.textDOM, offset: e } } ignoreMutation(e) { return e.type === "characterData" && e.target.nodeValue == e.oldValue } } class ht extends sn { constructor(e, t, n, i, s) { super(e, [], n, i), this.mark = t, this.spec = s } static create(e, t, n, i) { let s = i.nodeViews[t.type.name], u = s && s(t, i, n); return (!u || !u.dom) && (u = gt.renderSpec(document, t.type.spec.toDOM(t, n), null, t.attrs)), new ht(e, t, u.dom, u.contentDOM || u.dom, u) } parseRule() { return this.dirty & Ae || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM } } matchesMark(e) { return this.dirty != Ae && this.mark.eq(e) } markDirty(e, t) { if (super.markDirty(e, t), this.dirty != be) { let n = this.parent; for (; !n.node;)n = n.parent; n.dirty < this.dirty && (n.dirty = this.dirty), this.dirty = be } } slice(e, t, n) { let i = ht.create(this.parent, this.mark, !0, n), s = this.children, u = this.size; t < u && (s = $r(s, t, u, n)), e > 0 && (s = $r(s, 0, e, n)); for (let o = 0; o < s.length; o++)s[o].parent = i; return i.children = s, i } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } } class Je extends sn { constructor(e, t, n, i, s, u, o, l, a) { super(e, [], s, u), this.node = t, this.outerDeco = n, this.innerDeco = i, this.nodeDOM = o } static create(e, t, n, i, s, u) { let o = s.nodeViews[t.type.name], l, a = o && o(t, s, () => { if (!l) return u; if (l.parent) return l.parent.posBeforeChild(l) }, n, i), c = a && a.dom, d = a && a.contentDOM; if (t.isText) { if (!c) c = document.createTextNode(t.text); else if (c.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node") } else c || ({ dom: c, contentDOM: d } = gt.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs)); !d && !t.isText && c.nodeName != "BR" && (c.hasAttribute("contenteditable") || (c.contentEditable = "false"), t.type.spec.draggable && (c.draggable = !0)); let f = c; return c = Qu(c, n, t), a ? l = new Va(e, t, n, i, c, d || null, f, a, s, u + 1) : t.isText ? new Un(e, t, n, i, c, f, s) : new Je(e, t, n, i, c, d || null, f, s, u + 1) } parseRule() { if (this.node.type.spec.reparseInView) return null; let e = { node: this.node.type.name, attrs: this.node.attrs }; if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM) e.getContent = () => this.node.content; else if (!this.contentLost) e.contentElement = this.contentDOM; else { for (let t = this.children.length - 1; t >= 0; t--) { let n = this.children[t]; if (this.dom.contains(n.dom.parentNode)) { e.contentElement = n.dom.parentNode; break } } e.contentElement || (e.getContent = () => y.empty) } return e } matchesNode(e, t, n) { return this.dirty == be && e.eq(this.node) && On(t, this.outerDeco) && n.eq(this.innerDeco) } get size() { return this.node.nodeSize } get border() { return this.node.isLeaf ? 0 : 1 } updateChildren(e, t) { let n = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, u = s && s.pos > -1 ? s : null, o = s && s.pos < 0, l = new Ha(this, u && u.node, e); Ua(this.node, this.innerDeco, (a, c, d) => { a.spec.marks ? l.syncToMarks(a.spec.marks, n, e) : a.type.side >= 0 && !d && l.syncToMarks(c == this.node.childCount ? P.none : this.node.child(c).marks, n, e), l.placeWidget(a, e, i) }, (a, c, d, f) => { l.syncToMarks(a.marks, n, e); let h; l.findNodeMatch(a, c, d, f) || o && e.state.selection.from > i && e.state.selection.to < i + a.nodeSize && (h = l.findIndexWithChild(s.node)) > -1 && l.updateNodeAt(a, c, d, h, e) || l.updateNextNode(a, c, d, e, f, i) || l.addNode(a, c, d, e, i), i += a.nodeSize }), l.syncToMarks([], n, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == nt) && (u && this.protectLocalComposition(e, u), Gu(this.contentDOM, this.children, e), Ot && Ja(this.dom)) } localCompositionInfo(e, t) { let { from: n, to: i } = e.state.selection; if (!(e.state.selection instanceof T) || n < t || i > t + this.node.content.size) return null; let s = e.input.compositionNode; if (!s || !this.dom.contains(s.parentNode)) return null; if (this.node.inlineContent) { let u = s.nodeValue, o = Ka(this.node.content, u, n - t, i - t); return o < 0 ? null : { node: s, pos: o, text: u } } else return { node: s, pos: -1, text: "" } } protectLocalComposition(e, { node: t, pos: n, text: i }) { if (this.getDesc(t)) return; let s = t; for (; s.parentNode != this.contentDOM; s = s.parentNode) { for (; s.previousSibling;)s.parentNode.removeChild(s.previousSibling); for (; s.nextSibling;)s.parentNode.removeChild(s.nextSibling); s.pmViewDesc && (s.pmViewDesc = void 0) } let u = new Fa(this, s, t, i); e.input.compositionNodes.push(u), this.children = $r(this.children, n, n + i.length, e, u) } update(e, t, n, i) { return this.dirty == Ae || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, n, i), !0) } updateInner(e, t, n, i) { this.updateOuterDeco(t), this.node = e, this.innerDeco = n, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = be } updateOuterDeco(e) { if (On(e, this.outerDeco)) return; let t = this.nodeDOM.nodeType != 1, n = this.dom; this.dom = Zu(this.dom, this.nodeDOM, zr(this.outerDeco, this.node, t), zr(e, this.node, t)), this.dom != n && (n.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e } selectNode() { this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0) } deselectNode() { this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable")) } get domAtom() { return this.node.isAtom } } function us(r, e, t, n, i) { Qu(n, e, r); let s = new Je(void 0, r, e, t, n, n, n, i, 0); return s.contentDOM && s.updateChildren(i, 0), s } class Un extends Je { constructor(e, t, n, i, s, u, o) { super(e, t, n, i, s, null, u, o, 0) } parseRule() { let e = this.nodeDOM.parentNode; for (; e && e != this.dom && !e.pmIsDeco;)e = e.parentNode; return { skip: e || !0 } } update(e, t, n, i) { return this.dirty == Ae || this.dirty != be && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != be || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = be, !0) } inParent() { let e = this.parent.contentDOM; for (let t = this.nodeDOM; t; t = t.parentNode)if (t == e) return !0; return !1 } domFromPos(e) { return { node: this.nodeDOM, offset: e } } localPosFromDOM(e, t, n) { return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, n) } ignoreMutation(e) { return e.type != "characterData" && e.type != "selection" } slice(e, t, n) { let i = this.node.cut(e, t), s = document.createTextNode(i.text); return new Un(this.parent, i, this.outerDeco, this.innerDeco, s, s, n) } markDirty(e, t) { super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = Ae) } get domAtom() { return !1 } isText(e) { return this.node.text == e } } class Ku extends sn { parseRule() { return { ignore: !0 } } matchesHack(e) { return this.dirty == be && this.dom.nodeName == e } get domAtom() { return !0 } get ignoreForCoords() { return this.dom.nodeName == "IMG" } } class Va extends Je { constructor(e, t, n, i, s, u, o, l, a, c) { super(e, t, n, i, s, u, o, a, c), this.spec = l } update(e, t, n, i) { if (this.dirty == Ae) return !1; if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) { let s = this.spec.update(e, t, n); return s && this.updateInner(e, t, n, i), s } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, n, i) } selectNode() { this.spec.selectNode ? this.spec.selectNode() : super.selectNode() } deselectNode() { this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode() } setSelection(e, t, n, i) { this.spec.setSelection ? this.spec.setSelection(e, t, n.root) : super.setSelection(e, t, n, i) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } stopEvent(e) { return this.spec.stopEvent ? this.spec.stopEvent(e) : !1 } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } } function Gu(r, e, t) { let n = r.firstChild, i = !1; for (let s = 0; s < e.length; s++) { let u = e[s], o = u.dom; if (o.parentNode == r) { for (; o != n;)n = ls(n), i = !0; n = n.nextSibling } else i = !0, r.insertBefore(o, n); if (u instanceof ht) { let l = n ? n.previousSibling : r.lastChild; Gu(u.contentDOM, u.children, t), n = l ? l.nextSibling : r.firstChild } } for (; n;)n = ls(n), i = !0; i && t.trackWrites == r && (t.trackWrites = null) } const qt = function (r) { r && (this.nodeName = r) }; qt.prototype = Object.create(null); const rt = [new qt]; function zr(r, e, t) { if (r.length == 0) return rt; let n = t ? rt[0] : new qt, i = [n]; for (let s = 0; s < r.length; s++) { let u = r[s].type.attrs; if (u) { u.nodeName && i.push(n = new qt(u.nodeName)); for (let o in u) { let l = u[o]; l != null && (t && i.length == 1 && i.push(n = new qt(e.isInline ? "span" : "div")), o == "class" ? n.class = (n.class ? n.class + " " : "") + l : o == "style" ? n.style = (n.style ? n.style + ";" : "") + l : o != "nodeName" && (n[o] = l)) } } } return i } function Zu(r, e, t, n) { if (t == rt && n == rt) return e; let i = e; for (let s = 0; s < n.length; s++) { let u = n[s], o = t[s]; if (s) { let l; o && o.nodeName == u.nodeName && i != r && (l = i.parentNode) && l.nodeName.toLowerCase() == u.nodeName || (l = document.createElement(u.nodeName), l.pmIsDeco = !0, l.appendChild(i), o = rt[0]), i = l } qa(i, o || rt[0], u) } return i } function qa(r, e, t) { for (let n in e) n != "class" && n != "style" && n != "nodeName" && !(n in t) && r.removeAttribute(n); for (let n in t) n != "class" && n != "style" && n != "nodeName" && t[n] != e[n] && r.setAttribute(n, t[n]); if (e.class != t.class) { let n = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : []; for (let s = 0; s < n.length; s++)i.indexOf(n[s]) == -1 && r.classList.remove(n[s]); for (let s = 0; s < i.length; s++)n.indexOf(i[s]) == -1 && r.classList.add(i[s]); r.classList.length == 0 && r.removeAttribute("class") } if (e.style != t.style) { if (e.style) { let n = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i; for (; i = n.exec(e.style);)r.style.removeProperty(i[1]) } t.style && (r.style.cssText += t.style) } } function Qu(r, e, t) { return Zu(r, r, rt, zr(e, t, r.nodeType != 1)) } function On(r, e) { if (r.length != e.length) return !1; for (let t = 0; t < r.length; t++)if (!r[t].type.eq(e[t].type)) return !1; return !0 } function ls(r) { let e = r.nextSibling; return r.parentNode.removeChild(r), e } class Ha { constructor(e, t, n) { this.lock = t, this.view = n, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = ja(e.node.content, e) } destroyBetween(e, t) { if (e != t) { for (let n = e; n < t; n++)this.top.children[n].destroy(); this.top.children.splice(e, t - e), this.changed = !0 } } destroyRest() { this.destroyBetween(this.index, this.top.children.length) } syncToMarks(e, t, n) { let i = 0, s = this.stack.length >> 1, u = Math.min(s, e.length); for (; i < u && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1;)i++; for (; i < s;)this.destroyRest(), this.top.dirty = be, this.index = this.stack.pop(), this.top = this.stack.pop(), s--; for (; s < e.length;) { this.stack.push(this.top, this.index + 1); let o = -1; for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) { let a = this.top.children[l]; if (a.matchesMark(e[s]) && !this.isLocked(a.dom)) { o = l; break } } if (o > -1) o > this.index && (this.changed = !0, this.destroyBetween(this.index, o)), this.top = this.top.children[this.index]; else { let l = ht.create(this.top, e[s], t, n); this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0 } this.index = 0, s++ } } findNodeMatch(e, t, n, i) { let s = -1, u; if (i >= this.preMatch.index && (u = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && u.matchesNode(e, t, n)) s = this.top.children.indexOf(u, this.index); else for (let o = this.index, l = Math.min(this.top.children.length, o + 5); o < l; o++) { let a = this.top.children[o]; if (a.matchesNode(e, t, n) && !this.preMatch.matched.has(a)) { s = o; break } } return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0) } updateNodeAt(e, t, n, i, s) { let u = this.top.children[i]; return u.dirty == Ae && u.dom == u.contentDOM && (u.dirty = nt), u.update(e, t, n, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1 } findIndexWithChild(e) { for (; ;) { let t = e.parentNode; if (!t) return -1; if (t == this.top.contentDOM) { let n = e.pmViewDesc; if (n) { for (let i = this.index; i < this.top.children.length; i++)if (this.top.children[i] == n) return i } return -1 } e = t } } updateNextNode(e, t, n, i, s, u) { for (let o = this.index; o < this.top.children.length; o++) { let l = this.top.children[o]; if (l instanceof Je) { let a = this.preMatch.matched.get(l); if (a != null && a != s) return !1; let c = l.dom, d, f = this.isLocked(c) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Ae && On(t, l.outerDeco)); if (!f && l.update(e, t, n, i)) return this.destroyBetween(this.index, o), l.dom != c && (this.changed = !0), this.index++, !0; if (!f && (d = this.recreateWrapper(l, e, t, n, i, u))) return this.destroyBetween(this.index, o), this.top.children[this.index] = d, d.contentDOM && (d.dirty = nt, d.updateChildren(i, u + 1), d.dirty = be), this.changed = !0, this.index++, !0; break } } return !1 } recreateWrapper(e, t, n, i, s, u) { if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !On(n, e.outerDeco) || !i.eq(e.innerDeco)) return null; let o = Je.create(this.top, t, n, i, s, u); if (o.contentDOM) { o.children = e.children, e.children = []; for (let l of o.children) l.parent = o } return e.destroy(), o } addNode(e, t, n, i, s) { let u = Je.create(this.top, e, t, n, i, s); u.contentDOM && u.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, u), this.changed = !0 } placeWidget(e, t, n) { let i = this.index < this.top.children.length ? this.top.children[this.index] : null; if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode)) this.index++; else { let s = new Ju(this.top, e, t, n); this.top.children.splice(this.index++, 0, s), this.changed = !0 } } addTextblockHacks() { let e = this.top.children[this.index - 1], t = this.top; for (; e instanceof ht;)t = e, e = t.children[t.children.length - 1]; (!e || !(e instanceof Un) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((re || ee) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top)) } addHackNode(e, t) { if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e)) this.index++; else { let n = document.createElement(e); e == "IMG" && (n.className = "ProseMirror-separator", n.alt = ""), e == "BR" && (n.className = "ProseMirror-trailingBreak"); let i = new Ku(this.top, [], n, null); t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0 } } isLocked(e) { return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode)) } } function ja(r, e) { let t = e, n = t.children.length, i = r.childCount, s = new Map, u = []; e: for (; i > 0;) { let o; for (; ;)if (n) { let a = t.children[n - 1]; if (a instanceof ht) t = a, n = a.children.length; else { o = a, n--; break } } else { if (t == e) break e; n = t.parent.children.indexOf(t), t = t.parent } let l = o.node; if (l) { if (l != r.child(i - 1)) break; --i, s.set(o, i), u.push(o) } } return { index: i, matched: s, matches: u.reverse() } } function Wa(r, e) { return r.type.side - e.type.side } function Ua(r, e, t, n) { let i = e.locals(r), s = 0; if (i.length == 0) { for (let a = 0; a < r.childCount; a++) { let c = r.child(a); n(c, i, e.forChild(s, c), a), s += c.nodeSize } return } let u = 0, o = [], l = null; for (let a = 0; ;) { let c, d; for (; u < i.length && i[u].to == s;) { let g = i[u++]; g.widget && (c ? (d || (d = [c])).push(g) : c = g) } if (c) if (d) { d.sort(Wa); for (let g = 0; g < d.length; g++)t(d[g], a, !!l) } else t(c, a, !!l); let f, h; if (l) h = -1, f = l, l = null; else if (a < r.childCount) h = a, f = r.child(a++); else break; for (let g = 0; g < o.length; g++)o[g].to <= s && o.splice(g--, 1); for (; u < i.length && i[u].from <= s && i[u].to > s;)o.push(i[u++]); let p = s + f.nodeSize; if (f.isText) { let g = p; u < i.length && i[u].from < g && (g = i[u].from); for (let b = 0; b < o.length; b++)o[b].to < g && (g = o[b].to); g < p && (l = f.cut(g - s), f = f.cut(0, g - s), p = g, h = -1) } else for (; u < i.length && i[u].to < p;)u++; let m = f.isInline && !f.isLeaf ? o.filter(g => !g.inline) : o.slice(); n(f, m, e.forChild(s, f), h), s = p } } function Ja(r) { if (r.nodeName == "UL" || r.nodeName == "OL") { let e = r.style.cssText; r.style.cssText = e + "; list-style: square !important", window.getComputedStyle(r).listStyle, r.style.cssText = e } } function Ka(r, e, t, n) { for (let i = 0, s = 0; i < r.childCount && s <= n;) { let u = r.child(i++), o = s; if (s += u.nodeSize, !u.isText) continue; let l = u.text; for (; i < r.childCount;) { let a = r.child(i++); if (s += a.nodeSize, !a.isText) break; l += a.text } if (s >= t) { if (s >= n && l.slice(n - e.length - o, n - o) == e) return n - e.length; let a = o < n ? l.lastIndexOf(e, n - o - 1) : -1; if (a >= 0 && a + e.length + o >= t) return o + a; if (t == n && l.length >= n + e.length - o && l.slice(n - o, n - o + e.length) == e) return n } } return -1 } function $r(r, e, t, n, i) { let s = []; for (let u = 0, o = 0; u < r.length; u++) { let l = r[u], a = o, c = o += l.size; a >= t || c <= e ? s.push(l) : (a < e && s.push(l.slice(0, e - a, n)), i && (s.push(i), i = void 0), c > t && s.push(l.slice(t - a, l.size, n))) } return s } function ri(r, e = null) { let t = r.domSelectionRange(), n = r.state.doc; if (!t.focusNode) return null; let i = r.docView.nearestDesc(t.focusNode), s = i && i.size == 0, u = r.docView.posFromDOM(t.focusNode, t.focusOffset, 1); if (u < 0) return null; let o = n.resolve(u), l, a; if (Wn(t)) { for (l = u; i && !i.node;)i = i.parent; let d = i.node; if (i && d.isAtom && S.isSelectable(d) && i.parent && !(d.isInline && ka(t.focusNode, t.focusOffset, i.dom))) { let f = i.posBefore; a = new S(u == f ? o : n.resolve(f)) } } else { if (t instanceof r.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) { let d = u, f = u; for (let h = 0; h < t.rangeCount; h++) { let p = t.getRangeAt(h); d = Math.min(d, r.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, r.docView.posFromDOM(p.endContainer, p.endOffset, -1)) } if (d < 0) return null;[l, u] = f == r.state.selection.anchor ? [f, d] : [d, f], o = n.resolve(u) } else l = r.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1); if (l < 0) return null } let c = n.resolve(l); if (!a) { let d = e == "pointer" || r.state.selection.head < o.pos && !s ? 1 : -1; a = ii(r, c, o, d) } return a } function Yu(r) { return r.editable ? r.hasFocus() : eo(r) && document.activeElement && document.activeElement.contains(r.dom) } function Ie(r, e = !1) { let t = r.state.selection; if (Xu(r, t), !!Yu(r)) { if (!e && r.input.mouseDown && r.input.mouseDown.allowDefault && ee) { let n = r.domSelectionRange(), i = r.domObserver.currentSelection; if (n.anchorNode && i.anchorNode && ft(n.anchorNode, n.anchorOffset, i.anchorNode, i.anchorOffset)) { r.input.mouseDown.delayedSelectionSync = !0, r.domObserver.setCurSelection(); return } } if (r.domObserver.disconnectSelection(), r.cursorWrapper) Za(r); else { let { anchor: n, head: i } = t, s, u; as && !(t instanceof T) && (t.$from.parent.inlineContent || (s = cs(r, t.from)), !t.empty && !t.$from.parent.inlineContent && (u = cs(r, t.to))), r.docView.setSelection(n, i, r, e), as && (s && ds(s), u && ds(u)), t.visible ? r.dom.classList.remove("ProseMirror-hideselection") : (r.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Ga(r)) } r.domObserver.setCurSelection(), r.domObserver.connectSelection() } } const as = re || ee && Fu < 63; function cs(r, e) { let { node: t, offset: n } = r.docView.domFromPos(e, 0), i = n < t.childNodes.length ? t.childNodes[n] : null, s = n ? t.childNodes[n - 1] : null; if (re && i && i.contentEditable == "false") return fr(i); if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) { if (i) return fr(i); if (s) return fr(s) } } function fr(r) { return r.contentEditable = "true", re && r.draggable && (r.draggable = !1, r.wasDraggable = !0), r } function ds(r) { r.contentEditable = "false", r.wasDraggable && (r.draggable = !0, r.wasDraggable = null) } function Ga(r) { let e = r.dom.ownerDocument; e.removeEventListener("selectionchange", r.input.hideSelectionGuard); let t = r.domSelectionRange(), n = t.anchorNode, i = t.anchorOffset; e.addEventListener("selectionchange", r.input.hideSelectionGuard = () => { (t.anchorNode != n || t.anchorOffset != i) && (e.removeEventListener("selectionchange", r.input.hideSelectionGuard), setTimeout(() => { (!Yu(r) || r.state.selection.visible) && r.dom.classList.remove("ProseMirror-hideselection") }, 20)) }) } function Za(r) { let e = r.domSelection(), t = document.createRange(); if (!e) return; let n = r.cursorWrapper.dom, i = n.nodeName == "IMG"; i ? t.setStart(n.parentNode, Z(n) + 1) : t.setStart(n, 0), t.collapse(!0), e.removeAllRanges(), e.addRange(t), !i && !r.state.selection.visible && le && Ue <= 11 && (n.disabled = !0, n.disabled = !1) } function Xu(r, e) { if (e instanceof S) { let t = r.docView.descAt(e.from); t != r.lastSelectedViewDesc && (fs(r), t && t.selectNode(), r.lastSelectedViewDesc = t) } else fs(r) } function fs(r) { r.lastSelectedViewDesc && (r.lastSelectedViewDesc.parent && r.lastSelectedViewDesc.deselectNode(), r.lastSelectedViewDesc = void 0) } function ii(r, e, t, n) { return r.someProp("createSelectionBetween", i => i(r, e, t)) || T.between(e, t, n) } function hs(r) { return r.editable && !r.hasFocus() ? !1 : eo(r) } function eo(r) { let e = r.domSelectionRange(); if (!e.anchorNode) return !1; try { return r.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (r.editable || r.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode)) } catch { return !1 } } function Qa(r) { let e = r.docView.domFromPos(r.state.selection.anchor, 0), t = r.domSelectionRange(); return ft(e.node, e.offset, t.anchorNode, t.anchorOffset) } function _r(r, e) { let { $anchor: t, $head: n } = r.selection, i = e > 0 ? t.max(n) : t.min(n), s = i.parent.inlineContent ? i.depth ? r.doc.resolve(e > 0 ? i.after() : i.before()) : null : i; return s && M.findFrom(s, e) } function Be(r, e) { return r.dispatch(r.state.tr.setSelection(e).scrollIntoView()), !0 } function ps(r, e, t) { let n = r.state.selection; if (n instanceof T) if (t.indexOf("s") > -1) { let { $head: i } = n, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter; if (!s || s.isText || !s.isLeaf) return !1; let u = r.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1)); return Be(r, new T(n.$anchor, u)) } else if (n.empty) { if (r.endOfTextblock(e > 0 ? "forward" : "backward")) { let i = _r(r.state, e); return i && i instanceof S ? Be(r, i) : !1 } else if (!(pe && t.indexOf("m") > -1)) { let i = n.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, u; if (!s || s.isText) return !1; let o = e < 0 ? i.pos - s.nodeSize : i.pos; return s.isAtom || (u = r.docView.descAt(o)) && !u.contentDOM ? S.isSelectable(s) ? Be(r, new S(e < 0 ? r.state.doc.resolve(i.pos - s.nodeSize) : i)) : rn ? Be(r, new T(r.state.doc.resolve(e < 0 ? o : o + s.nodeSize))) : !1 : !1 } } else return !1; else { if (n instanceof S && n.node.isInline) return Be(r, new T(e > 0 ? n.$to : n.$from)); { let i = _r(r.state, e); return i ? Be(r, i) : !1 } } } function vn(r) { return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length } function Ht(r, e) { let t = r.pmViewDesc; return t && t.size == 0 && (e < 0 || r.nextSibling || r.nodeName != "BR") } function xt(r, e) { return e < 0 ? Ya(r) : Xa(r) } function Ya(r) { let e = r.domSelectionRange(), t = e.focusNode, n = e.focusOffset; if (!t) return; let i, s, u = !1; for (ke && t.nodeType == 1 && n < vn(t) && Ht(t.childNodes[n], -1) && (u = !0); ;)if (n > 0) { if (t.nodeType != 1) break; { let o = t.childNodes[n - 1]; if (Ht(o, -1)) i = t, s = --n; else if (o.nodeType == 3) t = o, n = t.nodeValue.length; else break } } else { if (to(t)) break; { let o = t.previousSibling; for (; o && Ht(o, -1);)i = t.parentNode, s = Z(o), o = o.previousSibling; if (o) t = o, n = vn(t); else { if (t = t.parentNode, t == r.dom) break; n = 0 } } } u ? Fr(r, t, n) : i && Fr(r, i, s) } function Xa(r) { let e = r.domSelectionRange(), t = e.focusNode, n = e.focusOffset; if (!t) return; let i = vn(t), s, u; for (; ;)if (n < i) { if (t.nodeType != 1) break; let o = t.childNodes[n]; if (Ht(o, 1)) s = t, u = ++n; else break } else { if (to(t)) break; { let o = t.nextSibling; for (; o && Ht(o, 1);)s = o.parentNode, u = Z(o) + 1, o = o.nextSibling; if (o) t = o, n = 0, i = vn(t); else { if (t = t.parentNode, t == r.dom) break; n = i = 0 } } } s && Fr(r, s, u) } function to(r) { let e = r.pmViewDesc; return e && e.node && e.node.isBlock } function ec(r, e) { for (; r && e == r.childNodes.length && !nn(r);)e = Z(r) + 1, r = r.parentNode; for (; r && e < r.childNodes.length;) { let t = r.childNodes[e]; if (t.nodeType == 3) return t; if (t.nodeType == 1 && t.contentEditable == "false") break; r = t, e = 0 } } function tc(r, e) { for (; r && !e && !nn(r);)e = Z(r), r = r.parentNode; for (; r && e;) { let t = r.childNodes[e - 1]; if (t.nodeType == 3) return t; if (t.nodeType == 1 && t.contentEditable == "false") break; r = t, e = r.childNodes.length } } function Fr(r, e, t) { if (e.nodeType != 3) { let s, u; (u = ec(e, t)) ? (e = u, t = 0) : (s = tc(e, t)) && (e = s, t = s.nodeValue.length) } let n = r.domSelection(); if (!n) return; if (Wn(n)) { let s = document.createRange(); s.setEnd(e, t), s.setStart(e, t), n.removeAllRanges(), n.addRange(s) } else n.extend && n.extend(e, t); r.domObserver.setCurSelection(); let { state: i } = r; setTimeout(() => { r.state == i && Ie(r) }, 50) } function ms(r, e) { let t = r.state.doc.resolve(e); if (!(ee || Ca) && t.parent.inlineContent) { let i = r.coordsAtPos(e); if (e > t.start()) { let s = r.coordsAtPos(e - 1), u = (s.top + s.bottom) / 2; if (u > i.top && u < i.bottom && Math.abs(s.left - i.left) > 1) return s.left < i.left ? "ltr" : "rtl" } if (e < t.end()) { let s = r.coordsAtPos(e + 1), u = (s.top + s.bottom) / 2; if (u > i.top && u < i.bottom && Math.abs(s.left - i.left) > 1) return s.left > i.left ? "ltr" : "rtl" } } return getComputedStyle(r.dom).direction == "rtl" ? "rtl" : "ltr" } function gs(r, e, t) { let n = r.state.selection; if (n instanceof T && !n.empty || t.indexOf("s") > -1 || pe && t.indexOf("m") > -1) return !1; let { $from: i, $to: s } = n; if (!i.parent.inlineContent || r.endOfTextblock(e < 0 ? "up" : "down")) { let u = _r(r.state, e); if (u && u instanceof S) return Be(r, u) } if (!i.parent.inlineContent) { let u = e < 0 ? i : s, o = n instanceof he ? M.near(u, e) : M.findFrom(u, e); return o ? Be(r, o) : !1 } return !1 } function bs(r, e) { if (!(r.state.selection instanceof T)) return !0; let { $head: t, $anchor: n, empty: i } = r.state.selection; if (!t.sameParent(n)) return !0; if (!i) return !1; if (r.endOfTextblock(e > 0 ? "forward" : "backward")) return !0; let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter); if (s && !s.isText) { let u = r.state.tr; return e < 0 ? u.delete(t.pos - s.nodeSize, t.pos) : u.delete(t.pos, t.pos + s.nodeSize), r.dispatch(u), !0 } return !1 } function ys(r, e, t) { r.domObserver.stop(), e.contentEditable = t, r.domObserver.start() } function nc(r) { if (!re || r.state.selection.$head.parentOffset > 0) return !1; let { focusNode: e, focusOffset: t } = r.domSelectionRange(); if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") { let n = e.firstChild; ys(r, n, "true"), setTimeout(() => ys(r, n, "false"), 20) } return !1 } function rc(r) { let e = ""; return r.ctrlKey && (e += "c"), r.metaKey && (e += "m"), r.altKey && (e += "a"), r.shiftKey && (e += "s"), e } function ic(r, e) { let t = e.keyCode, n = rc(e); if (t == 8 || pe && t == 72 && n == "c") return bs(r, -1) || xt(r, -1); if (t == 46 && !e.shiftKey || pe && t == 68 && n == "c") return bs(r, 1) || xt(r, 1); if (t == 13 || t == 27) return !0; if (t == 37 || pe && t == 66 && n == "c") { let i = t == 37 ? ms(r, r.state.selection.from) == "ltr" ? -1 : 1 : -1; return ps(r, i, n) || xt(r, i) } else if (t == 39 || pe && t == 70 && n == "c") { let i = t == 39 ? ms(r, r.state.selection.from) == "ltr" ? 1 : -1 : 1; return ps(r, i, n) || xt(r, i) } else { if (t == 38 || pe && t == 80 && n == "c") return gs(r, -1, n) || xt(r, -1); if (t == 40 || pe && t == 78 && n == "c") return nc(r) || gs(r, 1, n) || xt(r, 1); if (n == (pe ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90)) return !0 } return !1 } function si(r, e) {
    r.someProp("transformCopied", h => { e = h(e, r) }); let t = [], { content: n, openStart: i, openEnd: s } = e; for (; i > 1 && s > 1 && n.childCount == 1 && n.firstChild.childCount == 1;) { i--, s--; let h = n.firstChild; t.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), n = h.content } let u = r.someProp("clipboardSerializer") || gt.fromSchema(r.state.schema), o = oo(), l = o.createElement("div"); l.appendChild(u.serializeFragment(n, { document: o })); let a = l.firstChild, c, d = 0; for (; a && a.nodeType == 1 && (c = uo[a.nodeName.toLowerCase()]);) { for (let h = c.length - 1; h >= 0; h--) { let p = o.createElement(c[h]); for (; l.firstChild;)p.appendChild(l.firstChild); l.appendChild(p), d++ } a = l.firstChild } a && a.nodeType == 1 && a.setAttribute("data-pm-slice", `${i} ${s}${d ? ` -${d}` : ""} ${JSON.stringify(t)}`); let f = r.someProp("clipboardTextSerializer", h => h(e, r)) || e.content.textBetween(0, e.content.size, `

`); return { dom: l, text: f, slice: e }
} function no(r, e, t, n, i) {
    let s = i.parent.type.spec.code, u, o; if (!t && !e) return null; let l = e && (n || s || !t); if (l) {
        if (r.someProp("transformPastedText", f => { e = f(e, s || n, r) }), s) return e ? new x(y.from(r.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : x.empty; let d = r.someProp("clipboardTextParser", f => f(e, i, n, r)); if (d) o = d; else { let f = i.marks(), { schema: h } = r.state, p = gt.fromSchema(h); u = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach(m => { let g = u.appendChild(document.createElement("p")); m && g.appendChild(p.serializeNode(h.text(m, f))) }) }
    } else r.someProp("transformPastedHTML", d => { t = d(t, r) }), u = lc(t), rn && ac(u); let a = u && u.querySelector("[data-pm-slice]"), c = a && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(a.getAttribute("data-pm-slice") || ""); if (c && c[3]) for (let d = +c[3]; d > 0; d--) { let f = u.firstChild; for (; f && f.nodeType != 1;)f = f.nextSibling; if (!f) break; u = f } if (o || (o = (r.someProp("clipboardParser") || r.someProp("domParser") || We.fromSchema(r.state.schema)).parseSlice(u, { preserveWhitespace: !!(l || c), context: i, ruleFromNode(f) { return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !sc.test(f.parentNode.nodeName) ? { ignore: !0 } : null } })), c) o = cc(xs(o, +c[1], +c[2]), c[4]); else if (o = x.maxOpen(uc(o.content, i), !0), o.openStart || o.openEnd) { let d = 0, f = 0; for (let h = o.content.firstChild; d < o.openStart && !h.type.spec.isolating; d++, h = h.firstChild); for (let h = o.content.lastChild; f < o.openEnd && !h.type.spec.isolating; f++, h = h.lastChild); o = xs(o, d, f) } return r.someProp("transformPasted", d => { o = d(o, r) }), o
} const sc = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i; function uc(r, e) { if (r.childCount < 2) return r; for (let t = e.depth; t >= 0; t--) { let i = e.node(t).contentMatchAt(e.index(t)), s, u = []; if (r.forEach(o => { if (!u) return; let l = i.findWrapping(o.type), a; if (!l) return u = null; if (a = u.length && s.length && io(l, s, o, u[u.length - 1], 0)) u[u.length - 1] = a; else { u.length && (u[u.length - 1] = so(u[u.length - 1], s.length)); let c = ro(o, l); u.push(c), i = i.matchType(c.type), s = l } }), u) return y.from(u) } return r } function ro(r, e, t = 0) { for (let n = e.length - 1; n >= t; n--)r = e[n].create(null, y.from(r)); return r } function io(r, e, t, n, i) { if (i < r.length && i < e.length && r[i] == e[i]) { let s = io(r, e, t, n.lastChild, i + 1); if (s) return n.copy(n.content.replaceChild(n.childCount - 1, s)); if (n.contentMatchAt(n.childCount).matchType(i == r.length - 1 ? t.type : r[i + 1])) return n.copy(n.content.append(y.from(ro(t, r, i + 1)))) } } function so(r, e) { if (e == 0) return r; let t = r.content.replaceChild(r.childCount - 1, so(r.lastChild, e - 1)), n = r.contentMatchAt(r.childCount).fillBefore(y.empty, !0); return r.copy(t.append(n)) } function Vr(r, e, t, n, i, s) { let u = e < 0 ? r.firstChild : r.lastChild, o = u.content; return r.childCount > 1 && (s = 0), i < n - 1 && (o = Vr(o, e, t, n, i + 1, s)), i >= t && (o = e < 0 ? u.contentMatchAt(0).fillBefore(o, s <= i).append(o) : o.append(u.contentMatchAt(u.childCount).fillBefore(y.empty, !0))), r.replaceChild(e < 0 ? 0 : r.childCount - 1, u.copy(o)) } function xs(r, e, t) { return e < r.openStart && (r = new x(Vr(r.content, -1, e, r.openStart, 0, r.openEnd), e, r.openEnd)), t < r.openEnd && (r = new x(Vr(r.content, 1, t, r.openEnd, 0, 0), r.openStart, t)), r } const uo = { thead: ["table"], tbody: ["table"], tfoot: ["table"], caption: ["table"], colgroup: ["table"], col: ["table", "colgroup"], tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"] }; let ks = null; function oo() { return ks || (ks = document.implementation.createHTMLDocument("title")) } let hr = null; function oc(r) { let e = window.trustedTypes; return e ? (hr || (hr = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: t => t })), hr.createHTML(r)) : r } function lc(r) { let e = /^(\s*<meta [^>]*>)*/.exec(r); e && (r = r.slice(e[0].length)); let t = oo().createElement("div"), n = /<([a-z][^>\s]+)/i.exec(r), i; if ((i = n && uo[n[1].toLowerCase()]) && (r = i.map(s => "<" + s + ">").join("") + r + i.map(s => "</" + s + ">").reverse().join("")), t.innerHTML = oc(r), i) for (let s = 0; s < i.length; s++)t = t.querySelector(i[s]) || t; return t } function ac(r) { let e = r.querySelectorAll(ee ? "span:not([class]):not([style])" : "span.Apple-converted-space"); for (let t = 0; t < e.length; t++) { let n = e[t]; n.childNodes.length == 1 && n.textContent == "" && n.parentNode && n.parentNode.replaceChild(r.ownerDocument.createTextNode(" "), n) } } function cc(r, e) { if (!r.size) return r; let t = r.content.firstChild.type.schema, n; try { n = JSON.parse(e) } catch { return r } let { content: i, openStart: s, openEnd: u } = r; for (let o = n.length - 2; o >= 0; o -= 2) { let l = t.nodes[n[o]]; if (!l || l.hasRequiredAttrs()) break; i = y.from(l.create(n[o + 1], i)), s++, u++ } return new x(i, s, u) } const ie = {}, se = {}, dc = { touchstart: !0, touchmove: !0 }; class fc { constructor() { this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = Object.create(null), this.hideSelectionGuard = null } } function hc(r) { for (let e in ie) { let t = ie[e]; r.dom.addEventListener(e, r.input.eventHandlers[e] = n => { mc(r, n) && !ui(r, n) && (r.editable || !(n.type in se)) && t(r, n) }, dc[e] ? { passive: !0 } : void 0) } re && r.dom.addEventListener("input", () => null), qr(r) } function qe(r, e) { r.input.lastSelectionOrigin = e, r.input.lastSelectionTime = Date.now() } function pc(r) { r.domObserver.stop(); for (let e in r.input.eventHandlers) r.dom.removeEventListener(e, r.input.eventHandlers[e]); clearTimeout(r.input.composingTimeout), clearTimeout(r.input.lastIOSEnterFallbackTimeout) } function qr(r) { r.someProp("handleDOMEvents", e => { for (let t in e) r.input.eventHandlers[t] || r.dom.addEventListener(t, r.input.eventHandlers[t] = n => ui(r, n)) }) } function ui(r, e) { return r.someProp("handleDOMEvents", t => { let n = t[e.type]; return n ? n(r, e) || e.defaultPrevented : !1 }) } function mc(r, e) { if (!e.bubbles) return !0; if (e.defaultPrevented) return !1; for (let t = e.target; t != r.dom; t = t.parentNode)if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e)) return !1; return !0 } function gc(r, e) { !ui(r, e) && ie[e.type] && (r.editable || !(e.type in se)) && ie[e.type](r, e) } se.keydown = (r, e) => { let t = e; if (r.input.shiftKey = t.keyCode == 16 || t.shiftKey, !ao(r, t) && (r.input.lastKeyCode = t.keyCode, r.input.lastKeyCodeTime = Date.now(), !(De && ee && t.keyCode == 13))) if (t.keyCode != 229 && r.domObserver.forceFlush(), Ot && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) { let n = Date.now(); r.input.lastIOSEnter = n, r.input.lastIOSEnterFallbackTimeout = setTimeout(() => { r.input.lastIOSEnter == n && (r.someProp("handleKeyDown", i => i(r, et(13, "Enter"))), r.input.lastIOSEnter = 0) }, 200) } else r.someProp("handleKeyDown", n => n(r, t)) || ic(r, t) ? t.preventDefault() : qe(r, "key") }; se.keyup = (r, e) => { e.keyCode == 16 && (r.input.shiftKey = !1) }; se.keypress = (r, e) => { let t = e; if (ao(r, t) || !t.charCode || t.ctrlKey && !t.altKey || pe && t.metaKey) return; if (r.someProp("handleKeyPress", i => i(r, t))) { t.preventDefault(); return } let n = r.state.selection; if (!(n instanceof T) || !n.$from.sameParent(n.$to)) { let i = String.fromCharCode(t.charCode), s = () => r.state.tr.insertText(i).scrollIntoView(); !/[\r\n]/.test(i) && !r.someProp("handleTextInput", u => u(r, n.$from.pos, n.$to.pos, i, s)) && r.dispatch(s()), t.preventDefault() } }; function Jn(r) { return { left: r.clientX, top: r.clientY } } function bc(r, e) { let t = e.x - r.clientX, n = e.y - r.clientY; return t * t + n * n < 100 } function oi(r, e, t, n, i) { if (n == -1) return !1; let s = r.state.doc.resolve(n); for (let u = s.depth + 1; u > 0; u--)if (r.someProp(e, o => u > s.depth ? o(r, t, s.nodeAfter, s.before(u), i, !0) : o(r, t, s.node(u), s.before(u), i, !1))) return !0; return !1 } function Mt(r, e, t) { if (r.focused || r.focus(), r.state.selection.eq(e)) return; let n = r.state.tr.setSelection(e); n.setMeta("pointer", !0), r.dispatch(n) } function yc(r, e) { if (e == -1) return !1; let t = r.state.doc.resolve(e), n = t.nodeAfter; return n && n.isAtom && S.isSelectable(n) ? (Mt(r, new S(t)), !0) : !1 } function xc(r, e) { if (e == -1) return !1; let t = r.state.selection, n, i; t instanceof S && (n = t.node); let s = r.state.doc.resolve(e); for (let u = s.depth + 1; u > 0; u--) { let o = u > s.depth ? s.nodeAfter : s.node(u); if (S.isSelectable(o)) { n && t.$from.depth > 0 && u >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(u); break } } return i != null ? (Mt(r, S.create(r.state.doc, i)), !0) : !1 } function kc(r, e, t, n, i) { return oi(r, "handleClickOn", e, t, n) || r.someProp("handleClick", s => s(r, e, n)) || (i ? xc(r, t) : yc(r, t)) } function wc(r, e, t, n) { return oi(r, "handleDoubleClickOn", e, t, n) || r.someProp("handleDoubleClick", i => i(r, e, n)) } function Sc(r, e, t, n) { return oi(r, "handleTripleClickOn", e, t, n) || r.someProp("handleTripleClick", i => i(r, e, n)) || Cc(r, t, n) } function Cc(r, e, t) { if (t.button != 0) return !1; let n = r.state.doc; if (e == -1) return n.inlineContent ? (Mt(r, T.create(n, 0, n.content.size)), !0) : !1; let i = n.resolve(e); for (let s = i.depth + 1; s > 0; s--) { let u = s > i.depth ? i.nodeAfter : i.node(s), o = i.before(s); if (u.inlineContent) Mt(r, T.create(n, o + 1, o + 1 + u.content.size)); else if (S.isSelectable(u)) Mt(r, S.create(n, o)); else continue; return !0 } } function li(r) { return Dn(r) } const lo = pe ? "metaKey" : "ctrlKey"; ie.mousedown = (r, e) => { let t = e; r.input.shiftKey = t.shiftKey; let n = li(r), i = Date.now(), s = "singleClick"; i - r.input.lastClick.time < 500 && bc(t, r.input.lastClick) && !t[lo] && r.input.lastClick.button == t.button && (r.input.lastClick.type == "singleClick" ? s = "doubleClick" : r.input.lastClick.type == "doubleClick" && (s = "tripleClick")), r.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s, button: t.button }; let u = r.posAtCoords(Jn(t)); u && (s == "singleClick" ? (r.input.mouseDown && r.input.mouseDown.done(), r.input.mouseDown = new Tc(r, u, t, !!n)) : (s == "doubleClick" ? wc : Sc)(r, u.pos, u.inside, t) ? t.preventDefault() : qe(r, "pointer")) }; class Tc { constructor(e, t, n, i) { this.view = e, this.pos = t, this.event = n, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!n[lo], this.allowDefault = n.shiftKey; let s, u; if (t.inside > -1) s = e.state.doc.nodeAt(t.inside), u = t.inside; else { let c = e.state.doc.resolve(t.pos); s = c.parent, u = c.depth ? c.before() : 0 } const o = i ? null : n.target, l = o ? e.docView.nearestDesc(o, !0) : null; this.target = l && l.dom.nodeType == 1 ? l.dom : null; let { selection: a } = e.state; (n.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || a instanceof S && a.from <= u && a.to > u) && (this.mightDrag = { node: s, pos: u, addAttr: !!(this.target && !this.target.draggable), setUneditable: !!(this.target && ke && !this.target.hasAttribute("contentEditable")) }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => { this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false") }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), qe(e, "pointer") } done() { this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Ie(this.view)), this.view.input.mouseDown = null } up(e) { if (this.done(), !this.view.dom.contains(e.target)) return; let t = this.pos; this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(Jn(e))), this.updateAllowDefault(e), this.allowDefault || !t ? qe(this.view, "pointer") : kc(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || re && this.mightDrag && !this.mightDrag.node.isAtom || ee && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (Mt(this.view, M.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : qe(this.view, "pointer") } move(e) { this.updateAllowDefault(e), qe(this.view, "pointer"), e.buttons == 0 && this.done() } updateAllowDefault(e) { !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0) } } ie.touchstart = r => { r.input.lastTouch = Date.now(), li(r), qe(r, "pointer") }; ie.touchmove = r => { r.input.lastTouch = Date.now(), qe(r, "pointer") }; ie.contextmenu = r => li(r); function ao(r, e) { return r.composing ? !0 : re && Math.abs(e.timeStamp - r.input.compositionEndedAt) < 500 ? (r.input.compositionEndedAt = -2e8, !0) : !1 } const Ec = De ? 5e3 : -1; se.compositionstart = se.compositionupdate = r => { if (!r.composing) { r.domObserver.flush(); let { state: e } = r, t = e.selection.$to; if (e.selection instanceof T && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some(n => n.type.spec.inclusive === !1))) r.markCursor = r.state.storedMarks || t.marks(), Dn(r, !0), r.markCursor = null; else if (Dn(r, !e.selection.empty), ke && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) { let n = r.domSelectionRange(); for (let i = n.focusNode, s = n.focusOffset; i && i.nodeType == 1 && s != 0;) { let u = s < 0 ? i.lastChild : i.childNodes[s - 1]; if (!u) break; if (u.nodeType == 3) { let o = r.domSelection(); o && o.collapse(u, u.nodeValue.length); break } else i = u, s = -1 } } r.input.composing = !0 } co(r, Ec) }; se.compositionend = (r, e) => { r.composing && (r.input.composing = !1, r.input.compositionEndedAt = e.timeStamp, r.input.compositionPendingChanges = r.domObserver.pendingRecords().length ? r.input.compositionID : 0, r.input.compositionNode = null, r.input.compositionPendingChanges && Promise.resolve().then(() => r.domObserver.flush()), r.input.compositionID++, co(r, 20)) }; function co(r, e) { clearTimeout(r.input.composingTimeout), e > -1 && (r.input.composingTimeout = setTimeout(() => Dn(r), e)) } function fo(r) { for (r.composing && (r.input.composing = !1, r.input.compositionEndedAt = Nc()); r.input.compositionNodes.length > 0;)r.input.compositionNodes.pop().markParentsDirty() } function Mc(r) { let e = r.domSelectionRange(); if (!e.focusNode) return null; let t = ya(e.focusNode, e.focusOffset), n = xa(e.focusNode, e.focusOffset); if (t && n && t != n) { let i = n.pmViewDesc, s = r.domObserver.lastChangedTextNode; if (t == s || n == s) return s; if (!i || !i.isText(n.nodeValue)) return n; if (r.input.compositionNode == n) { let u = t.pmViewDesc; if (!(!u || !u.isText(t.nodeValue))) return n } } return t || n } function Nc() { let r = document.createEvent("Event"); return r.initEvent("event", !0, !0), r.timeStamp } function Dn(r, e = !1) { if (!(De && r.domObserver.flushingSoon >= 0)) { if (r.domObserver.forceFlush(), fo(r), e || r.docView && r.docView.dirty) { let t = ri(r), n = r.state.selection; return t && !t.eq(n) ? r.dispatch(r.state.tr.setSelection(t)) : (r.markCursor || e) && !n.$from.node(n.$from.sharedDepth(n.to)).inlineContent ? r.dispatch(r.state.tr.deleteSelection()) : r.updateState(r.state), !0 } return !1 } } function Ac(r, e) { if (!r.dom.parentNode) return; let t = r.dom.parentNode.appendChild(document.createElement("div")); t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px"; let n = getSelection(), i = document.createRange(); i.selectNodeContents(e), r.dom.blur(), n.removeAllRanges(), n.addRange(i), setTimeout(() => { t.parentNode && t.parentNode.removeChild(t), r.focus() }, 50) } const Zt = le && Ue < 15 || Ot && Ta < 604; ie.copy = se.cut = (r, e) => { let t = e, n = r.state.selection, i = t.type == "cut"; if (n.empty) return; let s = Zt ? null : t.clipboardData, u = n.content(), { dom: o, text: l } = si(r, u); s ? (t.preventDefault(), s.clearData(), s.setData("text/html", o.innerHTML), s.setData("text/plain", l)) : Ac(r, o), i && r.dispatch(r.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")) }; function Oc(r) { return r.openStart == 0 && r.openEnd == 0 && r.content.childCount == 1 ? r.content.firstChild : null } function vc(r, e) { if (!r.dom.parentNode) return; let t = r.input.shiftKey || r.state.selection.$from.parent.type.spec.code, n = r.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div")); t || (n.contentEditable = "true"), n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(); let i = r.input.shiftKey && r.input.lastKeyCode != 45; setTimeout(() => { r.focus(), n.parentNode && n.parentNode.removeChild(n), t ? Qt(r, n.value, null, i, e) : Qt(r, n.textContent, n.innerHTML, i, e) }, 50) } function Qt(r, e, t, n, i) { let s = no(r, e, t, n, r.state.selection.$from); if (r.someProp("handlePaste", l => l(r, i, s || x.empty))) return !0; if (!s) return !1; let u = Oc(s), o = u ? r.state.tr.replaceSelectionWith(u, n) : r.state.tr.replaceSelection(s); return r.dispatch(o.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0 } function ho(r) { let e = r.getData("text/plain") || r.getData("Text"); if (e) return e; let t = r.getData("text/uri-list"); return t ? t.replace(/\r?\n/g, " ") : "" } se.paste = (r, e) => { let t = e; if (r.composing && !De) return; let n = Zt ? null : t.clipboardData, i = r.input.shiftKey && r.input.lastKeyCode != 45; n && Qt(r, ho(n), n.getData("text/html"), i, t) ? t.preventDefault() : vc(r, t) }; class po { constructor(e, t, n) { this.slice = e, this.move = t, this.node = n } } const Dc = pe ? "altKey" : "ctrlKey"; function mo(r, e) { let t = r.someProp("dragCopies", n => !n(e)); return t ?? !e[Dc] } ie.dragstart = (r, e) => { let t = e, n = r.input.mouseDown; if (n && n.done(), !t.dataTransfer) return; let i = r.state.selection, s = i.empty ? null : r.posAtCoords(Jn(t)), u; if (!(s && s.pos >= i.from && s.pos <= (i instanceof S ? i.to - 1 : i.to))) { if (n && n.mightDrag) u = S.create(r.state.doc, n.mightDrag.pos); else if (t.target && t.target.nodeType == 1) { let d = r.docView.nearestDesc(t.target, !0); d && d.node.type.spec.draggable && d != r.docView && (u = S.create(r.state.doc, d.posBefore)) } } let o = (u || r.state.selection).content(), { dom: l, text: a, slice: c } = si(r, o); (!t.dataTransfer.files.length || !ee || Fu > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Zt ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Zt || t.dataTransfer.setData("text/plain", a), r.dragging = new po(c, mo(r, t), u) }; ie.dragend = r => { let e = r.dragging; window.setTimeout(() => { r.dragging == e && (r.dragging = null) }, 50) }; se.dragover = se.dragenter = (r, e) => e.preventDefault(); se.drop = (r, e) => { let t = e, n = r.dragging; if (r.dragging = null, !t.dataTransfer) return; let i = r.posAtCoords(Jn(t)); if (!i) return; let s = r.state.doc.resolve(i.pos), u = n && n.slice; u ? r.someProp("transformPasted", p => { u = p(u, r) }) : u = no(r, ho(t.dataTransfer), Zt ? null : t.dataTransfer.getData("text/html"), !1, s); let o = !!(n && mo(r, t)); if (r.someProp("handleDrop", p => p(r, t, u || x.empty, o))) { t.preventDefault(); return } if (!u) return; t.preventDefault(); let l = u ? Ru(r.state.doc, s.pos, u) : s.pos; l == null && (l = s.pos); let a = r.state.tr; if (o) { let { node: p } = n; p ? p.replace(a) : a.deleteSelection() } let c = a.mapping.map(l), d = u.openStart == 0 && u.openEnd == 0 && u.content.childCount == 1, f = a.doc; if (d ? a.replaceRangeWith(c, c, u.content.firstChild) : a.replaceRange(c, c, u), a.doc.eq(f)) return; let h = a.doc.resolve(c); if (d && S.isSelectable(u.content.firstChild) && h.nodeAfter && h.nodeAfter.sameMarkup(u.content.firstChild)) a.setSelection(new S(h)); else { let p = a.mapping.map(l); a.mapping.maps[a.mapping.maps.length - 1].forEach((m, g, b, w) => p = w), a.setSelection(ii(r, h, a.doc.resolve(p))) } r.focus(), r.dispatch(a.setMeta("uiEvent", "drop")) }; ie.focus = r => { r.input.lastFocus = Date.now(), r.focused || (r.domObserver.stop(), r.dom.classList.add("ProseMirror-focused"), r.domObserver.start(), r.focused = !0, setTimeout(() => { r.docView && r.hasFocus() && !r.domObserver.currentSelection.eq(r.domSelectionRange()) && Ie(r) }, 20)) }; ie.blur = (r, e) => { let t = e; r.focused && (r.domObserver.stop(), r.dom.classList.remove("ProseMirror-focused"), r.domObserver.start(), t.relatedTarget && r.dom.contains(t.relatedTarget) && r.domObserver.currentSelection.clear(), r.focused = !1) }; ie.beforeinput = (r, e) => { if (ee && De && e.inputType == "deleteContentBackward") { r.domObserver.flushSoon(); let { domChangeCount: n } = r.input; setTimeout(() => { if (r.input.domChangeCount != n || (r.dom.blur(), r.focus(), r.someProp("handleKeyDown", s => s(r, et(8, "Backspace"))))) return; let { $cursor: i } = r.state.selection; i && i.pos > 0 && r.dispatch(r.state.tr.delete(i.pos - 1, i.pos).scrollIntoView()) }, 50) } }; for (let r in se) ie[r] = se[r]; function Yt(r, e) { if (r == e) return !0; for (let t in r) if (r[t] !== e[t]) return !1; for (let t in e) if (!(t in r)) return !1; return !0 } class Rn { constructor(e, t) { this.toDOM = e, this.spec = t || ot, this.side = this.spec.side || 0 } map(e, t, n, i) { let { pos: s, deleted: u } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1); return u ? null : new fe(s - n, s - n, this) } valid() { return !0 } eq(e) { return this == e || e instanceof Rn && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Yt(this.spec, e.spec)) } destroy(e) { this.spec.destroy && this.spec.destroy(e) } } class Ke { constructor(e, t) { this.attrs = e, this.spec = t || ot } map(e, t, n, i) { let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - n, u = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - n; return s >= u ? null : new fe(s, u, this) } valid(e, t) { return t.from < t.to } eq(e) { return this == e || e instanceof Ke && Yt(this.attrs, e.attrs) && Yt(this.spec, e.spec) } static is(e) { return e.type instanceof Ke } destroy() { } } class ai { constructor(e, t) { this.attrs = e, this.spec = t || ot } map(e, t, n, i) { let s = e.mapResult(t.from + i, 1); if (s.deleted) return null; let u = e.mapResult(t.to + i, -1); return u.deleted || u.pos <= s.pos ? null : new fe(s.pos - n, u.pos - n, this) } valid(e, t) { let { index: n, offset: i } = e.content.findIndex(t.from), s; return i == t.from && !(s = e.child(n)).isText && i + s.nodeSize == t.to } eq(e) { return this == e || e instanceof ai && Yt(this.attrs, e.attrs) && Yt(this.spec, e.spec) } destroy() { } } class fe { constructor(e, t, n) { this.from = e, this.to = t, this.type = n } copy(e, t) { return new fe(e, t, this.type) } eq(e, t = 0) { return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to } map(e, t, n) { return this.type.map(e, this, t, n) } static widget(e, t, n) { return new fe(e, e, new Rn(t, n)) } static inline(e, t, n, i) { return new fe(e, t, new Ke(n, i)) } static node(e, t, n, i) { return new fe(e, t, new ai(n, i)) } get spec() { return this.type.spec } get inline() { return this.type instanceof Ke } get widget() { return this.type instanceof Rn } } const wt = [], ot = {}; class _ { constructor(e, t) { this.local = e.length ? e : wt, this.children = t.length ? t : wt } static create(e, t) { return t.length ? In(t, e, 0, ot) : X } find(e, t, n) { let i = []; return this.findInner(e ?? 0, t ?? 1e9, i, 0, n), i } findInner(e, t, n, i, s) { for (let u = 0; u < this.local.length; u++) { let o = this.local[u]; o.from <= t && o.to >= e && (!s || s(o.spec)) && n.push(o.copy(o.from + i, o.to + i)) } for (let u = 0; u < this.children.length; u += 3)if (this.children[u] < t && this.children[u + 1] > e) { let o = this.children[u] + 1; this.children[u + 2].findInner(e - o, t - o, n, i + o, s) } } map(e, t, n) { return this == X || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, n || ot) } mapInner(e, t, n, i, s) { let u; for (let o = 0; o < this.local.length; o++) { let l = this.local[o].map(e, n, i); l && l.type.valid(t, l) ? (u || (u = [])).push(l) : s.onRemove && s.onRemove(this.local[o].spec) } return this.children.length ? Rc(this.children, u || [], e, t, n, i, s) : u ? new _(u.sort(lt), wt) : X } add(e, t) { return t.length ? this == X ? _.create(e, t) : this.addInner(e, t, 0) : this } addInner(e, t, n) { let i, s = 0; e.forEach((o, l) => { let a = l + n, c; if (c = bo(t, o, a)) { for (i || (i = this.children.slice()); s < i.length && i[s] < l;)s += 3; i[s] == l ? i[s + 2] = i[s + 2].addInner(o, c, a + 1) : i.splice(s, 0, l, l + o.nodeSize, In(c, o, a + 1, ot)), s += 3 } }); let u = go(s ? yo(t) : t, -n); for (let o = 0; o < u.length; o++)u[o].type.valid(e, u[o]) || u.splice(o--, 1); return new _(u.length ? this.local.concat(u).sort(lt) : this.local, i || this.children) } remove(e) { return e.length == 0 || this == X ? this : this.removeInner(e, 0) } removeInner(e, t) { let n = this.children, i = this.local; for (let s = 0; s < n.length; s += 3) { let u, o = n[s] + t, l = n[s + 1] + t; for (let c = 0, d; c < e.length; c++)(d = e[c]) && d.from > o && d.to < l && (e[c] = null, (u || (u = [])).push(d)); if (!u) continue; n == this.children && (n = this.children.slice()); let a = n[s + 2].removeInner(u, o + 1); a != X ? n[s + 2] = a : (n.splice(s, 3), s -= 3) } if (i.length) { for (let s = 0, u; s < e.length; s++)if (u = e[s]) for (let o = 0; o < i.length; o++)i[o].eq(u, t) && (i == this.local && (i = this.local.slice()), i.splice(o--, 1)) } return n == this.children && i == this.local ? this : i.length || n.length ? new _(i, n) : X } forChild(e, t) { if (this == X) return this; if (t.isLeaf) return _.empty; let n, i; for (let o = 0; o < this.children.length; o += 3)if (this.children[o] >= e) { this.children[o] == e && (n = this.children[o + 2]); break } let s = e + 1, u = s + t.content.size; for (let o = 0; o < this.local.length; o++) { let l = this.local[o]; if (l.from < u && l.to > s && l.type instanceof Ke) { let a = Math.max(s, l.from) - s, c = Math.min(u, l.to) - s; a < c && (i || (i = [])).push(l.copy(a, c)) } } if (i) { let o = new _(i.sort(lt), wt); return n ? new $e([o, n]) : o } return n || X } eq(e) { if (this == e) return !0; if (!(e instanceof _) || this.local.length != e.local.length || this.children.length != e.children.length) return !1; for (let t = 0; t < this.local.length; t++)if (!this.local[t].eq(e.local[t])) return !1; for (let t = 0; t < this.children.length; t += 3)if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2])) return !1; return !0 } locals(e) { return ci(this.localsInner(e)) } localsInner(e) { if (this == X) return wt; if (e.inlineContent || !this.local.some(Ke.is)) return this.local; let t = []; for (let n = 0; n < this.local.length; n++)this.local[n].type instanceof Ke || t.push(this.local[n]); return t } forEachSet(e) { e(this) } } _.empty = new _([], []); _.removeOverlap = ci; const X = _.empty; class $e { constructor(e) { this.members = e } map(e, t) { const n = this.members.map(i => i.map(e, t, ot)); return $e.from(n) } forChild(e, t) { if (t.isLeaf) return _.empty; let n = []; for (let i = 0; i < this.members.length; i++) { let s = this.members[i].forChild(e, t); s != X && (s instanceof $e ? n = n.concat(s.members) : n.push(s)) } return $e.from(n) } eq(e) { if (!(e instanceof $e) || e.members.length != this.members.length) return !1; for (let t = 0; t < this.members.length; t++)if (!this.members[t].eq(e.members[t])) return !1; return !0 } locals(e) { let t, n = !0; for (let i = 0; i < this.members.length; i++) { let s = this.members[i].localsInner(e); if (s.length) if (!t) t = s; else { n && (t = t.slice(), n = !1); for (let u = 0; u < s.length; u++)t.push(s[u]) } } return t ? ci(n ? t : t.sort(lt)) : wt } static from(e) { switch (e.length) { case 0: return X; case 1: return e[0]; default: return new $e(e.every(t => t instanceof _) ? e : e.reduce((t, n) => t.concat(n instanceof _ ? n : n.members), [])) } } forEachSet(e) { for (let t = 0; t < this.members.length; t++)this.members[t].forEachSet(e) } } function Rc(r, e, t, n, i, s, u) { let o = r.slice(); for (let a = 0, c = s; a < t.maps.length; a++) { let d = 0; t.maps[a].forEach((f, h, p, m) => { let g = m - p - (h - f); for (let b = 0; b < o.length; b += 3) { let w = o[b + 1]; if (w < 0 || f > w + c - d) continue; let C = o[b] + c - d; h >= C ? o[b + 1] = f <= C ? -2 : -1 : f >= c && g && (o[b] += g, o[b + 1] += g) } d += g }), c = t.maps[a].map(c, -1) } let l = !1; for (let a = 0; a < o.length; a += 3)if (o[a + 1] < 0) { if (o[a + 1] == -2) { l = !0, o[a + 1] = -1; continue } let c = t.map(r[a] + s), d = c - i; if (d < 0 || d >= n.content.size) { l = !0; continue } let f = t.map(r[a + 1] + s, -1), h = f - i, { index: p, offset: m } = n.content.findIndex(d), g = n.maybeChild(p); if (g && m == d && m + g.nodeSize == h) { let b = o[a + 2].mapInner(t, g, c + 1, r[a] + s + 1, u); b != X ? (o[a] = d, o[a + 1] = h, o[a + 2] = b) : (o[a + 1] = -2, l = !0) } else l = !0 } if (l) { let a = Ic(o, r, e, t, i, s, u), c = In(a, n, 0, u); e = c.local; for (let d = 0; d < o.length; d += 3)o[d + 1] < 0 && (o.splice(d, 3), d -= 3); for (let d = 0, f = 0; d < c.children.length; d += 3) { let h = c.children[d]; for (; f < o.length && o[f] < h;)f += 3; o.splice(f, 0, c.children[d], c.children[d + 1], c.children[d + 2]) } } return new _(e.sort(lt), o) } function go(r, e) { if (!e || !r.length) return r; let t = []; for (let n = 0; n < r.length; n++) { let i = r[n]; t.push(new fe(i.from + e, i.to + e, i.type)) } return t } function Ic(r, e, t, n, i, s, u) { function o(l, a) { for (let c = 0; c < l.local.length; c++) { let d = l.local[c].map(n, i, a); d ? t.push(d) : u.onRemove && u.onRemove(l.local[c].spec) } for (let c = 0; c < l.children.length; c += 3)o(l.children[c + 2], l.children[c] + a + 1) } for (let l = 0; l < r.length; l += 3)r[l + 1] == -1 && o(r[l + 2], e[l] + s + 1); return t } function bo(r, e, t) { if (e.isLeaf) return null; let n = t + e.nodeSize, i = null; for (let s = 0, u; s < r.length; s++)(u = r[s]) && u.from > t && u.to < n && ((i || (i = [])).push(u), r[s] = null); return i } function yo(r) { let e = []; for (let t = 0; t < r.length; t++)r[t] != null && e.push(r[t]); return e } function In(r, e, t, n) { let i = [], s = !1; e.forEach((o, l) => { let a = bo(r, o, l + t); if (a) { s = !0; let c = In(a, o, t + l + 1, n); c != X && i.push(l, l + o.nodeSize, c) } }); let u = go(s ? yo(r) : r, -t).sort(lt); for (let o = 0; o < u.length; o++)u[o].type.valid(e, u[o]) || (n.onRemove && n.onRemove(u[o].spec), u.splice(o--, 1)); return u.length || i.length ? new _(u, i) : X } function lt(r, e) { return r.from - e.from || r.to - e.to } function ci(r) { let e = r; for (let t = 0; t < e.length - 1; t++) { let n = e[t]; if (n.from != n.to) for (let i = t + 1; i < e.length; i++) { let s = e[i]; if (s.from == n.from) { s.to != n.to && (e == r && (e = r.slice()), e[i] = s.copy(s.from, n.to), ws(e, i + 1, s.copy(n.to, s.to))); continue } else { s.from < n.to && (e == r && (e = r.slice()), e[t] = n.copy(n.from, s.from), ws(e, i, n.copy(s.from, n.to))); break } } } return e } function ws(r, e, t) { for (; e < r.length && lt(t, r[e]) > 0;)e++; r.splice(e, 0, t) } function pr(r) { let e = []; return r.someProp("decorations", t => { let n = t(r.state); n && n != X && e.push(n) }), r.cursorWrapper && e.push(_.create(r.state.doc, [r.cursorWrapper.deco])), $e.from(e) } const Pc = { childList: !0, characterData: !0, characterDataOldValue: !0, attributes: !0, attributeOldValue: !0, subtree: !0 }, Lc = le && Ue <= 11; class Bc { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } set(e) { this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset } clear() { this.anchorNode = this.focusNode = null } eq(e) { return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset } } class zc { constructor(e, t) { this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Bc, this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver(n => { for (let i = 0; i < n.length; i++)this.queue.push(n[i]); le && Ue <= 11 && n.some(i => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush() }), Lc && (this.onCharData = n => { this.queue.push({ target: n.target, type: "characterData", oldValue: n.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this) } flushSoon() { this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1, this.flush() }, 20)) } forceFlush() { this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush()) } start() { this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Pc)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection() } stop() { if (this.observer) { let e = this.observer.takeRecords(); if (e.length) { for (let t = 0; t < e.length; t++)this.queue.push(e[t]); window.setTimeout(() => this.flush(), 20) } this.observer.disconnect() } this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection() } connectSelection() { this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange) } disconnectSelection() { this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange) } suppressSelectionUpdates() { this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50) } onSelectionChange() { if (hs(this.view)) { if (this.suppressingSelectionUpdates) return Ie(this.view); if (le && Ue <= 11 && !this.view.state.selection.empty) { let e = this.view.domSelectionRange(); if (e.focusNode && ft(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)) return this.flushSoon() } this.flush() } } setCurSelection() { this.currentSelection.set(this.view.domSelectionRange()) } ignoreSelectionChange(e) { if (!e.focusNode) return !0; let t = new Set, n; for (let s = e.focusNode; s; s = At(s))t.add(s); for (let s = e.anchorNode; s; s = At(s))if (t.has(s)) { n = s; break } let i = n && this.view.docView.nearestDesc(n); if (i && i.ignoreMutation({ type: "selection", target: n.nodeType == 3 ? n.parentNode : n })) return this.setCurSelection(), !0 } pendingRecords() { if (this.observer) for (let e of this.observer.takeRecords()) this.queue.push(e); return this.queue } flush() { let { view: e } = this; if (!e.docView || this.flushingSoon > -1) return; let t = this.pendingRecords(); t.length && (this.queue = []); let n = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(n) && hs(e) && !this.ignoreSelectionChange(n), s = -1, u = -1, o = !1, l = []; if (e.editable) for (let c = 0; c < t.length; c++) { let d = this.registerMutation(t[c], l); d && (s = s < 0 ? d.from : Math.min(d.from, s), u = u < 0 ? d.to : Math.max(d.to, u), d.typeOver && (o = !0)) } if (ke && l.length) { let c = l.filter(d => d.nodeName == "BR"); if (c.length == 2) { let [d, f] = c; d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove() } else { let { focusNode: d } = this.currentSelection; for (let f of c) { let h = f.parentNode; h && h.nodeName == "LI" && (!d || Fc(e, d) != h) && f.remove() } } } let a = null; s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Wn(n) && (a = ri(e)) && a.eq(M.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Ie(e), this.currentSelection.set(n), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, u), $c(e)), this.handleDOMChange(s, u, o, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(n) || Ie(e), this.currentSelection.set(n)) } registerMutation(e, t) { if (t.indexOf(e.target) > -1) return null; let n = this.view.docView.nearestDesc(e.target); if (e.type == "attributes" && (n == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !n || n.ignoreMutation(e)) return null; if (e.type == "childList") { for (let c = 0; c < e.addedNodes.length; c++) { let d = e.addedNodes[c]; t.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d) } if (n.contentDOM && n.contentDOM != n.dom && !n.contentDOM.contains(e.target)) return { from: n.posBefore, to: n.posAfter }; let i = e.previousSibling, s = e.nextSibling; if (le && Ue <= 11 && e.addedNodes.length) for (let c = 0; c < e.addedNodes.length; c++) { let { previousSibling: d, nextSibling: f } = e.addedNodes[c]; (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (i = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (s = f) } let u = i && i.parentNode == e.target ? Z(i) + 1 : 0, o = n.localPosFromDOM(e.target, u, -1), l = s && s.parentNode == e.target ? Z(s) : e.target.childNodes.length, a = n.localPosFromDOM(e.target, l, 1); return { from: o, to: a } } else return e.type == "attributes" ? { from: n.posAtStart - n.border, to: n.posAtEnd + n.border } : (this.lastChangedTextNode = e.target, { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue }) } } let Ss = new WeakMap, Cs = !1; function $c(r) { if (!Ss.has(r) && (Ss.set(r, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(r.dom).whiteSpace) !== -1)) { if (r.requiresGeckoHackNode = ke, Cs) return; console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Cs = !0 } } function Ts(r, e) { let t = e.startContainer, n = e.startOffset, i = e.endContainer, s = e.endOffset, u = r.domAtPos(r.state.selection.anchor); return ft(u.node, u.offset, i, s) && ([t, n, i, s] = [i, s, t, n]), { anchorNode: t, anchorOffset: n, focusNode: i, focusOffset: s } } function _c(r, e) { if (e.getComposedRanges) { let i = e.getComposedRanges(r.root)[0]; if (i) return Ts(r, i) } let t; function n(i) { i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0] } return r.dom.addEventListener("beforeinput", n, !0), document.execCommand("indent"), r.dom.removeEventListener("beforeinput", n, !0), t ? Ts(r, t) : null } function Fc(r, e) { for (let t = e.parentNode; t && t != r.dom; t = t.parentNode) { let n = r.docView.nearestDesc(t, !0); if (n && n.node.isBlock) return t } return null } function Vc(r, e, t) { let { node: n, fromOffset: i, toOffset: s, from: u, to: o } = r.docView.parseRange(e, t), l = r.domSelectionRange(), a, c = l.anchorNode; if (c && r.dom.contains(c.nodeType == 1 ? c : c.parentNode) && (a = [{ node: c, offset: l.anchorOffset }], Wn(l) || a.push({ node: l.focusNode, offset: l.focusOffset })), ee && r.input.lastKeyCode === 8) for (let g = s; g > i; g--) { let b = n.childNodes[g - 1], w = b.pmViewDesc; if (b.nodeName == "BR" && !w) { s = g; break } if (!w || w.size) break } let d = r.state.doc, f = r.someProp("domParser") || We.fromSchema(r.state.schema), h = d.resolve(u), p = null, m = f.parse(n, { topNode: h.parent, topMatch: h.parent.contentMatchAt(h.index()), topOpen: !0, from: i, to: s, preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0, findPositions: a, ruleFromNode: qc, context: h }); if (a && a[0].pos != null) { let g = a[0].pos, b = a[1] && a[1].pos; b == null && (b = g), p = { anchor: g + u, head: b + u } } return { doc: m, sel: p, from: u, to: o } } function qc(r) { let e = r.pmViewDesc; if (e) return e.parseRule(); if (r.nodeName == "BR" && r.parentNode) { if (re && /^(ul|ol)$/i.test(r.parentNode.nodeName)) { let t = document.createElement("div"); return t.appendChild(document.createElement("li")), { skip: t } } else if (r.parentNode.lastChild == r || re && /^(tr|table)$/i.test(r.parentNode.nodeName)) return { ignore: !0 } } else if (r.nodeName == "IMG" && r.getAttribute("mark-placeholder")) return { ignore: !0 }; return null } const Hc = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i; function jc(r, e, t, n, i) { let s = r.input.compositionPendingChanges || (r.composing ? r.input.compositionID : 0); if (r.input.compositionPendingChanges = 0, e < 0) { let E = r.input.lastSelectionTime > Date.now() - 50 ? r.input.lastSelectionOrigin : null, $ = ri(r, E); if ($ && !r.state.selection.eq($)) { if (ee && De && r.input.lastKeyCode === 13 && Date.now() - 100 < r.input.lastKeyCodeTime && r.someProp("handleKeyDown", gl => gl(r, et(13, "Enter")))) return; let oe = r.state.tr.setSelection($); E == "pointer" ? oe.setMeta("pointer", !0) : E == "key" && oe.scrollIntoView(), s && oe.setMeta("composition", s), r.dispatch(oe) } return } let u = r.state.doc.resolve(e), o = u.sharedDepth(t); e = u.before(o + 1), t = r.state.doc.resolve(t).after(o + 1); let l = r.state.selection, a = Vc(r, e, t), c = r.state.doc, d = c.slice(a.from, a.to), f, h; r.input.lastKeyCode === 8 && Date.now() - 100 < r.input.lastKeyCodeTime ? (f = r.state.selection.to, h = "end") : (f = r.state.selection.from, h = "start"), r.input.lastKeyCode = null; let p = Jc(d.content, a.doc.content, a.from, f, h); if (p && r.input.domChangeCount++, (Ot && r.input.lastIOSEnter > Date.now() - 225 || De) && i.some(E => E.nodeType == 1 && !Hc.test(E.nodeName)) && (!p || p.endA >= p.endB) && r.someProp("handleKeyDown", E => E(r, et(13, "Enter")))) { r.input.lastIOSEnter = 0; return } if (!p) if (n && l instanceof T && !l.empty && l.$head.sameParent(l.$anchor) && !r.composing && !(a.sel && a.sel.anchor != a.sel.head)) p = { start: l.from, endA: l.to, endB: l.to }; else { if (a.sel) { let E = Es(r, r.state.doc, a.sel); if (E && !E.eq(r.state.selection)) { let $ = r.state.tr.setSelection(E); s && $.setMeta("composition", s), r.dispatch($) } } return } r.state.selection.from < r.state.selection.to && p.start == p.endB && r.state.selection instanceof T && (p.start > r.state.selection.from && p.start <= r.state.selection.from + 2 && r.state.selection.from >= a.from ? p.start = r.state.selection.from : p.endA < r.state.selection.to && p.endA >= r.state.selection.to - 2 && r.state.selection.to <= a.to && (p.endB += r.state.selection.to - p.endA, p.endA = r.state.selection.to)), le && Ue <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > a.from && a.doc.textBetween(p.start - a.from - 1, p.start - a.from + 1) == " " && (p.start--, p.endA--, p.endB--); let m = a.doc.resolveNoCache(p.start - a.from), g = a.doc.resolveNoCache(p.endB - a.from), b = c.resolve(p.start), w = m.sameParent(g) && m.parent.inlineContent && b.end() >= p.endA, C; if ((Ot && r.input.lastIOSEnter > Date.now() - 225 && (!w || i.some(E => E.nodeName == "DIV" || E.nodeName == "P")) || !w && m.pos < a.doc.content.size && (!m.sameParent(g) || !m.parent.inlineContent) && !/\S/.test(a.doc.textBetween(m.pos, g.pos, "", "")) && (C = M.findFrom(a.doc.resolve(m.pos + 1), 1, !0)) && C.head > m.pos) && r.someProp("handleKeyDown", E => E(r, et(13, "Enter")))) { r.input.lastIOSEnter = 0; return } if (r.state.selection.anchor > p.start && Uc(c, p.start, p.endA, m, g) && r.someProp("handleKeyDown", E => E(r, et(8, "Backspace")))) { De && ee && r.domObserver.suppressSelectionUpdates(); return } ee && p.endB == p.start && (r.input.lastChromeDelete = Date.now()), De && !w && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && a.sel && a.sel.anchor == a.sel.head && a.sel.head == p.endA && (p.endB -= 2, g = a.doc.resolveNoCache(p.endB - a.from), setTimeout(() => { r.someProp("handleKeyDown", function (E) { return E(r, et(13, "Enter")) }) }, 20)); let O = p.start, A = p.endA, I = E => { let $ = E || r.state.tr.replace(O, A, a.doc.slice(p.start - a.from, p.endB - a.from)); if (a.sel) { let oe = Es(r, $.doc, a.sel); oe && !(ee && r.composing && oe.empty && (p.start != p.endB || r.input.lastChromeDelete < Date.now() - 100) && (oe.head == O || oe.head == $.mapping.map(A) - 1) || le && oe.empty && oe.head == O) && $.setSelection(oe) } return s && $.setMeta("composition", s), $.scrollIntoView() }, ne; if (w) { if (m.pos == g.pos) { le && Ue <= 11 && m.parentOffset == 0 && (r.domObserver.suppressSelectionUpdates(), setTimeout(() => Ie(r), 20)); let E = I(r.state.tr.delete(O, A)), $ = c.resolve(p.start).marksAcross(c.resolve(p.endA)); $ && E.ensureMarks($), r.dispatch(E) } else if (p.endA == p.endB && (ne = Wc(m.parent.content.cut(m.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, p.endA - b.start())))) { let E = I(r.state.tr); ne.type == "add" ? E.addMark(O, A, ne.mark) : E.removeMark(O, A, ne.mark), r.dispatch(E) } else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) { let E = m.parent.textBetween(m.parentOffset, g.parentOffset), $ = () => I(r.state.tr.insertText(E, O, A)); r.someProp("handleTextInput", oe => oe(r, O, A, E, $)) || r.dispatch($()) } } else r.dispatch(I()) } function Es(r, e, t) { return Math.max(t.anchor, t.head) > e.content.size ? null : ii(r, e.resolve(t.anchor), e.resolve(t.head)) } function Wc(r, e) { let t = r.firstChild.marks, n = e.firstChild.marks, i = t, s = n, u, o, l; for (let c = 0; c < n.length; c++)i = n[c].removeFromSet(i); for (let c = 0; c < t.length; c++)s = t[c].removeFromSet(s); if (i.length == 1 && s.length == 0) o = i[0], u = "add", l = c => c.mark(o.addToSet(c.marks)); else if (i.length == 0 && s.length == 1) o = s[0], u = "remove", l = c => c.mark(o.removeFromSet(c.marks)); else return null; let a = []; for (let c = 0; c < e.childCount; c++)a.push(l(e.child(c))); if (y.from(a).eq(r)) return { mark: o, type: u } } function Uc(r, e, t, n, i) { if (t - e <= i.pos - n.pos || mr(n, !0, !1) < i.pos) return !1; let s = r.resolve(e); if (!n.parent.isTextblock) { let o = s.nodeAfter; return o != null && t == e + o.nodeSize } if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock) return !1; let u = r.resolve(mr(s, !0, !0)); return !u.parent.isTextblock || u.pos > t || mr(u, !0, !1) < t ? !1 : n.parent.content.cut(n.parentOffset).eq(u.parent.content) } function mr(r, e, t) { let n = r.depth, i = e ? r.end() : r.pos; for (; n > 0 && (e || r.indexAfter(n) == r.node(n).childCount);)n--, i++, e = !1; if (t) { let s = r.node(n).maybeChild(r.indexAfter(n)); for (; s && !s.isLeaf;)s = s.firstChild, i++ } return i } function Jc(r, e, t, n, i) { let s = r.findDiffStart(e, t); if (s == null) return null; let { a: u, b: o } = r.findDiffEnd(e, t + r.size, t + e.size); if (i == "end") { let l = Math.max(0, s - Math.min(u, o)); n -= u + l - s } if (u < s && r.size < e.size) { let l = n <= s && n >= u ? s - n : 0; s -= l, s && s < e.size && Ms(e.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), o = s + (o - u), u = s } else if (o < s) { let l = n <= s && n >= o ? s - n : 0; s -= l, s && s < r.size && Ms(r.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), u = s + (u - o), o = s } return { start: s, endA: u, endB: o } } function Ms(r) { if (r.length != 2) return !1; let e = r.charCodeAt(0), t = r.charCodeAt(1); return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319 } class xo { constructor(e, t) { this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new fc, this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(Ds), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = Os(this), As(this), this.nodeViews = vs(this), this.docView = us(this.state.doc, Ns(this), pr(this), this.dom, this), this.domObserver = new zc(this, (n, i, s, u) => jc(this, n, i, s, u)), this.domObserver.start(), hc(this), this.updatePluginViews() } get composing() { return this.input.composing } get props() { if (this._props.state != this.state) { let e = this._props; this._props = {}; for (let t in e) this._props[t] = e[t]; this._props.state = this.state } return this._props } update(e) { e.handleDOMEvents != this._props.handleDOMEvents && qr(this); let t = this._props; this._props = e, e.plugins && (e.plugins.forEach(Ds), this.directPlugins = e.plugins), this.updateStateInner(e.state, t) } setProps(e) { let t = {}; for (let n in this._props) t[n] = this._props[n]; t.state = this.state; for (let n in e) t[n] = e[n]; this.update(t) } updateState(e) { this.updateStateInner(e, this._props) } updateStateInner(e, t) { var n; let i = this.state, s = !1, u = !1; e.storedMarks && this.composing && (fo(this), u = !0), this.state = e; let o = i.plugins != e.plugins || this._props.plugins != t.plugins; if (o || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) { let h = vs(this); Gc(h, this.nodeViews) && (this.nodeViews = h, s = !0) } (o || t.handleDOMEvents != this._props.handleDOMEvents) && qr(this), this.editable = Os(this), As(this); let l = pr(this), a = Ns(this), c = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", d = s || !this.docView.matchesNode(e.doc, a, l); (d || !e.selection.eq(i.selection)) && (u = !0); let f = c == "preserve" && u && this.dom.style.overflowAnchor == null && Na(this); if (u) { this.domObserver.stop(); let h = d && (le || ee) && !this.composing && !i.selection.empty && !e.selection.empty && Kc(i.selection, e.selection); if (d) { let p = ee ? this.trackWrites = this.domSelectionRange().focusNode : null; this.composing && (this.input.compositionNode = Mc(this)), (s || !this.docView.update(e.doc, a, l, this)) && (this.docView.updateOuterDeco(a), this.docView.destroy(), this.docView = us(e.doc, a, l, this.dom, this)), p && !this.trackWrites && (h = !0) } h || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Qa(this)) ? Ie(this, h) : (Xu(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start() } this.updatePluginViews(i), !((n = this.dragging) === null || n === void 0) && n.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), c == "reset" ? this.dom.scrollTop = 0 : c == "to selection" ? this.scrollToSelection() : f && Aa(f) } scrollToSelection() { let e = this.domSelectionRange().focusNode; if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) { if (!this.someProp("handleScrollToSelection", t => t(this))) if (this.state.selection instanceof S) { let t = this.docView.domAfterPos(this.state.selection.from); t.nodeType == 1 && es(this, t.getBoundingClientRect(), e) } else es(this, this.coordsAtPos(this.state.selection.head, 1), e) } } destroyPluginViews() { let e; for (; e = this.pluginViews.pop();)e.destroy && e.destroy() } updatePluginViews(e) { if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) { this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews(); for (let t = 0; t < this.directPlugins.length; t++) { let n = this.directPlugins[t]; n.spec.view && this.pluginViews.push(n.spec.view(this)) } for (let t = 0; t < this.state.plugins.length; t++) { let n = this.state.plugins[t]; n.spec.view && this.pluginViews.push(n.spec.view(this)) } } else for (let t = 0; t < this.pluginViews.length; t++) { let n = this.pluginViews[t]; n.update && n.update(this, e) } } updateDraggedNode(e, t) { let n = e.node, i = -1; if (this.state.doc.nodeAt(n.from) == n.node) i = n.from; else { let s = n.from + (this.state.doc.content.size - t.doc.content.size); (s > 0 && this.state.doc.nodeAt(s)) == n.node && (i = s) } this.dragging = new po(e.slice, e.move, i < 0 ? void 0 : S.create(this.state.doc, i)) } someProp(e, t) { let n = this._props && this._props[e], i; if (n != null && (i = t ? t(n) : n)) return i; for (let u = 0; u < this.directPlugins.length; u++) { let o = this.directPlugins[u].props[e]; if (o != null && (i = t ? t(o) : o)) return i } let s = this.state.plugins; if (s) for (let u = 0; u < s.length; u++) { let o = s[u].props[e]; if (o != null && (i = t ? t(o) : o)) return i } } hasFocus() { if (le) { let e = this.root.activeElement; if (e == this.dom) return !0; if (!e || !this.dom.contains(e)) return !1; for (; e && this.dom != e && this.dom.contains(e);) { if (e.contentEditable == "false") return !1; e = e.parentElement } return !0 } return this.root.activeElement == this.dom } focus() { this.domObserver.stop(), this.editable && Oa(this.dom), Ie(this), this.domObserver.start() } get root() { let e = this._root; if (e == null) { for (let t = this.dom.parentNode; t; t = t.parentNode)if (t.nodeType == 9 || t.nodeType == 11 && t.host) return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t } return e || document } updateRoot() { this._root = null } posAtCoords(e) { return Pa(this, e) } coordsAtPos(e, t = 1) { return Wu(this, e, t) } domAtPos(e, t = 0) { return this.docView.domFromPos(e, t) } nodeDOM(e) { let t = this.docView.descAt(e); return t ? t.nodeDOM : null } posAtDOM(e, t, n = -1) { let i = this.docView.posFromDOM(e, t, n); if (i == null) throw new RangeError("DOM position not inside the editor"); return i } endOfTextblock(e, t) { return _a(this, t || this.state, e) } pasteHTML(e, t) { return Qt(this, "", e, !1, t || new ClipboardEvent("paste")) } pasteText(e, t) { return Qt(this, e, null, !0, t || new ClipboardEvent("paste")) } serializeForClipboard(e) { return si(this, e) } destroy() { this.docView && (pc(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], pr(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, ga()) } get isDestroyed() { return this.docView == null } dispatchEvent(e) { return gc(this, e) } domSelectionRange() { let e = this.domSelection(); return e ? re && this.root.nodeType === 11 && wa(this.dom.ownerDocument) == this.dom && _c(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 } } domSelection() { return this.root.getSelection() } } xo.prototype.dispatch = function (r) { let e = this._props.dispatchTransaction; e ? e.call(this, r) : this.updateState(this.state.apply(r)) }; function Ns(r) { let e = Object.create(null); return e.class = "ProseMirror", e.contenteditable = String(r.editable), r.someProp("attributes", t => { if (typeof t == "function" && (t = t(r.state)), t) for (let n in t) n == "class" ? e.class += " " + t[n] : n == "style" ? e.style = (e.style ? e.style + ";" : "") + t[n] : !e[n] && n != "contenteditable" && n != "nodeName" && (e[n] = String(t[n])) }), e.translate || (e.translate = "no"), [fe.node(0, r.state.doc.content.size, e)] } function As(r) { if (r.markCursor) { let e = document.createElement("img"); e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), r.cursorWrapper = { dom: e, deco: fe.widget(r.state.selection.from, e, { raw: !0, marks: r.markCursor }) } } else r.cursorWrapper = null } function Os(r) { return !r.someProp("editable", e => e(r.state) === !1) } function Kc(r, e) { let t = Math.min(r.$anchor.sharedDepth(r.head), e.$anchor.sharedDepth(e.head)); return r.$anchor.start(t) != e.$anchor.start(t) } function vs(r) { let e = Object.create(null); function t(n) { for (let i in n) Object.prototype.hasOwnProperty.call(e, i) || (e[i] = n[i]) } return r.someProp("nodeViews", t), r.someProp("markViews", t), e } function Gc(r, e) { let t = 0, n = 0; for (let i in r) { if (r[i] != e[i]) return !0; t++ } for (let i in e) n++; return t != n } function Ds(r) { if (r.spec.state || r.spec.filterTransaction || r.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component") } var Ge = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, Pn = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, Zc = typeof navigator < "u" && /Mac/.test(navigator.platform), Qc = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent); for (var Q = 0; Q < 10; Q++)Ge[48 + Q] = Ge[96 + Q] = String(Q); for (var Q = 1; Q <= 24; Q++)Ge[Q + 111] = "F" + Q; for (var Q = 65; Q <= 90; Q++)Ge[Q] = String.fromCharCode(Q + 32), Pn[Q] = String.fromCharCode(Q); for (var gr in Ge) Pn.hasOwnProperty(gr) || (Pn[gr] = Ge[gr]); function Yc(r) { var e = Zc && r.metaKey && r.shiftKey && !r.ctrlKey && !r.altKey || Qc && r.shiftKey && r.key && r.key.length == 1 || r.key == "Unidentified", t = !e && r.key || (r.shiftKey ? Pn : Ge)[r.keyCode] || r.key || "Unidentified"; return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t } const Xc = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), ed = typeof navigator < "u" && /Win/.test(navigator.platform); function td(r) { let e = r.split(/-(?!$)/), t = e[e.length - 1]; t == "Space" && (t = " "); let n, i, s, u; for (let o = 0; o < e.length - 1; o++) { let l = e[o]; if (/^(cmd|meta|m)$/i.test(l)) u = !0; else if (/^a(lt)?$/i.test(l)) n = !0; else if (/^(c|ctrl|control)$/i.test(l)) i = !0; else if (/^s(hift)?$/i.test(l)) s = !0; else if (/^mod$/i.test(l)) Xc ? u = !0 : i = !0; else throw new Error("Unrecognized modifier name: " + l) } return n && (t = "Alt-" + t), i && (t = "Ctrl-" + t), u && (t = "Meta-" + t), s && (t = "Shift-" + t), t } function nd(r) { let e = Object.create(null); for (let t in r) e[td(t)] = r[t]; return e } function br(r, e, t = !0) { return e.altKey && (r = "Alt-" + r), e.ctrlKey && (r = "Ctrl-" + r), e.metaKey && (r = "Meta-" + r), t && e.shiftKey && (r = "Shift-" + r), r } function rd(r) { return new ue({ props: { handleKeyDown: ko(r) } }) } function ko(r) { let e = nd(r); return function (t, n) { let i = Yc(n), s, u = e[br(i, n)]; if (u && u(t.state, t.dispatch, t)) return !0; if (i.length == 1 && i != " ") { if (n.shiftKey) { let o = e[br(i, n, !1)]; if (o && o(t.state, t.dispatch, t)) return !0 } if ((n.altKey || n.metaKey || n.ctrlKey) && !(ed && n.ctrlKey && n.altKey) && (s = Ge[n.keyCode]) && s != i) { let o = e[br(s, n)]; if (o && o(t.state, t.dispatch, t)) return !0 } } return !1 } } const di = (r, e) => r.selection.empty ? !1 : (e && e(r.tr.deleteSelection().scrollIntoView()), !0); function wo(r, e) { let { $cursor: t } = r.selection; return !t || (e ? !e.endOfTextblock("backward", r) : t.parentOffset > 0) ? null : t } const So = (r, e, t) => { let n = wo(r, t); if (!n) return !1; let i = fi(n); if (!i) { let u = n.blockRange(), o = u && It(u); return o == null ? !1 : (e && e(r.tr.lift(u, o).scrollIntoView()), !0) } let s = i.nodeBefore; if (Do(r, i, e, -1)) return !0; if (n.parent.content.size == 0 && (vt(s, "end") || S.isSelectable(s))) for (let u = n.depth; ; u--) { let o = Hn(r.doc, n.before(u), n.after(u), x.empty); if (o && o.slice.size < o.to - o.from) { if (e) { let l = r.tr.step(o); l.setSelection(vt(s, "end") ? M.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : S.create(l.doc, i.pos - s.nodeSize)), e(l.scrollIntoView()) } return !0 } if (u == 1 || n.node(u - 1).childCount > 1) break } return s.isAtom && i.depth == n.depth - 1 ? (e && e(r.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1 }, id = (r, e, t) => { let n = wo(r, t); if (!n) return !1; let i = fi(n); return i ? Co(r, i, e) : !1 }, sd = (r, e, t) => { let n = Eo(r, t); if (!n) return !1; let i = hi(n); return i ? Co(r, i, e) : !1 }; function Co(r, e, t) { let n = e.nodeBefore, i = n, s = e.pos - 1; for (; !i.isTextblock; s--) { if (i.type.spec.isolating) return !1; let c = i.lastChild; if (!c) return !1; i = c } let u = e.nodeAfter, o = u, l = e.pos + 1; for (; !o.isTextblock; l++) { if (o.type.spec.isolating) return !1; let c = o.firstChild; if (!c) return !1; o = c } let a = Hn(r.doc, s, l, x.empty); if (!a || a.from != s || a instanceof q && a.slice.size >= l - s) return !1; if (t) { let c = r.tr.step(a); c.setSelection(T.create(c.doc, s)), t(c.scrollIntoView()) } return !0 } function vt(r, e, t = !1) { for (let n = r; n; n = e == "start" ? n.firstChild : n.lastChild) { if (n.isTextblock) return !0; if (t && n.childCount != 1) return !1 } return !1 } const To = (r, e, t) => { let { $head: n, empty: i } = r.selection, s = n; if (!i) return !1; if (n.parent.isTextblock) { if (t ? !t.endOfTextblock("backward", r) : n.parentOffset > 0) return !1; s = fi(n) } let u = s && s.nodeBefore; return !u || !S.isSelectable(u) ? !1 : (e && e(r.tr.setSelection(S.create(r.doc, s.pos - u.nodeSize)).scrollIntoView()), !0) }; function fi(r) { if (!r.parent.type.spec.isolating) for (let e = r.depth - 1; e >= 0; e--) { if (r.index(e) > 0) return r.doc.resolve(r.before(e + 1)); if (r.node(e).type.spec.isolating) break } return null } function Eo(r, e) { let { $cursor: t } = r.selection; return !t || (e ? !e.endOfTextblock("forward", r) : t.parentOffset < t.parent.content.size) ? null : t } const Mo = (r, e, t) => { let n = Eo(r, t); if (!n) return !1; let i = hi(n); if (!i) return !1; let s = i.nodeAfter; if (Do(r, i, e, 1)) return !0; if (n.parent.content.size == 0 && (vt(s, "start") || S.isSelectable(s))) { let u = Hn(r.doc, n.before(), n.after(), x.empty); if (u && u.slice.size < u.to - u.from) { if (e) { let o = r.tr.step(u); o.setSelection(vt(s, "start") ? M.findFrom(o.doc.resolve(o.mapping.map(i.pos)), 1) : S.create(o.doc, o.mapping.map(i.pos))), e(o.scrollIntoView()) } return !0 } } return s.isAtom && i.depth == n.depth - 1 ? (e && e(r.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1 }, No = (r, e, t) => { let { $head: n, empty: i } = r.selection, s = n; if (!i) return !1; if (n.parent.isTextblock) { if (t ? !t.endOfTextblock("forward", r) : n.parentOffset < n.parent.content.size) return !1; s = hi(n) } let u = s && s.nodeAfter; return !u || !S.isSelectable(u) ? !1 : (e && e(r.tr.setSelection(S.create(r.doc, s.pos)).scrollIntoView()), !0) }; function hi(r) { if (!r.parent.type.spec.isolating) for (let e = r.depth - 1; e >= 0; e--) { let t = r.node(e); if (r.index(e) + 1 < t.childCount) return r.doc.resolve(r.after(e + 1)); if (t.type.spec.isolating) break } return null } const ud = (r, e) => { let t = r.selection, n = t instanceof S, i; if (n) { if (t.node.isTextblock || !Qe(r.doc, t.from)) return !1; i = t.from } else if (i = qn(r.doc, t.from, -1), i == null) return !1; if (e) { let s = r.tr.join(i); n && s.setSelection(S.create(s.doc, i - r.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView()) } return !0 }, od = (r, e) => { let t = r.selection, n; if (t instanceof S) { if (t.node.isTextblock || !Qe(r.doc, t.to)) return !1; n = t.to } else if (n = qn(r.doc, t.to, 1), n == null) return !1; return e && e(r.tr.join(n).scrollIntoView()), !0 }, ld = (r, e) => { let { $from: t, $to: n } = r.selection, i = t.blockRange(n), s = i && It(i); return s == null ? !1 : (e && e(r.tr.lift(i, s).scrollIntoView()), !0) }, Ao = (r, e) => {
    let { $head: t, $anchor: n } = r.selection; return !t.parent.type.spec.code || !t.sameParent(n) ? !1 : (e && e(r.tr.insertText(`
`).scrollIntoView()), !0)
}; function pi(r) { for (let e = 0; e < r.edgeCount; e++) { let { type: t } = r.edge(e); if (t.isTextblock && !t.hasRequiredAttrs()) return t } return null } const ad = (r, e) => { let { $head: t, $anchor: n } = r.selection; if (!t.parent.type.spec.code || !t.sameParent(n)) return !1; let i = t.node(-1), s = t.indexAfter(-1), u = pi(i.contentMatchAt(s)); if (!u || !i.canReplaceWith(s, s, u)) return !1; if (e) { let o = t.after(), l = r.tr.replaceWith(o, o, u.createAndFill()); l.setSelection(M.near(l.doc.resolve(o), 1)), e(l.scrollIntoView()) } return !0 }, Oo = (r, e) => { let t = r.selection, { $from: n, $to: i } = t; if (t instanceof he || n.parent.inlineContent || i.parent.inlineContent) return !1; let s = pi(i.parent.contentMatchAt(i.indexAfter())); if (!s || !s.isTextblock) return !1; if (e) { let u = (!n.parentOffset && i.index() < i.parent.childCount ? n : i).pos, o = r.tr.insert(u, s.createAndFill()); o.setSelection(T.create(o.doc, u + 1)), e(o.scrollIntoView()) } return !0 }, vo = (r, e) => { let { $cursor: t } = r.selection; if (!t || t.parent.content.size) return !1; if (t.depth > 1 && t.after() != t.end(-1)) { let s = t.before(); if (Re(r.doc, s)) return e && e(r.tr.split(s).scrollIntoView()), !0 } let n = t.blockRange(), i = n && It(n); return i == null ? !1 : (e && e(r.tr.lift(n, i).scrollIntoView()), !0) }; function cd(r) { return (e, t) => { let { $from: n, $to: i } = e.selection; if (e.selection instanceof S && e.selection.node.isBlock) return !n.parentOffset || !Re(e.doc, n.pos) ? !1 : (t && t(e.tr.split(n.pos).scrollIntoView()), !0); if (!n.depth) return !1; let s = [], u, o, l = !1, a = !1; for (let h = n.depth; ; h--)if (n.node(h).isBlock) { l = n.end(h) == n.pos + (n.depth - h), a = n.start(h) == n.pos - (n.depth - h), o = pi(n.node(h - 1).contentMatchAt(n.indexAfter(h - 1))), s.unshift(l && o ? { type: o } : null), u = h; break } else { if (h == 1) return !1; s.unshift(null) } let c = e.tr; (e.selection instanceof T || e.selection instanceof he) && c.deleteSelection(); let d = c.mapping.map(n.pos), f = Re(c.doc, d, s.length, s); if (f || (s[0] = o ? { type: o } : null, f = Re(c.doc, d, s.length, s)), !f) return !1; if (c.split(d, s.length, s), !l && a && n.node(u).type != o) { let h = c.mapping.map(n.before(u)), p = c.doc.resolve(h); o && n.node(u - 1).canReplaceWith(p.index(), p.index() + 1, o) && c.setNodeMarkup(c.mapping.map(n.before(u)), o) } return t && t(c.scrollIntoView()), !0 } } const dd = cd(), fd = (r, e) => { let { $from: t, to: n } = r.selection, i, s = t.sharedDepth(n); return s == 0 ? !1 : (i = t.before(s), e && e(r.tr.setSelection(S.create(r.doc, i))), !0) }; function hd(r, e, t) { let n = e.nodeBefore, i = e.nodeAfter, s = e.index(); return !n || !i || !n.type.compatibleContent(i.type) ? !1 : !n.content.size && e.parent.canReplace(s - 1, s) ? (t && t(r.tr.delete(e.pos - n.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || Qe(r.doc, e.pos)) ? !1 : (t && t(r.tr.join(e.pos).scrollIntoView()), !0) } function Do(r, e, t, n) { let i = e.nodeBefore, s = e.nodeAfter, u, o, l = i.type.spec.isolating || s.type.spec.isolating; if (!l && hd(r, e, t)) return !0; let a = !l && e.parent.canReplace(e.index(), e.index() + 1); if (a && (u = (o = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && o.matchType(u[0] || s.type).validEnd) { if (t) { let h = e.pos + s.nodeSize, p = y.empty; for (let b = u.length - 1; b >= 0; b--)p = y.from(u[b].create(null, p)); p = y.from(i.copy(p)); let m = r.tr.step(new j(e.pos - 1, h, e.pos, h, new x(p, 1, 0), u.length, !0)), g = m.doc.resolve(h + 2 * u.length); g.nodeAfter && g.nodeAfter.type == i.type && Qe(m.doc, g.pos) && m.join(g.pos), t(m.scrollIntoView()) } return !0 } let c = s.type.spec.isolating || n > 0 && l ? null : M.findFrom(e, 1), d = c && c.$from.blockRange(c.$to), f = d && It(d); if (f != null && f >= e.depth) return t && t(r.tr.lift(d, f).scrollIntoView()), !0; if (a && vt(s, "start", !0) && vt(i, "end")) { let h = i, p = []; for (; p.push(h), !h.isTextblock;)h = h.lastChild; let m = s, g = 1; for (; !m.isTextblock; m = m.firstChild)g++; if (h.canReplace(h.childCount, h.childCount, m.content)) { if (t) { let b = y.empty; for (let C = p.length - 1; C >= 0; C--)b = y.from(p[C].copy(b)); let w = r.tr.step(new j(e.pos - p.length, e.pos + s.nodeSize, e.pos + g, e.pos + s.nodeSize - g, new x(b, p.length, 0), 0, !0)); t(w.scrollIntoView()) } return !0 } } return !1 } function Ro(r) { return function (e, t) { let n = e.selection, i = r < 0 ? n.$from : n.$to, s = i.depth; for (; i.node(s).isInline;) { if (!s) return !1; s-- } return i.node(s).isTextblock ? (t && t(e.tr.setSelection(T.create(e.doc, r < 0 ? i.start(s) : i.end(s)))), !0) : !1 } } const pd = Ro(-1), md = Ro(1); function gd(r, e = null) { return function (t, n) { let { $from: i, $to: s } = t.selection, u = i.blockRange(s), o = u && ei(u, r, e); return o ? (n && n(t.tr.wrap(u, o).scrollIntoView()), !0) : !1 } } function Rs(r, e = null) { return function (t, n) { let i = !1; for (let s = 0; s < t.selection.ranges.length && !i; s++) { let { $from: { pos: u }, $to: { pos: o } } = t.selection.ranges[s]; t.doc.nodesBetween(u, o, (l, a) => { if (i) return !1; if (!(!l.isTextblock || l.hasMarkup(r, e))) if (l.type == r) i = !0; else { let c = t.doc.resolve(a), d = c.index(); i = c.parent.canReplaceWith(d, d + 1, r) } }) } if (!i) return !1; if (n) { let s = t.tr; for (let u = 0; u < t.selection.ranges.length; u++) { let { $from: { pos: o }, $to: { pos: l } } = t.selection.ranges[u]; s.setBlockType(o, l, r, e) } n(s.scrollIntoView()) } return !0 } } function mi(...r) { return function (e, t, n) { for (let i = 0; i < r.length; i++)if (r[i](e, t, n)) return !0; return !1 } } mi(di, So, To); mi(di, Mo, No); mi(Ao, Oo, vo, dd); typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin"; function bd(r, e = null) { return function (t, n) { let { $from: i, $to: s } = t.selection, u = i.blockRange(s); if (!u) return !1; let o = n ? t.tr : null; return yd(o, u, r, e) ? (n && n(o.scrollIntoView()), !0) : !1 } } function yd(r, e, t, n = null) { let i = !1, s = e, u = e.$from.doc; if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(t) && e.startIndex == 0) { if (e.$from.index(e.depth - 1) == 0) return !1; let l = u.resolve(e.start - 2); s = new Nn(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new Nn(e.$from, u.resolve(e.$to.end(e.depth)), e.depth)), i = !0 } let o = ei(s, t, n, e); return o ? (r && xd(r, e, o, i, t), !0) : !1 } function xd(r, e, t, n, i) { let s = y.empty; for (let c = t.length - 1; c >= 0; c--)s = y.from(t[c].type.create(t[c].attrs, s)); r.step(new j(e.start - (n ? 2 : 0), e.end, e.start, e.end, new x(s, 0, 0), t.length, !0)); let u = 0; for (let c = 0; c < t.length; c++)t[c].type == i && (u = c + 1); let o = t.length - u, l = e.start + t.length - (n ? 2 : 0), a = e.parent; for (let c = e.startIndex, d = e.endIndex, f = !0; c < d; c++, f = !1)!f && Re(r.doc, l, o) && (r.split(l, o), l += 2 * o), l += a.child(c).nodeSize; return r } function kd(r) { return function (e, t) { let { $from: n, $to: i } = e.selection, s = n.blockRange(i, u => u.childCount > 0 && u.firstChild.type == r); return s ? t ? n.node(s.depth - 1).type == r ? wd(e, t, r, s) : Sd(e, t, s) : !0 : !1 } } function wd(r, e, t, n) { let i = r.tr, s = n.end, u = n.$to.end(n.depth); s < u && (i.step(new j(s - 1, u, s, u, new x(y.from(t.create(null, n.parent.copy())), 1, 0), 1, !0)), n = new Nn(i.doc.resolve(n.$from.pos), i.doc.resolve(u), n.depth)); const o = It(n); if (o == null) return !1; i.lift(n, o); let l = i.doc.resolve(i.mapping.map(s, -1) - 1); return Qe(i.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && i.join(l.pos), e(i.scrollIntoView()), !0 } function Sd(r, e, t) { let n = r.tr, i = t.parent; for (let h = t.end, p = t.endIndex - 1, m = t.startIndex; p > m; p--)h -= i.child(p).nodeSize, n.delete(h - 1, h + 1); let s = n.doc.resolve(t.start), u = s.nodeAfter; if (n.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize) return !1; let o = t.startIndex == 0, l = t.endIndex == i.childCount, a = s.node(-1), c = s.index(-1); if (!a.canReplace(c + (o ? 0 : 1), c + 1, u.content.append(l ? y.empty : y.from(i)))) return !1; let d = s.pos, f = d + u.nodeSize; return n.step(new j(d - (o ? 1 : 0), f + (l ? 1 : 0), d + 1, f - 1, new x((o ? y.empty : y.from(i.copy(y.empty))).append(l ? y.empty : y.from(i.copy(y.empty))), o ? 0 : 1, l ? 0 : 1), o ? 0 : 1)), e(n.scrollIntoView()), !0 } function Cd(r) { return function (e, t) { let { $from: n, $to: i } = e.selection, s = n.blockRange(i, a => a.childCount > 0 && a.firstChild.type == r); if (!s) return !1; let u = s.startIndex; if (u == 0) return !1; let o = s.parent, l = o.child(u - 1); if (l.type != r) return !1; if (t) { let a = l.lastChild && l.lastChild.type == o.type, c = y.from(a ? r.create() : null), d = new x(y.from(r.create(null, y.from(o.type.create(null, c)))), a ? 3 : 1, 0), f = s.start, h = s.end; t(e.tr.step(new j(f - (a ? 3 : 1), h, f, h, d, 1, !0)).scrollIntoView()) } return !0 } } function Kn(r) { const { state: e, transaction: t } = r; let { selection: n } = t, { doc: i } = t, { storedMarks: s } = t; return { ...e, apply: e.apply.bind(e), applyTransaction: e.applyTransaction.bind(e), plugins: e.plugins, schema: e.schema, reconfigure: e.reconfigure.bind(e), toJSON: e.toJSON.bind(e), get storedMarks() { return s }, get selection() { return n }, get doc() { return i }, get tr() { return n = t.selection, i = t.doc, s = t.storedMarks, t } } } class Gn { constructor(e) { this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state } get hasCustomState() { return !!this.customState } get state() { return this.customState || this.editor.state } get commands() { const { rawCommands: e, editor: t, state: n } = this, { view: i } = t, { tr: s } = n, u = this.buildProps(s); return Object.fromEntries(Object.entries(e).map(([o, l]) => [o, (...c) => { const d = l(...c)(u); return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), d }])) } get chain() { return () => this.createChain() } get can() { return () => this.createCan() } createChain(e, t = !0) { const { rawCommands: n, editor: i, state: s } = this, { view: u } = i, o = [], l = !!e, a = e || s.tr, c = () => (!l && t && !a.getMeta("preventDispatch") && !this.hasCustomState && u.dispatch(a), o.every(f => f === !0)), d = { ...Object.fromEntries(Object.entries(n).map(([f, h]) => [f, (...m) => { const g = this.buildProps(a, t), b = h(...m)(g); return o.push(b), d }])), run: c }; return d } createCan(e) { const { rawCommands: t, state: n } = this, i = !1, s = e || n.tr, u = this.buildProps(s, i); return { ...Object.fromEntries(Object.entries(t).map(([l, a]) => [l, (...c) => a(...c)({ ...u, dispatch: void 0 })])), chain: () => this.createChain(s, i) } } buildProps(e, t = !0) { const { rawCommands: n, editor: i, state: s } = this, { view: u } = i, o = { tr: e, editor: i, view: u, state: Kn({ state: s, transaction: e }), dispatch: t ? () => { } : void 0, chain: () => this.createChain(e, t), can: () => this.createCan(e), get commands() { return Object.fromEntries(Object.entries(n).map(([l, a]) => [l, (...c) => a(...c)(o)])) } }; return o } } class Td { constructor() { this.callbacks = {} } on(e, t) { return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this } emit(e, ...t) { const n = this.callbacks[e]; return n && n.forEach(i => i.apply(this, t)), this } off(e, t) { const n = this.callbacks[e]; return n && (t ? this.callbacks[e] = n.filter(i => i !== t) : delete this.callbacks[e]), this } once(e, t) { const n = (...i) => { this.off(e, n), t.apply(this, i) }; return this.on(e, n) } removeAllListeners() { this.callbacks = {} } } function k(r, e, t) { return r.config[e] === void 0 && r.parent ? k(r.parent, e, t) : typeof r.config[e] == "function" ? r.config[e].bind({ ...t, parent: r.parent ? k(r.parent, e, t) : null }) : r.config[e] } function Zn(r) { const e = r.filter(i => i.type === "extension"), t = r.filter(i => i.type === "node"), n = r.filter(i => i.type === "mark"); return { baseExtensions: e, nodeExtensions: t, markExtensions: n } } function Io(r) { const e = [], { nodeExtensions: t, markExtensions: n } = Zn(r), i = [...t, ...n], s = { default: null, rendered: !0, renderHTML: null, parseHTML: null, keepOnSplit: !0, isRequired: !1 }; return r.forEach(u => { const o = { name: u.name, options: u.options, storage: u.storage, extensions: i }, l = k(u, "addGlobalAttributes", o); if (!l) return; l().forEach(c => { c.types.forEach(d => { Object.entries(c.attributes).forEach(([f, h]) => { e.push({ type: d, name: f, attribute: { ...s, ...h } }) }) }) }) }), i.forEach(u => { const o = { name: u.name, options: u.options, storage: u.storage }, l = k(u, "addAttributes", o); if (!l) return; const a = l(); Object.entries(a).forEach(([c, d]) => { const f = { ...s, ...d }; typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({ type: u.name, name: c, attribute: f }) }) }), e } function U(r, e) { if (typeof r == "string") { if (!e.nodes[r]) throw Error(`There is no node type named '${r}'. Maybe you forgot to add the extension?`); return e.nodes[r] } return r } function Y(...r) { return r.filter(e => !!e).reduce((e, t) => { const n = { ...e }; return Object.entries(t).forEach(([i, s]) => { if (!n[i]) { n[i] = s; return } if (i === "class") { const o = s ? String(s).split(" ") : [], l = n[i] ? n[i].split(" ") : [], a = o.filter(c => !l.includes(c)); n[i] = [...l, ...a].join(" ") } else if (i === "style") { const o = s ? s.split(";").map(c => c.trim()).filter(Boolean) : [], l = n[i] ? n[i].split(";").map(c => c.trim()).filter(Boolean) : [], a = new Map; l.forEach(c => { const [d, f] = c.split(":").map(h => h.trim()); a.set(d, f) }), o.forEach(c => { const [d, f] = c.split(":").map(h => h.trim()); a.set(d, f) }), n[i] = Array.from(a.entries()).map(([c, d]) => `${c}: ${d}`).join("; ") } else n[i] = s }), n }, {}) } function Hr(r, e) { return e.filter(t => t.type === r.type.name).filter(t => t.attribute.rendered).map(t => t.attribute.renderHTML ? t.attribute.renderHTML(r.attrs) || {} : { [t.name]: r.attrs[t.name] }).reduce((t, n) => Y(t, n), {}) } function Po(r) { return typeof r == "function" } function N(r, e = void 0, ...t) { return Po(r) ? e ? r.bind(e)(...t) : r(...t) : r } function Ed(r = {}) { return Object.keys(r).length === 0 && r.constructor === Object } function Md(r) { return typeof r != "string" ? r : r.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(r) : r === "true" ? !0 : r === "false" ? !1 : r } function Is(r, e) { return "style" in r ? r : { ...r, getAttrs: t => { const n = r.getAttrs ? r.getAttrs(t) : r.attrs; if (n === !1) return !1; const i = e.reduce((s, u) => { const o = u.attribute.parseHTML ? u.attribute.parseHTML(t) : Md(t.getAttribute(u.name)); return o == null ? s : { ...s, [u.name]: o } }, {}); return { ...n, ...i } } } } function Ps(r) { return Object.fromEntries(Object.entries(r).filter(([e, t]) => e === "attrs" && Ed(t) ? !1 : t != null)) } function Nd(r, e) { var t; const n = Io(r), { nodeExtensions: i, markExtensions: s } = Zn(r), u = (t = i.find(a => k(a, "topNode"))) === null || t === void 0 ? void 0 : t.name, o = Object.fromEntries(i.map(a => { const c = n.filter(b => b.type === a.name), d = { name: a.name, options: a.options, storage: a.storage, editor: e }, f = r.reduce((b, w) => { const C = k(w, "extendNodeSchema", d); return { ...b, ...C ? C(a) : {} } }, {}), h = Ps({ ...f, content: N(k(a, "content", d)), marks: N(k(a, "marks", d)), group: N(k(a, "group", d)), inline: N(k(a, "inline", d)), atom: N(k(a, "atom", d)), selectable: N(k(a, "selectable", d)), draggable: N(k(a, "draggable", d)), code: N(k(a, "code", d)), whitespace: N(k(a, "whitespace", d)), linebreakReplacement: N(k(a, "linebreakReplacement", d)), defining: N(k(a, "defining", d)), isolating: N(k(a, "isolating", d)), attrs: Object.fromEntries(c.map(b => { var w; return [b.name, { default: (w = b == null ? void 0 : b.attribute) === null || w === void 0 ? void 0 : w.default }] })) }), p = N(k(a, "parseHTML", d)); p && (h.parseDOM = p.map(b => Is(b, c))); const m = k(a, "renderHTML", d); m && (h.toDOM = b => m({ node: b, HTMLAttributes: Hr(b, c) })); const g = k(a, "renderText", d); return g && (h.toText = g), [a.name, h] })), l = Object.fromEntries(s.map(a => { const c = n.filter(g => g.type === a.name), d = { name: a.name, options: a.options, storage: a.storage, editor: e }, f = r.reduce((g, b) => { const w = k(b, "extendMarkSchema", d); return { ...g, ...w ? w(a) : {} } }, {}), h = Ps({ ...f, inclusive: N(k(a, "inclusive", d)), excludes: N(k(a, "excludes", d)), group: N(k(a, "group", d)), spanning: N(k(a, "spanning", d)), code: N(k(a, "code", d)), attrs: Object.fromEntries(c.map(g => { var b; return [g.name, { default: (b = g == null ? void 0 : g.attribute) === null || b === void 0 ? void 0 : b.default }] })) }), p = N(k(a, "parseHTML", d)); p && (h.parseDOM = p.map(g => Is(g, c))); const m = k(a, "renderHTML", d); return m && (h.toDOM = g => m({ mark: g, HTMLAttributes: Hr(g, c) })), [a.name, h] })); return new wu({ topNode: u, nodes: o, marks: l }) } function yr(r, e) { return e.nodes[r] || e.marks[r] || null } function Ls(r, e) { return Array.isArray(e) ? e.some(t => (typeof t == "string" ? t : t.name) === r.name) : e } function gi(r, e) { const t = gt.fromSchema(e).serializeFragment(r), i = document.implementation.createHTMLDocument().createElement("div"); return i.appendChild(t), i.innerHTML } const Ad = (r, e = 500) => { let t = ""; const n = r.parentOffset; return r.parent.nodesBetween(Math.max(0, n - e), n, (i, s, u, o) => { var l, a; const c = ((a = (l = i.type.spec).toText) === null || a === void 0 ? void 0 : a.call(l, { node: i, pos: s, parent: u, index: o })) || i.textContent || "%leaf%"; t += i.isAtom && !i.isText ? c : c.slice(0, Math.max(0, n - s)) }), t }; function bi(r) { return Object.prototype.toString.call(r) === "[object RegExp]" } class Qn { constructor(e) { this.find = e.find, this.handler = e.handler } } const Od = (r, e) => { if (bi(e)) return e.exec(r); const t = e(r); if (!t) return null; const n = [t.text]; return n.index = t.index, n.input = r, n.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), n.push(t.replaceWith)), n }; function fn(r) { var e; const { editor: t, from: n, to: i, text: s, rules: u, plugin: o } = r, { view: l } = t; if (l.composing) return !1; const a = l.state.doc.resolve(n); if (a.parent.type.spec.code || !((e = a.nodeBefore || a.nodeAfter) === null || e === void 0) && e.marks.find(f => f.type.spec.code)) return !1; let c = !1; const d = Ad(a) + s; return u.forEach(f => { if (c) return; const h = Od(d, f.find); if (!h) return; const p = l.state.tr, m = Kn({ state: l.state, transaction: p }), g = { from: n - (h[0].length - s.length), to: i }, { commands: b, chain: w, can: C } = new Gn({ editor: t, state: m }); f.handler({ state: m, range: g, match: h, commands: b, chain: w, can: C }) === null || !p.steps.length || (p.setMeta(o, { transform: p, from: n, to: i, text: s }), l.dispatch(p), c = !0) }), c } function vd(r) {
    const { editor: e, rules: t } = r, n = new ue({
        state: { init() { return null }, apply(i, s, u) { const o = i.getMeta(n); if (o) return o; const l = i.getMeta("applyInputRules"); return !!l && setTimeout(() => { let { text: c } = l; typeof c == "string" ? c = c : c = gi(y.from(c), u.schema); const { from: d } = l, f = d + c.length; fn({ editor: e, from: d, to: f, text: c, rules: t, plugin: n }) }), i.selectionSet || i.docChanged ? null : s } }, props: {
            handleTextInput(i, s, u, o) { return fn({ editor: e, from: s, to: u, text: o, rules: t, plugin: n }) }, handleDOMEvents: { compositionend: i => (setTimeout(() => { const { $cursor: s } = i.state.selection; s && fn({ editor: e, from: s.pos, to: s.pos, text: "", rules: t, plugin: n }) }), !1) }, handleKeyDown(i, s) {
                if (s.key !== "Enter") return !1; const { $cursor: u } = i.state.selection; return u ? fn({
                    editor: e, from: u.pos, to: u.pos, text: `
`, rules: t, plugin: n
                }) : !1
            }
        }, isInputRules: !0
    }); return n
} function Dd(r) { return Object.prototype.toString.call(r).slice(8, -1) } function hn(r) { return Dd(r) !== "Object" ? !1 : r.constructor === Object && Object.getPrototypeOf(r) === Object.prototype } function Yn(r, e) { const t = { ...r }; return hn(r) && hn(e) && Object.keys(e).forEach(n => { hn(e[n]) && hn(r[n]) ? t[n] = Yn(r[n], e[n]) : t[n] = e[n] }), t } class we { constructor(e = {}) { this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = N(k(this, "addOptions", { name: this.name }))), this.storage = N(k(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new we(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => Yn(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new we(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = N(k(t, "addOptions", { name: t.name })), t.storage = N(k(t, "addStorage", { name: t.name, options: t.options })), t } static handleExit({ editor: e, mark: t }) { const { tr: n } = e.state, i = e.state.selection.$from; if (i.pos === i.end()) { const u = i.marks(); if (!!!u.find(a => (a == null ? void 0 : a.type.name) === t.name)) return !1; const l = u.find(a => (a == null ? void 0 : a.type.name) === t.name); return l && n.removeStoredMark(l), n.insertText(" ", i.pos), e.view.dispatch(n), !0 } return !1 } } function Rd(r) { return typeof r == "number" } class Id { constructor(e) { this.find = e.find, this.handler = e.handler } } const Pd = (r, e, t) => { if (bi(e)) return [...r.matchAll(e)]; const n = e(r, t); return n ? n.map(i => { const s = [i.text]; return s.index = i.index, s.input = r, s.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), s.push(i.replaceWith)), s }) : [] }; function Ld(r) { const { editor: e, state: t, from: n, to: i, rule: s, pasteEvent: u, dropEvent: o } = r, { commands: l, chain: a, can: c } = new Gn({ editor: e, state: t }), d = []; return t.doc.nodesBetween(n, i, (h, p) => { if (!h.isTextblock || h.type.spec.code) return; const m = Math.max(n, p), g = Math.min(i, p + h.content.size), b = h.textBetween(m - p, g - p, void 0, " "); Pd(b, s.find, u).forEach(C => { if (C.index === void 0) return; const O = m + C.index + 1, A = O + C[0].length, I = { from: t.tr.mapping.map(O), to: t.tr.mapping.map(A) }, ne = s.handler({ state: t, range: I, match: C, commands: l, chain: a, can: c, pasteEvent: u, dropEvent: o }); d.push(ne) }) }), d.every(h => h !== null) } let pn = null; const Bd = r => { var e; const t = new ClipboardEvent("paste", { clipboardData: new DataTransfer }); return (e = t.clipboardData) === null || e === void 0 || e.setData("text/html", r), t }; function zd(r) { const { editor: e, rules: t } = r; let n = null, i = !1, s = !1, u = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, o; try { o = typeof DragEvent < "u" ? new DragEvent("drop") : null } catch { o = null } const l = ({ state: c, from: d, to: f, rule: h, pasteEvt: p }) => { const m = c.tr, g = Kn({ state: c, transaction: m }); if (!(!Ld({ editor: e, state: g, from: Math.max(d - 1, 0), to: f.b - 1, rule: h, pasteEvent: p, dropEvent: o }) || !m.steps.length)) { try { o = typeof DragEvent < "u" ? new DragEvent("drop") : null } catch { o = null } return u = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m } }; return t.map(c => new ue({ view(d) { const f = p => { var m; n = !((m = d.dom.parentElement) === null || m === void 0) && m.contains(p.target) ? d.dom.parentElement : null, n && (pn = e) }, h = () => { pn && (pn = null) }; return window.addEventListener("dragstart", f), window.addEventListener("dragend", h), { destroy() { window.removeEventListener("dragstart", f), window.removeEventListener("dragend", h) } } }, props: { handleDOMEvents: { drop: (d, f) => { if (s = n === d.dom.parentElement, o = f, !s) { const h = pn; h != null && h.isEditable && setTimeout(() => { const p = h.state.selection; p && h.commands.deleteRange({ from: p.from, to: p.to }) }, 10) } return !1 }, paste: (d, f) => { var h; const p = (h = f.clipboardData) === null || h === void 0 ? void 0 : h.getData("text/html"); return u = f, i = !!(p != null && p.includes("data-pm-slice")), !1 } } }, appendTransaction: (d, f, h) => { const p = d[0], m = p.getMeta("uiEvent") === "paste" && !i, g = p.getMeta("uiEvent") === "drop" && !s, b = p.getMeta("applyPasteRules"), w = !!b; if (!m && !g && !w) return; if (w) { let { text: A } = b; typeof A == "string" ? A = A : A = gi(y.from(A), h.schema); const { from: I } = b, ne = I + A.length, E = Bd(A); return l({ rule: c, state: h, from: I, to: { b: ne }, pasteEvt: E }) } const C = f.doc.content.findDiffStart(h.doc.content), O = f.doc.content.findDiffEnd(h.doc.content); if (!(!Rd(C) || !O || C === O.b)) return l({ rule: c, state: h, from: C, to: O, pasteEvt: u }) } })) } function $d(r) { const e = r.filter((t, n) => r.indexOf(t) !== n); return Array.from(new Set(e)) } class Ct { constructor(e, t) { this.splittableMarks = [], this.editor = t, this.extensions = Ct.resolve(e), this.schema = Nd(this.extensions, t), this.setupExtensions() } static resolve(e) { const t = Ct.sort(Ct.flatten(e)), n = $d(t.map(i => i.name)); return n.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${n.map(i => `'${i}'`).join(", ")}]. This can lead to issues.`), t } static flatten(e) { return e.map(t => { const n = { name: t.name, options: t.options, storage: t.storage }, i = k(t, "addExtensions", n); return i ? [t, ...this.flatten(i())] : t }).flat(10) } static sort(e) { return e.sort((n, i) => { const s = k(n, "priority") || 100, u = k(i, "priority") || 100; return s > u ? -1 : s < u ? 1 : 0 }) } get commands() { return this.extensions.reduce((e, t) => { const n = { name: t.name, options: t.options, storage: t.storage, editor: this.editor, type: yr(t.name, this.schema) }, i = k(t, "addCommands", n); return i ? { ...e, ...i() } : e }, {}) } get plugins() { const { editor: e } = this, t = Ct.sort([...this.extensions].reverse()), n = [], i = [], s = t.map(u => { const o = { name: u.name, options: u.options, storage: u.storage, editor: e, type: yr(u.name, this.schema) }, l = [], a = k(u, "addKeyboardShortcuts", o); let c = {}; if (u.type === "mark" && k(u, "exitable", o) && (c.ArrowRight = () => we.handleExit({ editor: e, mark: u })), a) { const m = Object.fromEntries(Object.entries(a()).map(([g, b]) => [g, () => b({ editor: e })])); c = { ...c, ...m } } const d = rd(c); l.push(d); const f = k(u, "addInputRules", o); Ls(u, e.options.enableInputRules) && f && n.push(...f()); const h = k(u, "addPasteRules", o); Ls(u, e.options.enablePasteRules) && h && i.push(...h()); const p = k(u, "addProseMirrorPlugins", o); if (p) { const m = p(); l.push(...m) } return l }).flat(); return [vd({ editor: e, rules: n }), ...zd({ editor: e, rules: i }), ...s] } get attributes() { return Io(this.extensions) } get nodeViews() { const { editor: e } = this, { nodeExtensions: t } = Zn(this.extensions); return Object.fromEntries(t.filter(n => !!k(n, "addNodeView")).map(n => { const i = this.attributes.filter(l => l.type === n.name), s = { name: n.name, options: n.options, storage: n.storage, editor: e, type: U(n.name, this.schema) }, u = k(n, "addNodeView", s); if (!u) return []; const o = (l, a, c, d, f) => { const h = Hr(l, i); return u()({ node: l, view: a, getPos: c, decorations: d, innerDecorations: f, editor: e, extension: n, HTMLAttributes: h }) }; return [n.name, o] })) } setupExtensions() { this.extensions.forEach(e => { var t; this.editor.extensionStorage[e.name] = e.storage; const n = { name: e.name, options: e.options, storage: e.storage, editor: this.editor, type: yr(e.name, this.schema) }; e.type === "mark" && (!((t = N(k(e, "keepOnSplit", n))) !== null && t !== void 0) || t) && this.splittableMarks.push(e.name); const i = k(e, "onBeforeCreate", n), s = k(e, "onCreate", n), u = k(e, "onUpdate", n), o = k(e, "onSelectionUpdate", n), l = k(e, "onTransaction", n), a = k(e, "onFocus", n), c = k(e, "onBlur", n), d = k(e, "onDestroy", n); i && this.editor.on("beforeCreate", i), s && this.editor.on("create", s), u && this.editor.on("update", u), o && this.editor.on("selectionUpdate", o), l && this.editor.on("transaction", l), a && this.editor.on("focus", a), c && this.editor.on("blur", c), d && this.editor.on("destroy", d) }) } } class J { constructor(e = {}) { this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = N(k(this, "addOptions", { name: this.name }))), this.storage = N(k(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new J(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => Yn(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new J({ ...this.config, ...e }); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = N(k(t, "addOptions", { name: t.name })), t.storage = N(k(t, "addStorage", { name: t.name, options: t.options })), t } } function Lo(r, e, t) {
    const { from: n, to: i } = e, { blockSeparator: s = `

`, textSerializers: u = {} } = t || {}; let o = ""; return r.nodesBetween(n, i, (l, a, c, d) => { var f; l.isBlock && a > n && (o += s); const h = u == null ? void 0 : u[l.type.name]; if (h) return c && (o += h({ node: l, pos: a, parent: c, index: d, range: e })), !1; l.isText && (o += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(n, a) - a, i - a)) }), o
} function Bo(r) { return Object.fromEntries(Object.entries(r.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText])) } const _d = J.create({ name: "clipboardTextSerializer", addOptions() { return { blockSeparator: void 0 } }, addProseMirrorPlugins() { return [new ue({ key: new Se("clipboardTextSerializer"), props: { clipboardTextSerializer: () => { const { editor: r } = this, { state: e, schema: t } = r, { doc: n, selection: i } = e, { ranges: s } = i, u = Math.min(...s.map(c => c.$from.pos)), o = Math.max(...s.map(c => c.$to.pos)), l = Bo(t); return Lo(n, { from: u, to: o }, { ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {}, textSerializers: l }) } } })] } }), Fd = () => ({ editor: r, view: e }) => (requestAnimationFrame(() => { var t; r.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) === null || t === void 0 || t.removeAllRanges()) }), !0), Vd = (r = !1) => ({ commands: e }) => e.setContent("", r), qd = () => ({ state: r, tr: e, dispatch: t }) => { const { selection: n } = e, { ranges: i } = n; return t && i.forEach(({ $from: s, $to: u }) => { r.doc.nodesBetween(s.pos, u.pos, (o, l) => { if (o.type.isText) return; const { doc: a, mapping: c } = e, d = a.resolve(c.map(l)), f = a.resolve(c.map(l + o.nodeSize)), h = d.blockRange(f); if (!h) return; const p = It(h); if (o.type.isTextblock) { const { defaultType: m } = d.parent.contentMatchAt(d.index()); e.setNodeMarkup(h.start, m) } (p || p === 0) && e.lift(h, p) }) }), !0 }, Hd = r => e => r(e), jd = () => ({ state: r, dispatch: e }) => Oo(r, e), Wd = (r, e) => ({ editor: t, tr: n }) => { const { state: i } = t, s = i.doc.slice(r.from, r.to); n.deleteRange(r.from, r.to); const u = n.mapping.map(e); return n.insert(u, s.content), n.setSelection(new T(n.doc.resolve(Math.max(u - 1, 0)))), !0 }, Ud = () => ({ tr: r, dispatch: e }) => { const { selection: t } = r, n = t.$anchor.node(); if (n.content.size > 0) return !1; const i = r.selection.$anchor; for (let s = i.depth; s > 0; s -= 1)if (i.node(s).type === n.type) { if (e) { const o = i.before(s), l = i.after(s); r.delete(o, l).scrollIntoView() } return !0 } return !1 }, Jd = r => ({ tr: e, state: t, dispatch: n }) => { const i = U(r, t.schema), s = e.selection.$anchor; for (let u = s.depth; u > 0; u -= 1)if (s.node(u).type === i) { if (n) { const l = s.before(u), a = s.after(u); e.delete(l, a).scrollIntoView() } return !0 } return !1 }, Kd = r => ({ tr: e, dispatch: t }) => { const { from: n, to: i } = r; return t && e.delete(n, i), !0 }, Gd = () => ({ state: r, dispatch: e }) => di(r, e), Zd = () => ({ commands: r }) => r.keyboardShortcut("Enter"), Qd = () => ({ state: r, dispatch: e }) => ad(r, e); function Ln(r, e, t = { strict: !0 }) { const n = Object.keys(e); return n.length ? n.every(i => t.strict ? e[i] === r[i] : bi(e[i]) ? e[i].test(r[i]) : e[i] === r[i]) : !0 } function zo(r, e, t = {}) { return r.find(n => n.type === e && Ln(Object.fromEntries(Object.keys(t).map(i => [i, n.attrs[i]])), t)) } function Bs(r, e, t = {}) { return !!zo(r, e, t) } function yi(r, e, t) { var n; if (!r || !e) return; let i = r.parent.childAfter(r.parentOffset); if ((!i.node || !i.node.marks.some(c => c.type === e)) && (i = r.parent.childBefore(r.parentOffset)), !i.node || !i.node.marks.some(c => c.type === e) || (t = t || ((n = i.node.marks[0]) === null || n === void 0 ? void 0 : n.attrs), !zo([...i.node.marks], e, t))) return; let u = i.index, o = r.start() + i.offset, l = u + 1, a = o + i.node.nodeSize; for (; u > 0 && Bs([...r.parent.child(u - 1).marks], e, t);)u -= 1, o -= r.parent.child(u).nodeSize; for (; l < r.parent.childCount && Bs([...r.parent.child(l).marks], e, t);)a += r.parent.child(l).nodeSize, l += 1; return { from: o, to: a } } function Xe(r, e) { if (typeof r == "string") { if (!e.marks[r]) throw Error(`There is no mark type named '${r}'. Maybe you forgot to add the extension?`); return e.marks[r] } return r } const Yd = (r, e = {}) => ({ tr: t, state: n, dispatch: i }) => { const s = Xe(r, n.schema), { doc: u, selection: o } = t, { $from: l, from: a, to: c } = o; if (i) { const d = yi(l, s, e); if (d && d.from <= a && d.to >= c) { const f = T.create(u, d.from, d.to); t.setSelection(f) } } return !0 }, Xd = r => e => { const t = typeof r == "function" ? r(e) : r; for (let n = 0; n < t.length; n += 1)if (t[n](e)) return !0; return !1 }; function $o(r) { return r instanceof T } function it(r = 0, e = 0, t = 0) { return Math.min(Math.max(r, e), t) } function _o(r, e = null) { if (!e) return null; const t = M.atStart(r), n = M.atEnd(r); if (e === "start" || e === !0) return t; if (e === "end") return n; const i = t.from, s = n.to; return e === "all" ? T.create(r, it(0, i, s), it(r.content.size, i, s)) : T.create(r, it(e, i, s), it(e, i, s)) } function ef() { return navigator.platform === "Android" || /android/i.test(navigator.userAgent) } function xi() { return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document } const tf = (r = null, e = {}) => ({ editor: t, view: n, tr: i, dispatch: s }) => { e = { scrollIntoView: !0, ...e }; const u = () => { (xi() || ef()) && n.dom.focus(), requestAnimationFrame(() => { t.isDestroyed || (n.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView()) }) }; if (n.hasFocus() && r === null || r === !1) return !0; if (s && r === null && !$o(t.state.selection)) return u(), !0; const o = _o(i.doc, r) || t.state.selection, l = t.state.selection.eq(o); return s && (l || i.setSelection(o), l && i.storedMarks && i.setStoredMarks(i.storedMarks), u()), !0 }, nf = (r, e) => t => r.every((n, i) => e(n, { ...t, index: i })), rf = (r, e) => ({ tr: t, commands: n }) => n.insertContentAt({ from: t.selection.from, to: t.selection.to }, r, e), Fo = r => { const e = r.childNodes; for (let t = e.length - 1; t >= 0; t -= 1) { const n = e[t]; n.nodeType === 3 && n.nodeValue && /^(\n\s\s|\n)$/.test(n.nodeValue) ? r.removeChild(n) : n.nodeType === 1 && Fo(n) } return r }; function mn(r) { const e = `<body>${r}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body; return Fo(t) } function Xt(r, e, t) { if (r instanceof je || r instanceof y) return r; t = { slice: !0, parseOptions: {}, ...t }; const n = typeof r == "object" && r !== null, i = typeof r == "string"; if (n) try { if (Array.isArray(r) && r.length > 0) return y.fromArray(r.map(o => e.nodeFromJSON(o))); const u = e.nodeFromJSON(r); return t.errorOnInvalidContent && u.check(), u } catch (s) { if (t.errorOnInvalidContent) throw new Error("[tiptap error]: Invalid JSON content", { cause: s }); return console.warn("[tiptap warn]: Invalid content.", "Passed value:", r, "Error:", s), Xt("", e, t) } if (i) { if (t.errorOnInvalidContent) { let u = !1, o = ""; const l = new wu({ topNode: e.spec.topNode, marks: e.spec.marks, nodes: e.spec.nodes.append({ __tiptap__private__unknown__catch__all__node: { content: "inline*", group: "block", parseDOM: [{ tag: "*", getAttrs: a => (u = !0, o = typeof a == "string" ? a : a.outerHTML, null) }] } }) }); if (t.slice ? We.fromSchema(l).parseSlice(mn(r), t.parseOptions) : We.fromSchema(l).parse(mn(r), t.parseOptions), t.errorOnInvalidContent && u) throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${o}`) }) } const s = We.fromSchema(e); return t.slice ? s.parseSlice(mn(r), t.parseOptions).content : s.parse(mn(r), t.parseOptions) } return Xt("", e, t) } function sf(r, e, t) { const n = r.steps.length - 1; if (n < e) return; const i = r.steps[n]; if (!(i instanceof q || i instanceof j)) return; const s = r.mapping.maps[n]; let u = 0; s.forEach((o, l, a, c) => { u === 0 && (u = c) }), r.setSelection(M.near(r.doc.resolve(u), t)) } const uf = r => !("type" in r), of = (r, e, t) => ({ tr: n, dispatch: i, editor: s }) => { var u; if (i) { t = { parseOptions: s.options.parseOptions, updateSelection: !0, applyInputRules: !1, applyPasteRules: !1, ...t }; let o; const l = g => { s.emit("contentError", { editor: s, error: g, disableCollaboration: () => { s.storage.collaboration && (s.storage.collaboration.isDisabled = !0) } }) }, a = { preserveWhitespace: "full", ...t.parseOptions }; if (!t.errorOnInvalidContent && !s.options.enableContentCheck && s.options.emitContentError) try { Xt(e, s.schema, { parseOptions: a, errorOnInvalidContent: !0 }) } catch (g) { l(g) } try { o = Xt(e, s.schema, { parseOptions: a, errorOnInvalidContent: (u = t.errorOnInvalidContent) !== null && u !== void 0 ? u : s.options.enableContentCheck }) } catch (g) { return l(g), !1 } let { from: c, to: d } = typeof r == "number" ? { from: r, to: r } : { from: r.from, to: r.to }, f = !0, h = !0; if ((uf(o) ? o : [o]).forEach(g => { g.check(), f = f ? g.isText && g.marks.length === 0 : !1, h = h ? g.isBlock : !1 }), c === d && h) { const { parent: g } = n.doc.resolve(c); g.isTextblock && !g.type.spec.code && !g.childCount && (c -= 1, d += 1) } let m; if (f) { if (Array.isArray(e)) m = e.map(g => g.text || "").join(""); else if (e instanceof y) { let g = ""; e.forEach(b => { b.text && (g += b.text) }), m = g } else typeof e == "object" && e && e.text ? m = e.text : m = e; n.insertText(m, c, d) } else m = o, n.replaceWith(c, d, m); t.updateSelection && sf(n, n.steps.length - 1, -1), t.applyInputRules && n.setMeta("applyInputRules", { from: c, text: m }), t.applyPasteRules && n.setMeta("applyPasteRules", { from: c, text: m }) } return !0 }, lf = () => ({ state: r, dispatch: e }) => ud(r, e), af = () => ({ state: r, dispatch: e }) => od(r, e), cf = () => ({ state: r, dispatch: e }) => So(r, e), df = () => ({ state: r, dispatch: e }) => Mo(r, e), ff = () => ({ state: r, dispatch: e, tr: t }) => { try { const n = qn(r.doc, r.selection.$from.pos, -1); return n == null ? !1 : (t.join(n, 2), e && e(t), !0) } catch { return !1 } }, hf = () => ({ state: r, dispatch: e, tr: t }) => { try { const n = qn(r.doc, r.selection.$from.pos, 1); return n == null ? !1 : (t.join(n, 2), e && e(t), !0) } catch { return !1 } }, pf = () => ({ state: r, dispatch: e }) => id(r, e), mf = () => ({ state: r, dispatch: e }) => sd(r, e); function Vo() { return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1 } function gf(r) { const e = r.split(/-(?!$)/); let t = e[e.length - 1]; t === "Space" && (t = " "); let n, i, s, u; for (let o = 0; o < e.length - 1; o += 1) { const l = e[o]; if (/^(cmd|meta|m)$/i.test(l)) u = !0; else if (/^a(lt)?$/i.test(l)) n = !0; else if (/^(c|ctrl|control)$/i.test(l)) i = !0; else if (/^s(hift)?$/i.test(l)) s = !0; else if (/^mod$/i.test(l)) xi() || Vo() ? u = !0 : i = !0; else throw new Error(`Unrecognized modifier name: ${l}`) } return n && (t = `Alt-${t}`), i && (t = `Ctrl-${t}`), u && (t = `Meta-${t}`), s && (t = `Shift-${t}`), t } const bf = r => ({ editor: e, view: t, tr: n, dispatch: i }) => { const s = gf(r).split(/-(?!$)/), u = s.find(a => !["Alt", "Ctrl", "Meta", "Shift"].includes(a)), o = new KeyboardEvent("keydown", { key: u === "Space" ? " " : u, altKey: s.includes("Alt"), ctrlKey: s.includes("Ctrl"), metaKey: s.includes("Meta"), shiftKey: s.includes("Shift"), bubbles: !0, cancelable: !0 }), l = e.captureTransaction(() => { t.someProp("handleKeyDown", a => a(t, o)) }); return l == null || l.steps.forEach(a => { const c = a.map(n.mapping); c && i && n.maybeStep(c) }), !0 }; function en(r, e, t = {}) { const { from: n, to: i, empty: s } = r.selection, u = e ? U(e, r.schema) : null, o = []; r.doc.nodesBetween(n, i, (d, f) => { if (d.isText) return; const h = Math.max(n, f), p = Math.min(i, f + d.nodeSize); o.push({ node: d, from: h, to: p }) }); const l = i - n, a = o.filter(d => u ? u.name === d.node.type.name : !0).filter(d => Ln(d.node.attrs, t, { strict: !1 })); return s ? !!a.length : a.reduce((d, f) => d + f.to - f.from, 0) >= l } const yf = (r, e = {}) => ({ state: t, dispatch: n }) => { const i = U(r, t.schema); return en(t, i, e) ? ld(t, n) : !1 }, xf = () => ({ state: r, dispatch: e }) => vo(r, e), kf = r => ({ state: e, dispatch: t }) => { const n = U(r, e.schema); return kd(n)(e, t) }, wf = () => ({ state: r, dispatch: e }) => Ao(r, e); function Xn(r, e) { return e.nodes[r] ? "node" : e.marks[r] ? "mark" : null } function zs(r, e) { const t = typeof e == "string" ? [e] : e; return Object.keys(r).reduce((n, i) => (t.includes(i) || (n[i] = r[i]), n), {}) } const Sf = (r, e) => ({ tr: t, state: n, dispatch: i }) => { let s = null, u = null; const o = Xn(typeof r == "string" ? r : r.name, n.schema); return o ? (o === "node" && (s = U(r, n.schema)), o === "mark" && (u = Xe(r, n.schema)), i && t.selection.ranges.forEach(l => { n.doc.nodesBetween(l.$from.pos, l.$to.pos, (a, c) => { s && s === a.type && t.setNodeMarkup(c, void 0, zs(a.attrs, e)), u && a.marks.length && a.marks.forEach(d => { u === d.type && t.addMark(c, c + a.nodeSize, u.create(zs(d.attrs, e))) }) }) }), !0) : !1 }, Cf = () => ({ tr: r, dispatch: e }) => (e && r.scrollIntoView(), !0), Tf = () => ({ tr: r, dispatch: e }) => { if (e) { const t = new he(r.doc); r.setSelection(t) } return !0 }, Ef = () => ({ state: r, dispatch: e }) => To(r, e), Mf = () => ({ state: r, dispatch: e }) => No(r, e), Nf = () => ({ state: r, dispatch: e }) => fd(r, e), Af = () => ({ state: r, dispatch: e }) => md(r, e), Of = () => ({ state: r, dispatch: e }) => pd(r, e); function jr(r, e, t = {}, n = {}) { return Xt(r, e, { slice: !1, parseOptions: t, errorOnInvalidContent: n.errorOnInvalidContent }) } const vf = (r, e = !1, t = {}, n = {}) => ({ editor: i, tr: s, dispatch: u, commands: o }) => { var l, a; const { doc: c } = s; if (t.preserveWhitespace !== "full") { const d = jr(r, i.schema, t, { errorOnInvalidContent: (l = n.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck }); return u && s.replaceWith(0, c.content.size, d).setMeta("preventUpdate", !e), !0 } return u && s.setMeta("preventUpdate", !e), o.insertContentAt({ from: 0, to: c.content.size }, r, { parseOptions: t, errorOnInvalidContent: (a = n.errorOnInvalidContent) !== null && a !== void 0 ? a : i.options.enableContentCheck }) }; function qo(r, e) { const t = Xe(e, r.schema), { from: n, to: i, empty: s } = r.selection, u = []; s ? (r.storedMarks && u.push(...r.storedMarks), u.push(...r.selection.$head.marks())) : r.doc.nodesBetween(n, i, l => { u.push(...l.marks) }); const o = u.find(l => l.type.name === t.name); return o ? { ...o.attrs } : {} } function Df(r) { for (let e = 0; e < r.edgeCount; e += 1) { const { type: t } = r.edge(e); if (t.isTextblock && !t.hasRequiredAttrs()) return t } return null } function Rf(r, e) { for (let t = r.depth; t > 0; t -= 1) { const n = r.node(t); if (e(n)) return { pos: t > 0 ? r.before(t) : 0, start: r.start(t), depth: t, node: n } } } function ki(r) { return e => Rf(e.$from, r) } function If(r, e) { const t = { from: 0, to: r.content.size }; return Lo(r, t, e) } function Pf(r, e) { const t = U(e, r.schema), { from: n, to: i } = r.selection, s = []; r.doc.nodesBetween(n, i, o => { s.push(o) }); const u = s.reverse().find(o => o.type.name === t.name); return u ? { ...u.attrs } : {} } function Lf(r, e) { const t = Xn(typeof e == "string" ? e : e.name, r.schema); return t === "node" ? Pf(r, e) : t === "mark" ? qo(r, e) : {} } function Ho(r, e, t) { const n = []; return r === e ? t.resolve(r).marks().forEach(i => { const s = t.resolve(r), u = yi(s, i.type); u && n.push({ mark: i, ...u }) }) : t.nodesBetween(r, e, (i, s) => { !i || (i == null ? void 0 : i.nodeSize) === void 0 || n.push(...i.marks.map(u => ({ from: s, to: s + i.nodeSize, mark: u }))) }), n } function wn(r, e, t) { return Object.fromEntries(Object.entries(t).filter(([n]) => { const i = r.find(s => s.type === e && s.name === n); return i ? i.attribute.keepOnSplit : !1 })) } function Wr(r, e, t = {}) { const { empty: n, ranges: i } = r.selection, s = e ? Xe(e, r.schema) : null; if (n) return !!(r.storedMarks || r.selection.$from.marks()).filter(d => s ? s.name === d.type.name : !0).find(d => Ln(d.attrs, t, { strict: !1 })); let u = 0; const o = []; if (i.forEach(({ $from: d, $to: f }) => { const h = d.pos, p = f.pos; r.doc.nodesBetween(h, p, (m, g) => { if (!m.isText && !m.marks.length) return; const b = Math.max(h, g), w = Math.min(p, g + m.nodeSize), C = w - b; u += C, o.push(...m.marks.map(O => ({ mark: O, from: b, to: w }))) }) }), u === 0) return !1; const l = o.filter(d => s ? s.name === d.mark.type.name : !0).filter(d => Ln(d.mark.attrs, t, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), a = o.filter(d => s ? d.mark.type !== s && d.mark.type.excludes(s) : !0).reduce((d, f) => d + f.to - f.from, 0); return (l > 0 ? l + a : l) >= u } function Bf(r, e, t = {}) { if (!e) return en(r, null, t) || Wr(r, null, t); const n = Xn(e, r.schema); return n === "node" ? en(r, e, t) : n === "mark" ? Wr(r, e, t) : !1 } function $s(r, e) { const { nodeExtensions: t } = Zn(e), n = t.find(u => u.name === r); if (!n) return !1; const i = { name: n.name, options: n.options, storage: n.storage }, s = N(k(n, "group", i)); return typeof s != "string" ? !1 : s.split(" ").includes("list") } function er(r, { checkChildren: e = !0, ignoreWhitespace: t = !1 } = {}) { var n; if (t) { if (r.type.name === "hardBreak") return !0; if (r.isText) return /^\s*$/m.test((n = r.text) !== null && n !== void 0 ? n : "") } if (r.isText) return !r.text; if (r.isAtom || r.isLeaf) return !1; if (r.content.childCount === 0) return !0; if (e) { let i = !0; return r.content.forEach(s => { i !== !1 && (er(s, { ignoreWhitespace: t, checkChildren: e }) || (i = !1)) }), i } return !1 } function zf(r) { return r instanceof S } function $f(r, e, t) { var n; const { selection: i } = e; let s = null; if ($o(i) && (s = i.$cursor), s) { const o = (n = r.storedMarks) !== null && n !== void 0 ? n : s.marks(); return !!t.isInSet(o) || !o.some(l => l.type.excludes(t)) } const { ranges: u } = i; return u.some(({ $from: o, $to: l }) => { let a = o.depth === 0 ? r.doc.inlineContent && r.doc.type.allowsMarkType(t) : !1; return r.doc.nodesBetween(o.pos, l.pos, (c, d, f) => { if (a) return !1; if (c.isInline) { const h = !f || f.type.allowsMarkType(t), p = !!t.isInSet(c.marks) || !c.marks.some(m => m.type.excludes(t)); a = h && p } return !a }), a }) } const _f = (r, e = {}) => ({ tr: t, state: n, dispatch: i }) => { const { selection: s } = t, { empty: u, ranges: o } = s, l = Xe(r, n.schema); if (i) if (u) { const a = qo(n, l); t.addStoredMark(l.create({ ...a, ...e })) } else o.forEach(a => { const c = a.$from.pos, d = a.$to.pos; n.doc.nodesBetween(c, d, (f, h) => { const p = Math.max(h, c), m = Math.min(h + f.nodeSize, d); f.marks.find(b => b.type === l) ? f.marks.forEach(b => { l === b.type && t.addMark(p, m, l.create({ ...b.attrs, ...e })) }) : t.addMark(p, m, l.create(e)) }) }); return $f(n, t, l) }, Ff = (r, e) => ({ tr: t }) => (t.setMeta(r, e), !0), Vf = (r, e = {}) => ({ state: t, dispatch: n, chain: i }) => { const s = U(r, t.schema); let u; return t.selection.$anchor.sameParent(t.selection.$head) && (u = t.selection.$anchor.parent.attrs), s.isTextblock ? i().command(({ commands: o }) => Rs(s, { ...u, ...e })(t) ? !0 : o.clearNodes()).command(({ state: o }) => Rs(s, { ...u, ...e })(o, n)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1) }, qf = r => ({ tr: e, dispatch: t }) => { if (t) { const { doc: n } = e, i = it(r, 0, n.content.size), s = S.create(n, i); e.setSelection(s) } return !0 }, Hf = r => ({ tr: e, dispatch: t }) => { if (t) { const { doc: n } = e, { from: i, to: s } = typeof r == "number" ? { from: r, to: r } : r, u = T.atStart(n).from, o = T.atEnd(n).to, l = it(i, u, o), a = it(s, u, o), c = T.create(n, l, a); e.setSelection(c) } return !0 }, jf = r => ({ state: e, dispatch: t }) => { const n = U(r, e.schema); return Cd(n)(e, t) }; function _s(r, e) { const t = r.storedMarks || r.selection.$to.parentOffset && r.selection.$from.marks(); if (t) { const n = t.filter(i => e == null ? void 0 : e.includes(i.type.name)); r.tr.ensureMarks(n) } } const Wf = ({ keepMarks: r = !0 } = {}) => ({ tr: e, state: t, dispatch: n, editor: i }) => { const { selection: s, doc: u } = e, { $from: o, $to: l } = s, a = i.extensionManager.attributes, c = wn(a, o.node().type.name, o.node().attrs); if (s instanceof S && s.node.isBlock) return !o.parentOffset || !Re(u, o.pos) ? !1 : (n && (r && _s(t, i.extensionManager.splittableMarks), e.split(o.pos).scrollIntoView()), !0); if (!o.parent.isBlock) return !1; const d = l.parentOffset === l.parent.content.size, f = o.depth === 0 ? void 0 : Df(o.node(-1).contentMatchAt(o.indexAfter(-1))); let h = d && f ? [{ type: f, attrs: c }] : void 0, p = Re(e.doc, e.mapping.map(o.pos), 1, h); if (!h && !p && Re(e.doc, e.mapping.map(o.pos), 1, f ? [{ type: f }] : void 0) && (p = !0, h = f ? [{ type: f, attrs: c }] : void 0), n) { if (p && (s instanceof T && e.deleteSelection(), e.split(e.mapping.map(o.pos), 1, h), f && !d && !o.parentOffset && o.parent.type !== f)) { const m = e.mapping.map(o.before()), g = e.doc.resolve(m); o.node(-1).canReplaceWith(g.index(), g.index() + 1, f) && e.setNodeMarkup(e.mapping.map(o.before()), f) } r && _s(t, i.extensionManager.splittableMarks), e.scrollIntoView() } return p }, Uf = (r, e = {}) => ({ tr: t, state: n, dispatch: i, editor: s }) => { var u; const o = U(r, n.schema), { $from: l, $to: a } = n.selection, c = n.selection.node; if (c && c.isBlock || l.depth < 2 || !l.sameParent(a)) return !1; const d = l.node(-1); if (d.type !== o) return !1; const f = s.extensionManager.attributes; if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) { if (l.depth === 2 || l.node(-3).type !== o || l.index(-2) !== l.node(-2).childCount - 1) return !1; if (i) { let b = y.empty; const w = l.index(-1) ? 1 : l.index(-2) ? 2 : 3; for (let E = l.depth - w; E >= l.depth - 3; E -= 1)b = y.from(l.node(E).copy(b)); const C = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, O = { ...wn(f, l.node().type.name, l.node().attrs), ...e }, A = ((u = o.contentMatch.defaultType) === null || u === void 0 ? void 0 : u.createAndFill(O)) || void 0; b = b.append(y.from(o.createAndFill(null, A) || void 0)); const I = l.before(l.depth - (w - 1)); t.replace(I, l.after(-C), new x(b, 4 - w, 0)); let ne = -1; t.doc.nodesBetween(I, t.doc.content.size, (E, $) => { if (ne > -1) return !1; E.isTextblock && E.content.size === 0 && (ne = $ + 1) }), ne > -1 && t.setSelection(T.near(t.doc.resolve(ne))), t.scrollIntoView() } return !0 } const h = a.pos === l.end() ? d.contentMatchAt(0).defaultType : null, p = { ...wn(f, d.type.name, d.attrs), ...e }, m = { ...wn(f, l.node().type.name, l.node().attrs), ...e }; t.delete(l.pos, a.pos); const g = h ? [{ type: o, attrs: p }, { type: h, attrs: m }] : [{ type: o, attrs: p }]; if (!Re(t.doc, l.pos, 2)) return !1; if (i) { const { selection: b, storedMarks: w } = n, { splittableMarks: C } = s.extensionManager, O = w || b.$to.parentOffset && b.$from.marks(); if (t.split(l.pos, 2, g).scrollIntoView(), !O || !i) return !0; const A = O.filter(I => C.includes(I.type.name)); t.ensureMarks(A) } return !0 }, xr = (r, e) => { const t = ki(u => u.type === e)(r.selection); if (!t) return !0; const n = r.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth); if (n === void 0) return !0; const i = r.doc.nodeAt(n); return t.node.type === (i == null ? void 0 : i.type) && Qe(r.doc, t.pos) && r.join(t.pos), !0 }, kr = (r, e) => { const t = ki(u => u.type === e)(r.selection); if (!t) return !0; const n = r.doc.resolve(t.start).after(t.depth); if (n === void 0) return !0; const i = r.doc.nodeAt(n); return t.node.type === (i == null ? void 0 : i.type) && Qe(r.doc, n) && r.join(n), !0 }, Jf = (r, e, t, n = {}) => ({ editor: i, tr: s, state: u, dispatch: o, chain: l, commands: a, can: c }) => { const { extensions: d, splittableMarks: f } = i.extensionManager, h = U(r, u.schema), p = U(e, u.schema), { selection: m, storedMarks: g } = u, { $from: b, $to: w } = m, C = b.blockRange(w), O = g || m.$to.parentOffset && m.$from.marks(); if (!C) return !1; const A = ki(I => $s(I.type.name, d))(m); if (C.depth >= 1 && A && C.depth - A.depth <= 1) { if (A.node.type === h) return a.liftListItem(p); if ($s(A.node.type.name, d) && h.validContent(A.node.content) && o) return l().command(() => (s.setNodeMarkup(A.pos, h), !0)).command(() => xr(s, h)).command(() => kr(s, h)).run() } return !t || !O || !o ? l().command(() => c().wrapInList(h, n) ? !0 : a.clearNodes()).wrapInList(h, n).command(() => xr(s, h)).command(() => kr(s, h)).run() : l().command(() => { const I = c().wrapInList(h, n), ne = O.filter(E => f.includes(E.type.name)); return s.ensureMarks(ne), I ? !0 : a.clearNodes() }).wrapInList(h, n).command(() => xr(s, h)).command(() => kr(s, h)).run() }, Kf = (r, e = {}, t = {}) => ({ state: n, commands: i }) => { const { extendEmptyMarkRange: s = !1 } = t, u = Xe(r, n.schema); return Wr(n, u, e) ? i.unsetMark(u, { extendEmptyMarkRange: s }) : i.setMark(u, e) }, Gf = (r, e, t = {}) => ({ state: n, commands: i }) => { const s = U(r, n.schema), u = U(e, n.schema), o = en(n, s, t); let l; return n.selection.$anchor.sameParent(n.selection.$head) && (l = n.selection.$anchor.parent.attrs), o ? i.setNode(u, l) : i.setNode(s, { ...l, ...t }) }, Zf = (r, e = {}) => ({ state: t, commands: n }) => { const i = U(r, t.schema); return en(t, i, e) ? n.lift(i) : n.wrapIn(i, e) }, Qf = () => ({ state: r, dispatch: e }) => { const t = r.plugins; for (let n = 0; n < t.length; n += 1) { const i = t[n]; let s; if (i.spec.isInputRules && (s = i.getState(r))) { if (e) { const u = r.tr, o = s.transform; for (let l = o.steps.length - 1; l >= 0; l -= 1)u.step(o.steps[l].invert(o.docs[l])); if (s.text) { const l = u.doc.resolve(s.from).marks(); u.replaceWith(s.from, s.to, r.schema.text(s.text, l)) } else u.delete(s.from, s.to) } return !0 } } return !1 }, Yf = () => ({ tr: r, dispatch: e }) => { const { selection: t } = r, { empty: n, ranges: i } = t; return n || e && i.forEach(s => { r.removeMark(s.$from.pos, s.$to.pos) }), !0 }, Xf = (r, e = {}) => ({ tr: t, state: n, dispatch: i }) => { var s; const { extendEmptyMarkRange: u = !1 } = e, { selection: o } = t, l = Xe(r, n.schema), { $from: a, empty: c, ranges: d } = o; if (!i) return !0; if (c && u) { let { from: f, to: h } = o; const p = (s = a.marks().find(g => g.type === l)) === null || s === void 0 ? void 0 : s.attrs, m = yi(a, l, p); m && (f = m.from, h = m.to), t.removeMark(f, h, l) } else d.forEach(f => { t.removeMark(f.$from.pos, f.$to.pos, l) }); return t.removeStoredMark(l), !0 }, eh = (r, e = {}) => ({ tr: t, state: n, dispatch: i }) => { let s = null, u = null; const o = Xn(typeof r == "string" ? r : r.name, n.schema); return o ? (o === "node" && (s = U(r, n.schema)), o === "mark" && (u = Xe(r, n.schema)), i && t.selection.ranges.forEach(l => { const a = l.$from.pos, c = l.$to.pos; let d, f, h, p; t.selection.empty ? n.doc.nodesBetween(a, c, (m, g) => { s && s === m.type && (h = Math.max(g, a), p = Math.min(g + m.nodeSize, c), d = g, f = m) }) : n.doc.nodesBetween(a, c, (m, g) => { g < a && s && s === m.type && (h = Math.max(g, a), p = Math.min(g + m.nodeSize, c), d = g, f = m), g >= a && g <= c && (s && s === m.type && t.setNodeMarkup(g, void 0, { ...m.attrs, ...e }), u && m.marks.length && m.marks.forEach(b => { if (u === b.type) { const w = Math.max(g, a), C = Math.min(g + m.nodeSize, c); t.addMark(w, C, u.create({ ...b.attrs, ...e })) } })) }), f && (d !== void 0 && t.setNodeMarkup(d, void 0, { ...f.attrs, ...e }), u && f.marks.length && f.marks.forEach(m => { u === m.type && t.addMark(h, p, u.create({ ...m.attrs, ...e })) })) }), !0) : !1 }, th = (r, e = {}) => ({ state: t, dispatch: n }) => { const i = U(r, t.schema); return gd(i, e)(t, n) }, nh = (r, e = {}) => ({ state: t, dispatch: n }) => { const i = U(r, t.schema); return bd(i, e)(t, n) }; var rh = Object.freeze({ __proto__: null, blur: Fd, clearContent: Vd, clearNodes: qd, command: Hd, createParagraphNear: jd, cut: Wd, deleteCurrentNode: Ud, deleteNode: Jd, deleteRange: Kd, deleteSelection: Gd, enter: Zd, exitCode: Qd, extendMarkRange: Yd, first: Xd, focus: tf, forEach: nf, insertContent: rf, insertContentAt: of, joinBackward: cf, joinDown: af, joinForward: df, joinItemBackward: ff, joinItemForward: hf, joinTextblockBackward: pf, joinTextblockForward: mf, joinUp: lf, keyboardShortcut: bf, lift: yf, liftEmptyBlock: xf, liftListItem: kf, newlineInCode: wf, resetAttributes: Sf, scrollIntoView: Cf, selectAll: Tf, selectNodeBackward: Ef, selectNodeForward: Mf, selectParentNode: Nf, selectTextblockEnd: Af, selectTextblockStart: Of, setContent: vf, setMark: _f, setMeta: Ff, setNode: Vf, setNodeSelection: qf, setTextSelection: Hf, sinkListItem: jf, splitBlock: Wf, splitListItem: Uf, toggleList: Jf, toggleMark: Kf, toggleNode: Gf, toggleWrap: Zf, undoInputRule: Qf, unsetAllMarks: Yf, unsetMark: Xf, updateAttributes: eh, wrapIn: th, wrapInList: nh }); const ih = J.create({ name: "commands", addCommands() { return { ...rh } } }), sh = J.create({ name: "drop", addProseMirrorPlugins() { return [new ue({ key: new Se("tiptapDrop"), props: { handleDrop: (r, e, t, n) => { this.editor.emit("drop", { editor: this.editor, event: e, slice: t, moved: n }) } } })] } }), uh = J.create({ name: "editable", addProseMirrorPlugins() { return [new ue({ key: new Se("editable"), props: { editable: () => this.editor.options.editable } })] } }), oh = new Se("focusEvents"), lh = J.create({ name: "focusEvents", addProseMirrorPlugins() { const { editor: r } = this; return [new ue({ key: oh, props: { handleDOMEvents: { focus: (e, t) => { r.isFocused = !0; const n = r.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1); return e.dispatch(n), !1 }, blur: (e, t) => { r.isFocused = !1; const n = r.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1); return e.dispatch(n), !1 } } } })] } }), ah = J.create({ name: "keymap", addKeyboardShortcuts() { const r = () => this.editor.commands.first(({ commands: u }) => [() => u.undoInputRule(), () => u.command(({ tr: o }) => { const { selection: l, doc: a } = o, { empty: c, $anchor: d } = l, { pos: f, parent: h } = d, p = d.parent.isTextblock && f > 0 ? o.doc.resolve(f - 1) : d, m = p.parent.type.spec.isolating, g = d.pos - d.parentOffset, b = m && p.parent.childCount === 1 ? g === d.pos : M.atStart(a).from === f; return !c || !h.type.isTextblock || h.textContent.length || !b || b && d.parent.type.name === "paragraph" ? !1 : u.clearNodes() }), () => u.deleteSelection(), () => u.joinBackward(), () => u.selectNodeBackward()]), e = () => this.editor.commands.first(({ commands: u }) => [() => u.deleteSelection(), () => u.deleteCurrentNode(), () => u.joinForward(), () => u.selectNodeForward()]), n = { Enter: () => this.editor.commands.first(({ commands: u }) => [() => u.newlineInCode(), () => u.createParagraphNear(), () => u.liftEmptyBlock(), () => u.splitBlock()]), "Mod-Enter": () => this.editor.commands.exitCode(), Backspace: r, "Mod-Backspace": r, "Shift-Backspace": r, Delete: e, "Mod-Delete": e, "Mod-a": () => this.editor.commands.selectAll() }, i = { ...n }, s = { ...n, "Ctrl-h": r, "Alt-Backspace": r, "Ctrl-d": e, "Ctrl-Alt-Backspace": e, "Alt-Delete": e, "Alt-d": e, "Ctrl-a": () => this.editor.commands.selectTextblockStart(), "Ctrl-e": () => this.editor.commands.selectTextblockEnd() }; return xi() || Vo() ? s : i }, addProseMirrorPlugins() { return [new ue({ key: new Se("clearDocument"), appendTransaction: (r, e, t) => { if (r.some(m => m.getMeta("composition"))) return; const n = r.some(m => m.docChanged) && !e.doc.eq(t.doc), i = r.some(m => m.getMeta("preventClearDocument")); if (!n || i) return; const { empty: s, from: u, to: o } = e.selection, l = M.atStart(e.doc).from, a = M.atEnd(e.doc).to; if (s || !(u === l && o === a) || !er(t.doc)) return; const f = t.tr, h = Kn({ state: t, transaction: f }), { commands: p } = new Gn({ editor: this.editor, state: h }); if (p.clearNodes(), !!f.steps.length) return f } })] } }), ch = J.create({ name: "paste", addProseMirrorPlugins() { return [new ue({ key: new Se("tiptapPaste"), props: { handlePaste: (r, e, t) => { this.editor.emit("paste", { editor: this.editor, event: e, slice: t }) } } })] } }), dh = J.create({ name: "tabindex", addProseMirrorPlugins() { return [new ue({ key: new Se("tabindex"), props: { attributes: () => this.editor.isEditable ? { tabindex: "0" } : {} } })] } }); class tt { get name() { return this.node.type.name } constructor(e, t, n = !1, i = null) { this.currentNode = null, this.actualDepth = null, this.isBlock = n, this.resolvedPos = e, this.editor = t, this.currentNode = i } get node() { return this.currentNode || this.resolvedPos.node() } get element() { return this.editor.view.domAtPos(this.pos).node } get depth() { var e; return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth } get pos() { return this.resolvedPos.pos } get content() { return this.node.content } set content(e) { let t = this.from, n = this.to; if (this.isBlock) { if (this.content.size === 0) { console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`); return } t = this.from + 1, n = this.to - 1 } this.editor.commands.insertContentAt({ from: t, to: n }, e) } get attributes() { return this.node.attrs } get textContent() { return this.node.textContent } get size() { return this.node.nodeSize } get from() { return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth) } get range() { return { from: this.from, to: this.to } } get to() { return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1) } get parent() { if (this.depth === 0) return null; const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e); return new tt(t, this.editor) } get before() { let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2)); return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new tt(e, this.editor) } get after() { let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1)); return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new tt(e, this.editor) } get children() { const e = []; return this.node.content.forEach((t, n) => { const i = t.isBlock && !t.isTextblock, s = t.isAtom && !t.isText, u = this.pos + n + (s ? 0 : 1); if (u < 0 || u > this.resolvedPos.doc.nodeSize - 2) return; const o = this.resolvedPos.doc.resolve(u); if (!i && o.depth <= this.depth) return; const l = new tt(o, this.editor, i, i ? t : null); i && (l.actualDepth = this.depth + 1), e.push(new tt(o, this.editor, i, i ? t : null)) }), e } get firstChild() { return this.children[0] || null } get lastChild() { const e = this.children; return e[e.length - 1] || null } closest(e, t = {}) { let n = null, i = this.parent; for (; i && !n;) { if (i.node.type.name === e) if (Object.keys(t).length > 0) { const s = i.node.attrs, u = Object.keys(t); for (let o = 0; o < u.length; o += 1) { const l = u[o]; if (s[l] !== t[l]) break } } else n = i; i = i.parent } return n } querySelector(e, t = {}) { return this.querySelectorAll(e, t, !0)[0] || null } querySelectorAll(e, t = {}, n = !1) { let i = []; if (!this.children || this.children.length === 0) return i; const s = Object.keys(t); return this.children.forEach(u => { n && i.length > 0 || (u.node.type.name === e && s.every(l => t[l] === u.node.attrs[l]) && i.push(u), !(n && i.length > 0) && (i = i.concat(u.querySelectorAll(e, t, n)))) }), i } setAttribute(e) { const { tr: t } = this.editor.state; t.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...e }), this.editor.view.dispatch(t) } } const fh = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`; function hh(r, e, t) { const n = document.querySelector("style[data-tiptap-style]"); if (n !== null) return n; const i = document.createElement("style"); return e && i.setAttribute("nonce", e), i.setAttribute("data-tiptap-style", ""), i.innerHTML = r, document.getElementsByTagName("head")[0].appendChild(i), i } class ph extends Td {
    constructor(e = {}) { super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = { element: document.createElement("div"), content: "", injectCSS: !0, injectNonce: void 0, extensions: [], autofocus: !1, editable: !0, editorProps: {}, parseOptions: {}, coreExtensionOptions: {}, enableInputRules: !0, enablePasteRules: !0, enableCoreExtensions: !0, enableContentCheck: !1, emitContentError: !1, onBeforeCreate: () => null, onCreate: () => null, onUpdate: () => null, onSelectionUpdate: () => null, onTransaction: () => null, onFocus: () => null, onBlur: () => null, onDestroy: () => null, onContentError: ({ error: t }) => { throw t }, onPaste: () => null, onDrop: () => null }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: t, slice: n, moved: i }) => this.options.onDrop(t, n, i)), this.on("paste", ({ event: t, slice: n }) => this.options.onPaste(t, n)), window.setTimeout(() => { this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0) }, 0) } get storage() { return this.extensionStorage } get commands() { return this.commandManager.commands } chain() { return this.commandManager.chain() } can() { return this.commandManager.can() } injectCSS() { this.options.injectCSS && document && (this.css = hh(fh, this.options.injectNonce)) } setOptions(e = {}) { this.options = { ...this.options, ...e }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state)) } setEditable(e, t = !0) { this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr }) } get isEditable() { return this.options.editable && this.view && this.view.editable } get state() { return this.view.state } registerPlugin(e, t) { const n = Po(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: n }); return this.view.updateState(i), i } unregisterPlugin(e) { if (this.isDestroyed) return; const t = this.state.plugins; let n = t; if ([].concat(e).forEach(s => { const u = typeof s == "string" ? `${s}$` : s.key; n = n.filter(o => !o.key.startsWith(u)) }), t.length === n.length) return; const i = this.state.reconfigure({ plugins: n }); return this.view.updateState(i), i } createExtensionManager() { var e, t; const i = [...this.options.enableCoreExtensions ? [uh, _d.configure({ blockSeparator: (t = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || t === void 0 ? void 0 : t.blockSeparator }), ih, lh, ah, dh, sh, ch].filter(s => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[s.name] !== !1 : !0) : [], ...this.options.extensions].filter(s => ["extension", "node", "mark"].includes(s == null ? void 0 : s.type)); this.extensionManager = new Ct(i, this) } createCommandManager() { this.commandManager = new Gn({ editor: this }) } createSchema() { this.schema = this.extensionManager.schema } createView() { var e; let t; try { t = jr(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck }) } catch (u) { if (!(u instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(u.message)) throw u; this.emit("contentError", { editor: this, error: u, disableCollaboration: () => { this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter(o => o.name !== "collaboration"), this.createExtensionManager() } }), t = jr(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 }) } const n = _o(t, this.options.autofocus); this.view = new xo(this.options.element, { ...this.options.editorProps, attributes: { role: "textbox", ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes }, dispatchTransaction: this.dispatchTransaction.bind(this), state: St.create({ doc: t, selection: n || void 0 }) }); const i = this.state.reconfigure({ plugins: this.extensionManager.plugins }); this.view.updateState(i), this.createNodeViews(), this.prependClass(); const s = this.view.dom; s.editor = this } createNodeViews() { this.view.isDestroyed || this.view.setProps({ nodeViews: this.extensionManager.nodeViews }) } prependClass() { this.view.dom.className = `tiptap ${this.view.dom.className}` } captureTransaction(e) { this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1; const t = this.capturedTransaction; return this.capturedTransaction = null, t } dispatchTransaction(e) { if (this.view.isDestroyed) return; if (this.isCapturingTransaction) { if (!this.capturedTransaction) { this.capturedTransaction = e; return } e.steps.forEach(u => { var o; return (o = this.capturedTransaction) === null || o === void 0 ? void 0 : o.step(u) }); return } const t = this.state.apply(e), n = !this.state.selection.eq(t.selection); this.emit("beforeTransaction", { editor: this, transaction: e, nextState: t }), this.view.updateState(t), this.emit("transaction", { editor: this, transaction: e }), n && this.emit("selectionUpdate", { editor: this, transaction: e }); const i = e.getMeta("focus"), s = e.getMeta("blur"); i && this.emit("focus", { editor: this, event: i.event, transaction: e }), s && this.emit("blur", { editor: this, event: s.event, transaction: e }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", { editor: this, transaction: e }) } getAttributes(e) { return Lf(this.state, e) } isActive(e, t) { const n = typeof e == "string" ? e : null, i = typeof e == "string" ? t : e; return Bf(this.state, n, i) } getJSON() { return this.state.doc.toJSON() } getHTML() { return gi(this.state.doc.content, this.schema) } getText(e) {
        const { blockSeparator: t = `

`, textSerializers: n = {} } = e || {}; return If(this.state.doc, { blockSeparator: t, textSerializers: { ...Bo(this.schema), ...n } })
    } get isEmpty() { return er(this.state.doc) } getCharacterCount() { return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2 } destroy() { if (this.emit("destroy"), this.view) { const e = this.view.dom; e && e.editor && delete e.editor, this.view.destroy() } this.removeAllListeners() } get isDestroyed() { var e; return !(!((e = this.view) === null || e === void 0) && e.docView) } $node(e, t) { var n; return ((n = this.$doc) === null || n === void 0 ? void 0 : n.querySelector(e, t)) || null } $nodes(e, t) { var n; return ((n = this.$doc) === null || n === void 0 ? void 0 : n.querySelectorAll(e, t)) || null } $pos(e) { const t = this.state.doc.resolve(e); return new tt(t, this) } get $doc() { return this.$pos(0) }
} function Dt(r) { return new Qn({ find: r.find, handler: ({ state: e, range: t, match: n }) => { const i = N(r.getAttributes, void 0, n); if (i === !1 || i === null) return null; const { tr: s } = e, u = n[n.length - 1], o = n[0]; if (u) { const l = o.search(/\S/), a = t.from + o.indexOf(u), c = a + u.length; if (Ho(t.from, t.to, e.doc).filter(h => h.mark.type.excluded.find(m => m === r.type && m !== h.mark.type)).filter(h => h.to > a).length) return null; c < t.to && s.delete(c, t.to), a > t.from && s.delete(t.from + l, a); const f = t.from + l + u.length; s.addMark(t.from + l, f, r.type.create(i || {})), s.removeStoredMark(r.type) } } }) } function mh(r) { return new Qn({ find: r.find, handler: ({ state: e, range: t, match: n }) => { const i = N(r.getAttributes, void 0, n) || {}, { tr: s } = e, u = t.from; let o = t.to; const l = r.type.create(i); if (n[1]) { const a = n[0].lastIndexOf(n[1]); let c = u + a; c > o ? c = o : o = c + n[1].length; const d = n[0][n[0].length - 1]; s.insertText(d, u + n[0].length - 1), s.replaceWith(c, o, l) } else if (n[0]) { const a = r.type.isInline ? u : u - 1; s.insert(a, r.type.create(i)).delete(s.mapping.map(u), s.mapping.map(o)) } s.scrollIntoView() } }) } function Ur(r) { return new Qn({ find: r.find, handler: ({ state: e, range: t, match: n }) => { const i = e.doc.resolve(t.from), s = N(r.getAttributes, void 0, n) || {}; if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), r.type)) return null; e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, r.type, s) } }) } function tn(r) { return new Qn({ find: r.find, handler: ({ state: e, range: t, match: n, chain: i }) => { const s = N(r.getAttributes, void 0, n) || {}, u = e.tr.delete(t.from, t.to), l = u.doc.resolve(t.from).blockRange(), a = l && ei(l, r.type, s); if (!a) return null; if (u.wrap(l, a), r.keepMarks && r.editor) { const { selection: d, storedMarks: f } = e, { splittableMarks: h } = r.editor.extensionManager, p = f || d.$to.parentOffset && d.$from.marks(); if (p) { const m = p.filter(g => h.includes(g.type.name)); u.ensureMarks(m) } } if (r.keepAttributes) { const d = r.type.name === "bulletList" || r.type.name === "orderedList" ? "listItem" : "taskList"; i().updateAttributes(d, s).run() } const c = u.doc.resolve(t.from - 1).nodeBefore; c && c.type === r.type && Qe(u.doc, t.from - 1) && (!r.joinPredicate || r.joinPredicate(n, c)) && u.join(t.from - 1) } }) } class ae { constructor(e = {}) { this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = N(k(this, "addOptions", { name: this.name }))), this.storage = N(k(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new ae(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => Yn(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new ae(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = N(k(t, "addOptions", { name: t.name })), t.storage = N(k(t, "addStorage", { name: t.name, options: t.options })), t } } function Rt(r) { return new Id({ find: r.find, handler: ({ state: e, range: t, match: n, pasteEvent: i }) => { const s = N(r.getAttributes, void 0, n, i); if (s === !1 || s === null) return null; const { tr: u } = e, o = n[n.length - 1], l = n[0]; let a = t.to; if (o) { const c = l.search(/\S/), d = t.from + l.indexOf(o), f = d + o.length; if (Ho(t.from, t.to, e.doc).filter(p => p.mark.type.excluded.find(g => g === r.type && g !== p.mark.type)).filter(p => p.to > d).length) return null; f < t.to && u.delete(f, t.to), d > t.from && u.delete(t.from + c, d), a = t.from + c + o.length, u.addMark(t.from + c, a, r.type.create(s || {})), u.removeStoredMark(r.type) } } }) } function gh(r, e) { const { selection: t } = r, { $from: n } = t; if (t instanceof S) { const s = n.index(); return n.parent.canReplaceWith(s, s + 1, e) } let i = n.depth; for (; i >= 0;) { const s = n.index(i); if (n.node(i).contentMatchAt(s).matchType(e)) return !0; i -= 1 } return !1 } const bh = /^\s*>\s$/, yh = ae.create({ name: "blockquote", addOptions() { return { HTMLAttributes: {} } }, content: "block+", group: "block", defining: !0, parseHTML() { return [{ tag: "blockquote" }] }, renderHTML({ HTMLAttributes: r }) { return ["blockquote", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { setBlockquote: () => ({ commands: r }) => r.wrapIn(this.name), toggleBlockquote: () => ({ commands: r }) => r.toggleWrap(this.name), unsetBlockquote: () => ({ commands: r }) => r.lift(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-b": () => this.editor.commands.toggleBlockquote() } }, addInputRules() { return [tn({ find: bh, type: this.type })] } }), xh = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, kh = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, wh = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, Sh = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, Ch = we.create({ name: "bold", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "strong" }, { tag: "b", getAttrs: r => r.style.fontWeight !== "normal" && null }, { style: "font-weight=400", clearMark: r => r.type.name === this.name }, { style: "font-weight", getAttrs: r => /^(bold(er)?|[5-9]\d{2,})$/.test(r) && null }] }, renderHTML({ HTMLAttributes: r }) { return ["strong", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { setBold: () => ({ commands: r }) => r.setMark(this.name), toggleBold: () => ({ commands: r }) => r.toggleMark(this.name), unsetBold: () => ({ commands: r }) => r.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-b": () => this.editor.commands.toggleBold(), "Mod-B": () => this.editor.commands.toggleBold() } }, addInputRules() { return [Dt({ find: xh, type: this.type }), Dt({ find: wh, type: this.type })] }, addPasteRules() { return [Rt({ find: kh, type: this.type }), Rt({ find: Sh, type: this.type })] } }), Th = "listItem", Fs = "textStyle", Vs = /^\s*([-+*])\s$/, Eh = ae.create({ name: "bulletList", addOptions() { return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 } }, group: "block list", content() { return `${this.options.itemTypeName}+` }, parseHTML() { return [{ tag: "ul" }] }, renderHTML({ HTMLAttributes: r }) { return ["ul", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { toggleBulletList: () => ({ commands: r, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Th, this.editor.getAttributes(Fs)).run() : r.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) } }, addKeyboardShortcuts() { return { "Mod-Shift-8": () => this.editor.commands.toggleBulletList() } }, addInputRules() { let r = tn({ find: Vs, type: this.type }); return (this.options.keepMarks || this.options.keepAttributes) && (r = tn({ find: Vs, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: () => this.editor.getAttributes(Fs), editor: this.editor })), [r] } }), Mh = /(^|[^`])`([^`]+)`(?!`)/, Nh = /(^|[^`])`([^`]+)`(?!`)/g, Ah = we.create({ name: "code", addOptions() { return { HTMLAttributes: {} } }, excludes: "_", code: !0, exitable: !0, parseHTML() { return [{ tag: "code" }] }, renderHTML({ HTMLAttributes: r }) { return ["code", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { setCode: () => ({ commands: r }) => r.setMark(this.name), toggleCode: () => ({ commands: r }) => r.toggleMark(this.name), unsetCode: () => ({ commands: r }) => r.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-e": () => this.editor.commands.toggleCode() } }, addInputRules() { return [Dt({ find: Mh, type: this.type })] }, addPasteRules() { return [Rt({ find: Nh, type: this.type })] } }), Oh = /^```([a-z]+)?[\s\n]$/, vh = /^~~~([a-z]+)?[\s\n]$/, Dh = ae.create({
    name: "codeBlock", addOptions() { return { languageClassPrefix: "language-", exitOnTripleEnter: !0, exitOnArrowDown: !0, defaultLanguage: null, HTMLAttributes: {} } }, content: "text*", marks: "", group: "block", code: !0, defining: !0, addAttributes() { return { language: { default: this.options.defaultLanguage, parseHTML: r => { var e; const { languageClassPrefix: t } = this.options, s = [...((e = r.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter(u => u.startsWith(t)).map(u => u.replace(t, ""))[0]; return s || null }, rendered: !1 } } }, parseHTML() { return [{ tag: "pre", preserveWhitespace: "full" }] }, renderHTML({ node: r, HTMLAttributes: e }) { return ["pre", Y(this.options.HTMLAttributes, e), ["code", { class: r.attrs.language ? this.options.languageClassPrefix + r.attrs.language : null }, 0]] }, addCommands() { return { setCodeBlock: r => ({ commands: e }) => e.setNode(this.name, r), toggleCodeBlock: r => ({ commands: e }) => e.toggleNode(this.name, "paragraph", r) } }, addKeyboardShortcuts() {
        return {
            "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(), Backspace: () => { const { empty: r, $anchor: e } = this.editor.state.selection, t = e.pos === 1; return !r || e.parent.type.name !== this.name ? !1 : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1 }, Enter: ({ editor: r }) => {
                if (!this.options.exitOnTripleEnter) return !1; const { state: e } = r, { selection: t } = e, { $from: n, empty: i } = t; if (!i || n.parent.type !== this.type) return !1; const s = n.parentOffset === n.parent.nodeSize - 2, u = n.parent.textContent.endsWith(`

`); return !s || !u ? !1 : r.chain().command(({ tr: o }) => (o.delete(n.pos - 2, n.pos), !0)).exitCode().run()
            }, ArrowDown: ({ editor: r }) => { if (!this.options.exitOnArrowDown) return !1; const { state: e } = r, { selection: t, doc: n } = e, { $from: i, empty: s } = t; if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2)) return !1; const o = i.after(); return o === void 0 ? !1 : n.nodeAt(o) ? r.commands.command(({ tr: a }) => (a.setSelection(M.near(n.resolve(o))), !0)) : r.commands.exitCode() }
        }
    }, addInputRules() { return [Ur({ find: Oh, type: this.type, getAttributes: r => ({ language: r[1] }) }), Ur({ find: vh, type: this.type, getAttributes: r => ({ language: r[1] }) })] }, addProseMirrorPlugins() {
        return [new ue({
            key: new Se("codeBlockVSCodeHandler"), props: {
                handlePaste: (r, e) => {
                    if (!e.clipboardData || this.editor.isActive(this.type.name)) return !1; const t = e.clipboardData.getData("text/plain"), n = e.clipboardData.getData("vscode-editor-data"), i = n ? JSON.parse(n) : void 0, s = i == null ? void 0 : i.mode; if (!t || !s) return !1; const { tr: u, schema: o } = r.state, l = o.text(t.replace(/\r\n?/g, `
`)); return u.replaceSelectionWith(this.type.create({ language: s }, l)), u.selection.$from.parent.type !== this.type && u.setSelection(T.near(u.doc.resolve(Math.max(0, u.selection.from - 2)))), u.setMeta("paste", !0), r.dispatch(u), !0
                }
            }
        })]
    }
}), Rh = ae.create({ name: "doc", topNode: !0, content: "block+" }); function Ih(r = {}) { return new ue({ view(e) { return new Ph(e, r) } }) } class Ph { constructor(e, t) { var n; this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (n = t.width) !== null && n !== void 0 ? n : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(i => { let s = u => { this[i](u) }; return e.dom.addEventListener(i, s), { name: i, handler: s } }) } destroy() { this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t)) } update(e, t) { this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay()) } setCursor(e) { e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay()) } updateOverlay() { let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, n, i = this.editorView.dom, s = i.getBoundingClientRect(), u = s.width / i.offsetWidth, o = s.height / i.offsetHeight; if (t) { let d = e.nodeBefore, f = e.nodeAfter; if (d || f) { let h = this.editorView.nodeDOM(this.cursorPos - (d ? d.nodeSize : 0)); if (h) { let p = h.getBoundingClientRect(), m = d ? p.bottom : p.top; d && f && (m = (m + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2); let g = this.width / 2 * o; n = { left: p.left, right: p.right, top: m - g, bottom: m + g } } } } if (!n) { let d = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * u; n = { left: d.left - f, right: d.left + f, top: d.top, bottom: d.bottom } } let l = this.editorView.dom.offsetParent; this.element || (this.element = l.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t); let a, c; if (!l || l == document.body && getComputedStyle(l).position == "static") a = -pageXOffset, c = -pageYOffset; else { let d = l.getBoundingClientRect(), f = d.width / l.offsetWidth, h = d.height / l.offsetHeight; a = d.left - l.scrollLeft * f, c = d.top - l.scrollTop * h } this.element.style.left = (n.left - a) / u + "px", this.element.style.top = (n.top - c) / o + "px", this.element.style.width = (n.right - n.left) / u + "px", this.element.style.height = (n.bottom - n.top) / o + "px" } scheduleRemoval(e) { clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e) } dragover(e) { if (!this.editorView.editable) return; let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), n = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = n && n.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, t, e) : i; if (t && !s) { let u = t.pos; if (this.editorView.dragging && this.editorView.dragging.slice) { let o = Ru(this.editorView.state.doc, u, this.editorView.dragging.slice); o != null && (u = o) } this.setCursor(u), this.scheduleRemoval(5e3) } } dragend() { this.scheduleRemoval(20) } drop() { this.scheduleRemoval(20) } dragleave(e) { this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null) } } const Lh = J.create({ name: "dropCursor", addOptions() { return { color: "currentColor", width: 1, class: void 0 } }, addProseMirrorPlugins() { return [Ih(this.options)] } }); class z extends M { constructor(e) { super(e, e) } map(e, t) { let n = e.resolve(t.map(this.head)); return z.valid(n) ? new z(n) : M.near(n) } content() { return x.empty } eq(e) { return e instanceof z && e.head == this.head } toJSON() { return { type: "gapcursor", pos: this.head } } static fromJSON(e, t) { if (typeof t.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON"); return new z(e.resolve(t.pos)) } getBookmark() { return new wi(this.anchor) } static valid(e) { let t = e.parent; if (t.isTextblock || !Bh(e) || !zh(e)) return !1; let n = t.type.spec.allowGapCursor; if (n != null) return n; let i = t.contentMatchAt(e.index()).defaultType; return i && i.isTextblock } static findGapCursorFrom(e, t, n = !1) { e: for (; ;) { if (!n && z.valid(e)) return e; let i = e.pos, s = null; for (let u = e.depth; ; u--) { let o = e.node(u); if (t > 0 ? e.indexAfter(u) < o.childCount : e.index(u) > 0) { s = o.child(t > 0 ? e.indexAfter(u) : e.index(u) - 1); break } else if (u == 0) return null; i += t; let l = e.doc.resolve(i); if (z.valid(l)) return l } for (; ;) { let u = t > 0 ? s.firstChild : s.lastChild; if (!u) { if (s.isAtom && !s.isText && !S.isSelectable(s)) { e = e.doc.resolve(i + s.nodeSize * t), n = !1; continue e } break } s = u, i += t; let o = e.doc.resolve(i); if (z.valid(o)) return o } return null } } } z.prototype.visible = !1; z.findFrom = z.findGapCursorFrom; M.jsonID("gapcursor", z); class wi { constructor(e) { this.pos = e } map(e) { return new wi(e.map(this.pos)) } resolve(e) { let t = e.resolve(this.pos); return z.valid(t) ? new z(t) : M.near(t) } } function Bh(r) { for (let e = r.depth; e >= 0; e--) { let t = r.index(e), n = r.node(e); if (t == 0) { if (n.type.spec.isolating) return !0; continue } for (let i = n.child(t - 1); ; i = i.lastChild) { if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating) return !0; if (i.inlineContent) return !1 } } return !0 } function zh(r) { for (let e = r.depth; e >= 0; e--) { let t = r.indexAfter(e), n = r.node(e); if (t == n.childCount) { if (n.type.spec.isolating) return !0; continue } for (let i = n.child(t); ; i = i.firstChild) { if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating) return !0; if (i.inlineContent) return !1 } } return !0 } function $h() { return new ue({ props: { decorations: qh, createSelectionBetween(r, e, t) { return e.pos == t.pos && z.valid(t) ? new z(t) : null }, handleClick: Fh, handleKeyDown: _h, handleDOMEvents: { beforeinput: Vh } } }) } const _h = ko({ ArrowLeft: gn("horiz", -1), ArrowRight: gn("horiz", 1), ArrowUp: gn("vert", -1), ArrowDown: gn("vert", 1) }); function gn(r, e) { const t = r == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left"; return function (n, i, s) { let u = n.selection, o = e > 0 ? u.$to : u.$from, l = u.empty; if (u instanceof T) { if (!s.endOfTextblock(t) || o.depth == 0) return !1; l = !1, o = n.doc.resolve(e > 0 ? o.after() : o.before()) } let a = z.findGapCursorFrom(o, e, l); return a ? (i && i(n.tr.setSelection(new z(a))), !0) : !1 } } function Fh(r, e, t) { if (!r || !r.editable) return !1; let n = r.state.doc.resolve(e); if (!z.valid(n)) return !1; let i = r.posAtCoords({ left: t.clientX, top: t.clientY }); return i && i.inside > -1 && S.isSelectable(r.state.doc.nodeAt(i.inside)) ? !1 : (r.dispatch(r.state.tr.setSelection(new z(n))), !0) } function Vh(r, e) { if (e.inputType != "insertCompositionText" || !(r.state.selection instanceof z)) return !1; let { $from: t } = r.state.selection, n = t.parent.contentMatchAt(t.index()).findWrapping(r.state.schema.nodes.text); if (!n) return !1; let i = y.empty; for (let u = n.length - 1; u >= 0; u--)i = y.from(n[u].createAndFill(null, i)); let s = r.state.tr.replace(t.pos, t.pos, new x(i, 0, 0)); return s.setSelection(T.near(s.doc.resolve(t.pos + 1))), r.dispatch(s), !1 } function qh(r) { if (!(r.selection instanceof z)) return null; let e = document.createElement("div"); return e.className = "ProseMirror-gapcursor", _.create(r.doc, [fe.widget(r.selection.head, e, { key: "gapcursor" })]) } const Hh = J.create({ name: "gapCursor", addProseMirrorPlugins() { return [$h()] }, extendNodeSchema(r) { var e; const t = { name: r.name, options: r.options, storage: r.storage }; return { allowGapCursor: (e = N(k(r, "allowGapCursor", t))) !== null && e !== void 0 ? e : null } } }), jh = ae.create({
    name: "hardBreak", addOptions() { return { keepMarks: !0, HTMLAttributes: {} } }, inline: !0, group: "inline", selectable: !1, linebreakReplacement: !0, parseHTML() { return [{ tag: "br" }] }, renderHTML({ HTMLAttributes: r }) { return ["br", Y(this.options.HTMLAttributes, r)] }, renderText() {
        return `
`}, addCommands() { return { setHardBreak: () => ({ commands: r, chain: e, state: t, editor: n }) => r.first([() => r.exitCode(), () => r.command(() => { const { selection: i, storedMarks: s } = t; if (i.$from.parent.type.spec.isolating) return !1; const { keepMarks: u } = this.options, { splittableMarks: o } = n.extensionManager, l = s || i.$to.parentOffset && i.$from.marks(); return e().insertContent({ type: this.name }).command(({ tr: a, dispatch: c }) => { if (c && l && u) { const d = l.filter(f => o.includes(f.type.name)); a.ensureMarks(d) } return !0 }).run() })]) } }, addKeyboardShortcuts() { return { "Mod-Enter": () => this.editor.commands.setHardBreak(), "Shift-Enter": () => this.editor.commands.setHardBreak() } }
}), Wh = ae.create({ name: "heading", addOptions() { return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} } }, content: "inline*", group: "block", defining: !0, addAttributes() { return { level: { default: 1, rendered: !1 } } }, parseHTML() { return this.options.levels.map(r => ({ tag: `h${r}`, attrs: { level: r } })) }, renderHTML({ node: r, HTMLAttributes: e }) { return [`h${this.options.levels.includes(r.attrs.level) ? r.attrs.level : this.options.levels[0]}`, Y(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setHeading: r => ({ commands: e }) => this.options.levels.includes(r.level) ? e.setNode(this.name, r) : !1, toggleHeading: r => ({ commands: e }) => this.options.levels.includes(r.level) ? e.toggleNode(this.name, "paragraph", r) : !1 } }, addKeyboardShortcuts() { return this.options.levels.reduce((r, e) => ({ ...r, [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e }) }), {}) }, addInputRules() { return this.options.levels.map(r => Ur({ find: new RegExp(`^(#{${Math.min(...this.options.levels)},${r}})\\s$`), type: this.type, getAttributes: { level: r } })) } }); var Bn = 200, W = function () { }; W.prototype.append = function (e) { return e.length ? (e = W.from(e), !this.length && e || e.length < Bn && this.leafAppend(e) || this.length < Bn && e.leafPrepend(this) || this.appendInner(e)) : this }; W.prototype.prepend = function (e) { return e.length ? W.from(e).append(this) : this }; W.prototype.appendInner = function (e) { return new Uh(this, e) }; W.prototype.slice = function (e, t) { return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? W.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t)) }; W.prototype.get = function (e) { if (!(e < 0 || e >= this.length)) return this.getInner(e) }; W.prototype.forEach = function (e, t, n) { t === void 0 && (t = 0), n === void 0 && (n = this.length), t <= n ? this.forEachInner(e, t, n, 0) : this.forEachInvertedInner(e, t, n, 0) }; W.prototype.map = function (e, t, n) { t === void 0 && (t = 0), n === void 0 && (n = this.length); var i = []; return this.forEach(function (s, u) { return i.push(e(s, u)) }, t, n), i }; W.from = function (e) { return e instanceof W ? e : e && e.length ? new jo(e) : W.empty }; var jo = function (r) { function e(n) { r.call(this), this.values = n } r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e; var t = { length: { configurable: !0 }, depth: { configurable: !0 } }; return e.prototype.flatten = function () { return this.values }, e.prototype.sliceInner = function (i, s) { return i == 0 && s == this.length ? this : new e(this.values.slice(i, s)) }, e.prototype.getInner = function (i) { return this.values[i] }, e.prototype.forEachInner = function (i, s, u, o) { for (var l = s; l < u; l++)if (i(this.values[l], o + l) === !1) return !1 }, e.prototype.forEachInvertedInner = function (i, s, u, o) { for (var l = s - 1; l >= u; l--)if (i(this.values[l], o + l) === !1) return !1 }, e.prototype.leafAppend = function (i) { if (this.length + i.length <= Bn) return new e(this.values.concat(i.flatten())) }, e.prototype.leafPrepend = function (i) { if (this.length + i.length <= Bn) return new e(i.flatten().concat(this.values)) }, t.length.get = function () { return this.values.length }, t.depth.get = function () { return 0 }, Object.defineProperties(e.prototype, t), e }(W); W.empty = new jo([]); var Uh = function (r) { function e(t, n) { r.call(this), this.left = t, this.right = n, this.length = t.length + n.length, this.depth = Math.max(t.depth, n.depth) + 1 } return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.flatten = function () { return this.left.flatten().concat(this.right.flatten()) }, e.prototype.getInner = function (n) { return n < this.left.length ? this.left.get(n) : this.right.get(n - this.left.length) }, e.prototype.forEachInner = function (n, i, s, u) { var o = this.left.length; if (i < o && this.left.forEachInner(n, i, Math.min(s, o), u) === !1 || s > o && this.right.forEachInner(n, Math.max(i - o, 0), Math.min(this.length, s) - o, u + o) === !1) return !1 }, e.prototype.forEachInvertedInner = function (n, i, s, u) { var o = this.left.length; if (i > o && this.right.forEachInvertedInner(n, i - o, Math.max(s, o) - o, u + o) === !1 || s < o && this.left.forEachInvertedInner(n, Math.min(i, o), s, u) === !1) return !1 }, e.prototype.sliceInner = function (n, i) { if (n == 0 && i == this.length) return this; var s = this.left.length; return i <= s ? this.left.slice(n, i) : n >= s ? this.right.slice(n - s, i - s) : this.left.slice(n, s).append(this.right.slice(0, i - s)) }, e.prototype.leafAppend = function (n) { var i = this.right.leafAppend(n); if (i) return new e(this.left, i) }, e.prototype.leafPrepend = function (n) { var i = this.left.leafPrepend(n); if (i) return new e(i, this.right) }, e.prototype.appendInner = function (n) { return this.left.depth >= Math.max(this.right.depth, n.depth) + 1 ? new e(this.left, new e(this.right, n)) : new e(this, n) }, e }(W); const Jh = 500; class xe { constructor(e, t) { this.items = e, this.eventCount = t } popEvent(e, t) { if (this.eventCount == 0) return null; let n = this.items.length; for (; ; n--)if (this.items.get(n - 1).selection) { --n; break } let i, s; t && (i = this.remapping(n, this.items.length), s = i.maps.length); let u = e.tr, o, l, a = [], c = []; return this.items.forEach((d, f) => { if (!d.step) { i || (i = this.remapping(n, f + 1), s = i.maps.length), s--, c.push(d); return } if (i) { c.push(new Ce(d.map)); let h = d.step.map(i.slice(s)), p; h && u.maybeStep(h).doc && (p = u.mapping.maps[u.mapping.maps.length - 1], a.push(new Ce(p, void 0, void 0, a.length + c.length))), s--, p && i.appendMap(p, s) } else u.maybeStep(d.step); if (d.selection) return o = i ? d.selection.map(i.slice(s)) : d.selection, l = new xe(this.items.slice(0, n).append(c.reverse().concat(a)), this.eventCount - 1), !1 }, this.items.length, 0), { remaining: l, transform: u, selection: o } } addTransform(e, t, n, i) { let s = [], u = this.eventCount, o = this.items, l = !i && o.length ? o.get(o.length - 1) : null; for (let c = 0; c < e.steps.length; c++) { let d = e.steps[c].invert(e.docs[c]), f = new Ce(e.mapping.maps[c], d, t), h; (h = l && l.merge(f)) && (f = h, c ? s.pop() : o = o.slice(0, o.length - 1)), s.push(f), t && (u++, t = void 0), i || (l = f) } let a = u - n.depth; return a > Gh && (o = Kh(o, a), u -= a), new xe(o.append(s), u) } remapping(e, t) { let n = new Kt; return this.items.forEach((i, s) => { let u = i.mirrorOffset != null && s - i.mirrorOffset >= e ? n.maps.length - i.mirrorOffset : void 0; n.appendMap(i.map, u) }, e, t), n } addMaps(e) { return this.eventCount == 0 ? this : new xe(this.items.append(e.map(t => new Ce(t))), this.eventCount) } rebased(e, t) { if (!this.eventCount) return this; let n = [], i = Math.max(0, this.items.length - t), s = e.mapping, u = e.steps.length, o = this.eventCount; this.items.forEach(f => { f.selection && o-- }, i); let l = t; this.items.forEach(f => { let h = s.getMirror(--l); if (h == null) return; u = Math.min(u, h); let p = s.maps[h]; if (f.step) { let m = e.steps[h].invert(e.docs[h]), g = f.selection && f.selection.map(s.slice(l + 1, h)); g && o++, n.push(new Ce(p, m, g)) } else n.push(new Ce(p)) }, i); let a = []; for (let f = t; f < u; f++)a.push(new Ce(s.maps[f])); let c = this.items.slice(0, i).append(a).append(n), d = new xe(c, o); return d.emptyItemCount() > Jh && (d = d.compress(this.items.length - n.length)), d } emptyItemCount() { let e = 0; return this.items.forEach(t => { t.step || e++ }), e } compress(e = this.items.length) { let t = this.remapping(0, e), n = t.maps.length, i = [], s = 0; return this.items.forEach((u, o) => { if (o >= e) i.push(u), u.selection && s++; else if (u.step) { let l = u.step.map(t.slice(n)), a = l && l.getMap(); if (n--, a && t.appendMap(a, n), l) { let c = u.selection && u.selection.map(t.slice(n)); c && s++; let d = new Ce(a.invert(), l, c), f, h = i.length - 1; (f = i.length && i[h].merge(d)) ? i[h] = f : i.push(d) } } else u.map && n-- }, this.items.length, 0), new xe(W.from(i.reverse()), s) } } xe.empty = new xe(W.empty, 0); function Kh(r, e) { let t; return r.forEach((n, i) => { if (n.selection && e-- == 0) return t = i, !1 }), r.slice(t) } class Ce { constructor(e, t, n, i) { this.map = e, this.step = t, this.selection = n, this.mirrorOffset = i } merge(e) { if (this.step && e.step && !e.selection) { let t = e.step.merge(this.step); if (t) return new Ce(t.getMap().invert(), t, this.selection) } } } class ze { constructor(e, t, n, i, s) { this.done = e, this.undone = t, this.prevRanges = n, this.prevTime = i, this.prevComposition = s } } const Gh = 20; function Zh(r, e, t, n) { let i = t.getMeta(at), s; if (i) return i.historyState; t.getMeta(Xh) && (r = new ze(r.done, r.undone, null, 0, -1)); let u = t.getMeta("appendedTransaction"); if (t.steps.length == 0) return r; if (u && u.getMeta(at)) return u.getMeta(at).redo ? new ze(r.done.addTransform(t, void 0, n, Sn(e)), r.undone, qs(t.mapping.maps), r.prevTime, r.prevComposition) : new ze(r.done, r.undone.addTransform(t, void 0, n, Sn(e)), null, r.prevTime, r.prevComposition); if (t.getMeta("addToHistory") !== !1 && !(u && u.getMeta("addToHistory") === !1)) { let o = t.getMeta("composition"), l = r.prevTime == 0 || !u && r.prevComposition != o && (r.prevTime < (t.time || 0) - n.newGroupDelay || !Qh(t, r.prevRanges)), a = u ? wr(r.prevRanges, t.mapping) : qs(t.mapping.maps); return new ze(r.done.addTransform(t, l ? e.selection.getBookmark() : void 0, n, Sn(e)), xe.empty, a, t.time, o ?? r.prevComposition) } else return (s = t.getMeta("rebased")) ? new ze(r.done.rebased(t, s), r.undone.rebased(t, s), wr(r.prevRanges, t.mapping), r.prevTime, r.prevComposition) : new ze(r.done.addMaps(t.mapping.maps), r.undone.addMaps(t.mapping.maps), wr(r.prevRanges, t.mapping), r.prevTime, r.prevComposition) } function Qh(r, e) { if (!e) return !1; if (!r.docChanged) return !0; let t = !1; return r.mapping.maps[0].forEach((n, i) => { for (let s = 0; s < e.length; s += 2)n <= e[s + 1] && i >= e[s] && (t = !0) }), t } function qs(r) { let e = []; for (let t = r.length - 1; t >= 0 && e.length == 0; t--)r[t].forEach((n, i, s, u) => e.push(s, u)); return e } function wr(r, e) { if (!r) return null; let t = []; for (let n = 0; n < r.length; n += 2) { let i = e.map(r[n], 1), s = e.map(r[n + 1], -1); i <= s && t.push(i, s) } return t } function Yh(r, e, t) { let n = Sn(e), i = at.get(e).spec.config, s = (t ? r.undone : r.done).popEvent(e, n); if (!s) return null; let u = s.selection.resolve(s.transform.doc), o = (t ? r.done : r.undone).addTransform(s.transform, e.selection.getBookmark(), i, n), l = new ze(t ? o : s.remaining, t ? s.remaining : o, null, 0, -1); return s.transform.setSelection(u).setMeta(at, { redo: t, historyState: l }) } let Sr = !1, Hs = null; function Sn(r) { let e = r.plugins; if (Hs != e) { Sr = !1, Hs = e; for (let t = 0; t < e.length; t++)if (e[t].spec.historyPreserveItems) { Sr = !0; break } } return Sr } const at = new Se("history"), Xh = new Se("closeHistory"); function e0(r = {}) { return r = { depth: r.depth || 100, newGroupDelay: r.newGroupDelay || 500 }, new ue({ key: at, state: { init() { return new ze(xe.empty, xe.empty, null, 0, -1) }, apply(e, t, n) { return Zh(t, n, e, r) } }, config: r, props: { handleDOMEvents: { beforeinput(e, t) { let n = t.inputType, i = n == "historyUndo" ? Uo : n == "historyRedo" ? Jo : null; return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1 } } } }) } function Wo(r, e) { return (t, n) => { let i = at.getState(t); if (!i || (r ? i.undone : i.done).eventCount == 0) return !1; if (n) { let s = Yh(i, t, r); s && n(e ? s.scrollIntoView() : s) } return !0 } } const Uo = Wo(!1, !0), Jo = Wo(!0, !0), t0 = J.create({ name: "history", addOptions() { return { depth: 100, newGroupDelay: 500 } }, addCommands() { return { undo: () => ({ state: r, dispatch: e }) => Uo(r, e), redo: () => ({ state: r, dispatch: e }) => Jo(r, e) } }, addProseMirrorPlugins() { return [e0(this.options)] }, addKeyboardShortcuts() { return { "Mod-z": () => this.editor.commands.undo(), "Shift-Mod-z": () => this.editor.commands.redo(), "Mod-y": () => this.editor.commands.redo(), "Mod-": () => this.editor.commands.undo(), "Shift-Mod-": () => this.editor.commands.redo() } } }), n0 = ae.create({ name: "horizontalRule", addOptions() { return { HTMLAttributes: {} } }, group: "block", parseHTML() { return [{ tag: "hr" }] }, renderHTML({ HTMLAttributes: r }) { return ["hr", Y(this.options.HTMLAttributes, r)] }, addCommands() { return { setHorizontalRule: () => ({ chain: r, state: e }) => { if (!gh(e, e.schema.nodes[this.name])) return !1; const { selection: t } = e, { $from: n, $to: i } = t, s = r(); return n.parentOffset === 0 ? s.insertContentAt({ from: Math.max(n.pos - 1, 0), to: i.pos }, { type: this.name }) : zf(t) ? s.insertContentAt(i.pos, { type: this.name }) : s.insertContent({ type: this.name }), s.command(({ tr: u, dispatch: o }) => { var l; if (o) { const { $to: a } = u.selection, c = a.end(); if (a.nodeAfter) a.nodeAfter.isTextblock ? u.setSelection(T.create(u.doc, a.pos + 1)) : a.nodeAfter.isBlock ? u.setSelection(S.create(u.doc, a.pos)) : u.setSelection(T.create(u.doc, a.pos)); else { const d = (l = a.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create(); d && (u.insert(c, d), u.setSelection(T.create(u.doc, c + 1))) } u.scrollIntoView() } return !0 }).run() } } }, addInputRules() { return [mh({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type })] } }), r0 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, i0 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, s0 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, u0 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, o0 = we.create({ name: "italic", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "em" }, { tag: "i", getAttrs: r => r.style.fontStyle !== "normal" && null }, { style: "font-style=normal", clearMark: r => r.type.name === this.name }, { style: "font-style=italic" }] }, renderHTML({ HTMLAttributes: r }) { return ["em", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { setItalic: () => ({ commands: r }) => r.setMark(this.name), toggleItalic: () => ({ commands: r }) => r.toggleMark(this.name), unsetItalic: () => ({ commands: r }) => r.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-i": () => this.editor.commands.toggleItalic(), "Mod-I": () => this.editor.commands.toggleItalic() } }, addInputRules() { return [Dt({ find: r0, type: this.type }), Dt({ find: s0, type: this.type })] }, addPasteRules() { return [Rt({ find: i0, type: this.type }), Rt({ find: u0, type: this.type })] } }), l0 = ae.create({ name: "listItem", addOptions() { return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" } }, content: "paragraph block*", defining: !0, parseHTML() { return [{ tag: "li" }] }, renderHTML({ HTMLAttributes: r }) { return ["li", Y(this.options.HTMLAttributes, r), 0] }, addKeyboardShortcuts() { return { Enter: () => this.editor.commands.splitListItem(this.name), Tab: () => this.editor.commands.sinkListItem(this.name), "Shift-Tab": () => this.editor.commands.liftListItem(this.name) } } }), a0 = "listItem", js = "textStyle", Ws = /^(\d+)\.\s$/, c0 = ae.create({ name: "orderedList", addOptions() { return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 } }, group: "block list", content() { return `${this.options.itemTypeName}+` }, addAttributes() { return { start: { default: 1, parseHTML: r => r.hasAttribute("start") ? parseInt(r.getAttribute("start") || "", 10) : 1 }, type: { default: null, parseHTML: r => r.getAttribute("type") } } }, parseHTML() { return [{ tag: "ol" }] }, renderHTML({ HTMLAttributes: r }) { const { start: e, ...t } = r; return e === 1 ? ["ol", Y(this.options.HTMLAttributes, t), 0] : ["ol", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { toggleOrderedList: () => ({ commands: r, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(a0, this.editor.getAttributes(js)).run() : r.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) } }, addKeyboardShortcuts() { return { "Mod-Shift-7": () => this.editor.commands.toggleOrderedList() } }, addInputRules() { let r = tn({ find: Ws, type: this.type, getAttributes: e => ({ start: +e[1] }), joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1] }); return (this.options.keepMarks || this.options.keepAttributes) && (r = tn({ find: Ws, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: e => ({ start: +e[1], ...this.editor.getAttributes(js) }), joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1], editor: this.editor })), [r] } }), d0 = ae.create({ name: "paragraph", priority: 1e3, addOptions() { return { HTMLAttributes: {} } }, group: "block", content: "inline*", parseHTML() { return [{ tag: "p" }] }, renderHTML({ HTMLAttributes: r }) { return ["p", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { setParagraph: () => ({ commands: r }) => r.setNode(this.name) } }, addKeyboardShortcuts() { return { "Mod-Alt-0": () => this.editor.commands.setParagraph() } } }), f0 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, h0 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, p0 = we.create({ name: "strike", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "s" }, { tag: "del" }, { tag: "strike" }, { style: "text-decoration", consuming: !1, getAttrs: r => r.includes("line-through") ? {} : !1 }] }, renderHTML({ HTMLAttributes: r }) { return ["s", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { setStrike: () => ({ commands: r }) => r.setMark(this.name), toggleStrike: () => ({ commands: r }) => r.toggleMark(this.name), unsetStrike: () => ({ commands: r }) => r.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-s": () => this.editor.commands.toggleStrike() } }, addInputRules() { return [Dt({ find: f0, type: this.type })] }, addPasteRules() { return [Rt({ find: h0, type: this.type })] } }), m0 = ae.create({ name: "text", group: "inline" }), g0 = J.create({ name: "starterKit", addExtensions() { const r = []; return this.options.bold !== !1 && r.push(Ch.configure(this.options.bold)), this.options.blockquote !== !1 && r.push(yh.configure(this.options.blockquote)), this.options.bulletList !== !1 && r.push(Eh.configure(this.options.bulletList)), this.options.code !== !1 && r.push(Ah.configure(this.options.code)), this.options.codeBlock !== !1 && r.push(Dh.configure(this.options.codeBlock)), this.options.document !== !1 && r.push(Rh.configure(this.options.document)), this.options.dropcursor !== !1 && r.push(Lh.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && r.push(Hh.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && r.push(jh.configure(this.options.hardBreak)), this.options.heading !== !1 && r.push(Wh.configure(this.options.heading)), this.options.history !== !1 && r.push(t0.configure(this.options.history)), this.options.horizontalRule !== !1 && r.push(n0.configure(this.options.horizontalRule)), this.options.italic !== !1 && r.push(o0.configure(this.options.italic)), this.options.listItem !== !1 && r.push(l0.configure(this.options.listItem)), this.options.orderedList !== !1 && r.push(c0.configure(this.options.orderedList)), this.options.paragraph !== !1 && r.push(d0.configure(this.options.paragraph)), this.options.strike !== !1 && r.push(p0.configure(this.options.strike)), this.options.text !== !1 && r.push(m0.configure(this.options.text)), r } }), b0 = J.create({ name: "placeholder", addOptions() { return { emptyEditorClass: "is-editor-empty", emptyNodeClass: "is-empty", placeholder: "Write something ", showOnlyWhenEditable: !0, showOnlyCurrent: !0, includeChildren: !1 } }, addProseMirrorPlugins() { return [new ue({ key: new Se("placeholder"), props: { decorations: ({ doc: r, selection: e }) => { const t = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: n } = e, i = []; if (!t) return null; const s = this.editor.isEmpty; return r.descendants((u, o) => { const l = n >= o && n <= o + u.nodeSize, a = !u.isLeaf && er(u); if ((l || !this.options.showOnlyCurrent) && a) { const c = [this.options.emptyNodeClass]; s && c.push(this.options.emptyEditorClass); const d = fe.node(o, o + u.nodeSize, { class: c.join(" "), "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({ editor: this.editor, node: u, pos: o, hasAnchor: l }) : this.options.placeholder }); i.push(d) } return this.options.includeChildren }), _.create(r, i) } } })] } }); we.create({ name: "underline", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "u" }, { style: "text-decoration", consuming: !1, getAttrs: r => r.includes("underline") ? {} : !1 }] }, renderHTML({ HTMLAttributes: r }) { return ["u", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { setUnderline: () => ({ commands: r }) => r.setMark(this.name), toggleUnderline: () => ({ commands: r }) => r.toggleMark(this.name), unsetUnderline: () => ({ commands: r }) => r.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-u": () => this.editor.commands.toggleUnderline(), "Mod-U": () => this.editor.commands.toggleUnderline() } } }); const y0 = r => { if (!r.children.length) return; const e = r.querySelectorAll("span"); e && e.forEach(t => { var n, i; const s = t.getAttribute("style"), u = (i = (n = t.parentElement) === null || n === void 0 ? void 0 : n.closest("span")) === null || i === void 0 ? void 0 : i.getAttribute("style"); t.setAttribute("style", `${u};${s}`) }) }, x0 = we.create({ name: "textStyle", priority: 101, addOptions() { return { HTMLAttributes: {}, mergeNestedSpanStyles: !1 } }, parseHTML() { return [{ tag: "span", getAttrs: r => r.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && y0(r), {}) : !1 }] }, renderHTML({ HTMLAttributes: r }) { return ["span", Y(this.options.HTMLAttributes, r), 0] }, addCommands() { return { removeEmptyTextStyle: () => ({ tr: r }) => { const { selection: e } = r; return r.doc.nodesBetween(e.from, e.to, (t, n) => { if (t.isTextblock) return !0; t.marks.filter(i => i.type === this.type).some(i => Object.values(i.attrs).some(s => !!s)) || r.removeMark(n, n + t.nodeSize, this.type) }), !0 } } } }), k0 = J.create({ name: "color", addOptions() { return { types: ["textStyle"] } }, addGlobalAttributes() { return [{ types: this.options.types, attributes: { color: { default: null, parseHTML: r => { var e; return (e = r.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "") }, renderHTML: r => r.color ? { style: `color: ${r.color}` } : {} } } }] }, addCommands() { return { setColor: r => ({ chain: e }) => e().setMark("textStyle", { color: r }).run(), unsetColor: () => ({ chain: r }) => r().setMark("textStyle", { color: null }).removeEmptyTextStyle().run() } } }), w0 = J.create({ name: "textAlign", addOptions() { return { types: [], alignments: ["left", "center", "right", "justify"], defaultAlignment: null } }, addGlobalAttributes() { return [{ types: this.options.types, attributes: { textAlign: { default: this.options.defaultAlignment, parseHTML: r => { const e = r.style.textAlign; return this.options.alignments.includes(e) ? e : this.options.defaultAlignment }, renderHTML: r => r.textAlign ? { style: `text-align: ${r.textAlign}` } : {} } } }] }, addCommands() { return { setTextAlign: r => ({ commands: e }) => this.options.alignments.includes(r) ? this.options.types.map(t => e.updateAttributes(t, { textAlign: r })).every(t => t) : !1, unsetTextAlign: () => ({ commands: r }) => this.options.types.map(e => r.resetAttributes(e, "textAlign")).every(e => e), toggleTextAlign: r => ({ editor: e, commands: t }) => this.options.alignments.includes(r) ? e.isActive({ textAlign: r }) ? t.unsetTextAlign() : t.setTextAlign(r) : !1 } }, addKeyboardShortcuts() { return { "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"), "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"), "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"), "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify") } } }), S0 = new Uint16Array('<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(r => r.charCodeAt(0))), C0 = new Uint16Array("aglq	\x1B\0\0p;os;t;t;uot;".split("").map(r => r.charCodeAt(0))); var Cr; const T0 = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]), E0 = (Cr = String.fromCodePoint) !== null && Cr !== void 0 ? Cr : function (r) { let e = ""; return r > 65535 && (r -= 65536, e += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), e += String.fromCharCode(r), e }; function M0(r) { var e; return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (e = T0.get(r)) !== null && e !== void 0 ? e : r } var H; (function (r) { r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z" })(H || (H = {})); const N0 = 32; var He; (function (r) { r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE" })(He || (He = {})); function Jr(r) { return r >= H.ZERO && r <= H.NINE } function A0(r) { return r >= H.UPPER_A && r <= H.UPPER_F || r >= H.LOWER_A && r <= H.LOWER_F } function O0(r) { return r >= H.UPPER_A && r <= H.UPPER_Z || r >= H.LOWER_A && r <= H.LOWER_Z || Jr(r) } function v0(r) { return r === H.EQUALS || O0(r) } var V; (function (r) { r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity" })(V || (V = {})); var _e; (function (r) { r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute" })(_e || (_e = {})); class D0 { constructor(e, t, n) { this.decodeTree = e, this.emitCodePoint = t, this.errors = n, this.state = V.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = _e.Strict } startEntity(e) { this.decodeMode = e, this.state = V.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1 } write(e, t) { switch (this.state) { case V.EntityStart: return e.charCodeAt(t) === H.NUM ? (this.state = V.NumericStart, this.consumed += 1, this.stateNumericStart(e, t + 1)) : (this.state = V.NamedEntity, this.stateNamedEntity(e, t)); case V.NumericStart: return this.stateNumericStart(e, t); case V.NumericDecimal: return this.stateNumericDecimal(e, t); case V.NumericHex: return this.stateNumericHex(e, t); case V.NamedEntity: return this.stateNamedEntity(e, t) } } stateNumericStart(e, t) { return t >= e.length ? -1 : (e.charCodeAt(t) | N0) === H.LOWER_X ? (this.state = V.NumericHex, this.consumed += 1, this.stateNumericHex(e, t + 1)) : (this.state = V.NumericDecimal, this.stateNumericDecimal(e, t)) } addToNumericResult(e, t, n, i) { if (t !== n) { const s = n - t; this.result = this.result * Math.pow(i, s) + Number.parseInt(e.substr(t, s), i), this.consumed += s } } stateNumericHex(e, t) { const n = t; for (; t < e.length;) { const i = e.charCodeAt(t); if (Jr(i) || A0(i)) t += 1; else return this.addToNumericResult(e, n, t, 16), this.emitNumericEntity(i, 3) } return this.addToNumericResult(e, n, t, 16), -1 } stateNumericDecimal(e, t) { const n = t; for (; t < e.length;) { const i = e.charCodeAt(t); if (Jr(i)) t += 1; else return this.addToNumericResult(e, n, t, 10), this.emitNumericEntity(i, 2) } return this.addToNumericResult(e, n, t, 10), -1 } emitNumericEntity(e, t) { var n; if (this.consumed <= t) return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; if (e === H.SEMI) this.consumed += 1; else if (this.decodeMode === _e.Strict) return 0; return this.emitCodePoint(M0(this.result), this.consumed), this.errors && (e !== H.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed } stateNamedEntity(e, t) { const { decodeTree: n } = this; let i = n[this.treeIndex], s = (i & He.VALUE_LENGTH) >> 14; for (; t < e.length; t++, this.excess++) { const u = e.charCodeAt(t); if (this.treeIndex = R0(n, i, this.treeIndex + Math.max(1, s), u), this.treeIndex < 0) return this.result === 0 || this.decodeMode === _e.Attribute && (s === 0 || v0(u)) ? 0 : this.emitNotTerminatedNamedEntity(); if (i = n[this.treeIndex], s = (i & He.VALUE_LENGTH) >> 14, s !== 0) { if (u === H.SEMI) return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess); this.decodeMode !== _e.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0) } } return -1 } emitNotTerminatedNamedEntity() { var e; const { result: t, decodeTree: n } = this, i = (n[t] & He.VALUE_LENGTH) >> 14; return this.emitNamedEntityData(t, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed } emitNamedEntityData(e, t, n) { const { decodeTree: i } = this; return this.emitCodePoint(t === 1 ? i[e] & ~He.VALUE_LENGTH : i[e + 1], n), t === 3 && this.emitCodePoint(i[e + 2], n), n } end() { var e; switch (this.state) { case V.NamedEntity: return this.result !== 0 && (this.decodeMode !== _e.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0; case V.NumericDecimal: return this.emitNumericEntity(0, 2); case V.NumericHex: return this.emitNumericEntity(0, 3); case V.NumericStart: return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; case V.EntityStart: return 0 } } } function Ko(r) { let e = ""; const t = new D0(r, n => e += E0(n)); return function (i, s) { let u = 0, o = 0; for (; (o = i.indexOf("&", o)) >= 0;) { e += i.slice(u, o), t.startEntity(s); const a = t.write(i, o + 1); if (a < 0) { u = o + t.end(); break } u = o + a, o = a === 0 ? u + 1 : u } const l = e + i.slice(u); return e = "", l } } function R0(r, e, t, n) { const i = (e & He.BRANCH_LENGTH) >> 7, s = e & He.JUMP_TABLE; if (i === 0) return s !== 0 && n === s ? t : -1; if (s) { const l = n - s; return l < 0 || l >= i ? -1 : r[t + l] - 1 } let u = t, o = u + i - 1; for (; u <= o;) { const l = u + o >>> 1, a = r[l]; if (a < n) u = l + 1; else if (a > n) o = l - 1; else return r[l + i] } return -1 } const I0 = Ko(S0); Ko(C0); function P0(r, e = _e.Legacy) { return I0(r, e) } var B; (function (r) { r.Attribute = "attribute", r.Pseudo = "pseudo", r.PseudoElement = "pseudo-element", r.Tag = "tag", r.Universal = "universal", r.Adjacent = "adjacent", r.Child = "child", r.Descendant = "descendant", r.Parent = "parent", r.Sibling = "sibling", r.ColumnCombinator = "column-combinator" })(B || (B = {})); var me; (function (r) { r.Any = "any", r.Element = "element", r.End = "end", r.Equals = "equals", r.Exists = "exists", r.Hyphen = "hyphen", r.Not = "not", r.Start = "start" })(me || (me = {})); const Us = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, L0 = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, B0 = new Map([[126, me.Element], [94, me.Start], [36, me.End], [42, me.Any], [33, me.Not], [124, me.Hyphen]]), z0 = new Set(["has", "not", "matches", "is", "where", "host", "host-context"]); function $0(r) { switch (r.type) { case B.Adjacent: case B.Child: case B.Descendant: case B.Parent: case B.Sibling: case B.ColumnCombinator: return !0; default: return !1 } } const _0 = new Set(["contains", "icontains"]); function F0(r, e, t) { const n = parseInt(e, 16) - 65536; return n !== n || t ? e : n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, n & 1023 | 56320) } function Lt(r) { return r.replace(L0, F0) } function Tr(r) { return r === 39 || r === 34 } function Js(r) { return r === 32 || r === 9 || r === 10 || r === 12 || r === 13 } function V0(r) { const e = [], t = Go(e, `${r}`, 0); if (t < r.length) throw new Error(`Unmatched selector: ${r.slice(t)}`); return e } function Go(r, e, t) { let n = []; function i(f) { const h = e.slice(t + f).match(Us); if (!h) throw new Error(`Expected name, found ${e.slice(t)}`); const [p] = h; return t += f + p.length, Lt(p) } function s(f) { for (t += f; t < e.length && Js(e.charCodeAt(t));)t++ } function u() { t += 1; const f = t; let h = 1; for (; h > 0 && t < e.length; t++)e.charCodeAt(t) === 40 && !o(t) ? h++ : e.charCodeAt(t) === 41 && !o(t) && h--; if (h) throw new Error("Parenthesis not matched"); return Lt(e.slice(f, t - 1)) } function o(f) { let h = 0; for (; e.charCodeAt(--f) === 92;)h++; return (h & 1) === 1 } function l() { if (n.length > 0 && $0(n[n.length - 1])) throw new Error("Did not expect successive traversals.") } function a(f) { if (n.length > 0 && n[n.length - 1].type === B.Descendant) { n[n.length - 1].type = f; return } l(), n.push({ type: f }) } function c(f, h) { n.push({ type: B.Attribute, name: f, action: h, value: i(1), namespace: null, ignoreCase: "quirks" }) } function d() { if (n.length && n[n.length - 1].type === B.Descendant && n.pop(), n.length === 0) throw new Error("Empty sub-selector"); r.push(n) } if (s(0), e.length === t) return t; e: for (; t < e.length;) { const f = e.charCodeAt(t); switch (f) { case 32: case 9: case 10: case 12: case 13: { (n.length === 0 || n[0].type !== B.Descendant) && (l(), n.push({ type: B.Descendant })), s(1); break } case 62: { a(B.Child), s(1); break } case 60: { a(B.Parent), s(1); break } case 126: { a(B.Sibling), s(1); break } case 43: { a(B.Adjacent), s(1); break } case 46: { c("class", me.Element); break } case 35: { c("id", me.Equals); break } case 91: { s(1); let h, p = null; e.charCodeAt(t) === 124 ? h = i(1) : e.startsWith("*|", t) ? (p = "*", h = i(2)) : (h = i(0), e.charCodeAt(t) === 124 && e.charCodeAt(t + 1) !== 61 && (p = h, h = i(1))), s(0); let m = me.Exists; const g = B0.get(e.charCodeAt(t)); if (g) { if (m = g, e.charCodeAt(t + 1) !== 61) throw new Error("Expected `=`"); s(2) } else e.charCodeAt(t) === 61 && (m = me.Equals, s(1)); let b = "", w = null; if (m !== "exists") { if (Tr(e.charCodeAt(t))) { const A = e.charCodeAt(t); let I = t + 1; for (; I < e.length && (e.charCodeAt(I) !== A || o(I));)I += 1; if (e.charCodeAt(I) !== A) throw new Error("Attribute value didn't end"); b = Lt(e.slice(t + 1, I)), t = I + 1 } else { const A = t; for (; t < e.length && (!Js(e.charCodeAt(t)) && e.charCodeAt(t) !== 93 || o(t));)t += 1; b = Lt(e.slice(A, t)) } s(0); const O = e.charCodeAt(t) | 32; O === 115 ? (w = !1, s(1)) : O === 105 && (w = !0, s(1)) } if (e.charCodeAt(t) !== 93) throw new Error("Attribute selector didn't terminate"); t += 1; const C = { type: B.Attribute, name: h, action: m, value: b, namespace: p, ignoreCase: w }; n.push(C); break } case 58: { if (e.charCodeAt(t + 1) === 58) { n.push({ type: B.PseudoElement, name: i(2).toLowerCase(), data: e.charCodeAt(t) === 40 ? u() : null }); continue } const h = i(1).toLowerCase(); let p = null; if (e.charCodeAt(t) === 40) if (z0.has(h)) { if (Tr(e.charCodeAt(t + 1))) throw new Error(`Pseudo-selector ${h} cannot be quoted`); if (p = [], t = Go(p, e, t + 1), e.charCodeAt(t) !== 41) throw new Error(`Missing closing parenthesis in :${h} (${e})`); t += 1 } else { if (p = u(), _0.has(h)) { const m = p.charCodeAt(0); m === p.charCodeAt(p.length - 1) && Tr(m) && (p = p.slice(1, -1)) } p = Lt(p) } n.push({ type: B.Pseudo, name: h, data: p }); break } case 44: { d(), n = [], s(1); break } default: { if (e.startsWith("/*", t)) { const m = e.indexOf("*/", t + 2); if (m < 0) throw new Error("Comment was not terminated"); t = m + 2, n.length === 0 && s(0); break } let h = null, p; if (f === 42) t += 1, p = "*"; else if (f === 124) { if (p = "", e.charCodeAt(t + 1) === 124) { a(B.ColumnCombinator), s(2); break } } else if (Us.test(e.slice(t))) p = i(0); else break e; e.charCodeAt(t) === 124 && e.charCodeAt(t + 1) !== 124 && (h = p, e.charCodeAt(t + 1) === 42 ? (p = "*", t += 2) : p = i(1)), n.push(p === "*" ? { type: B.Universal, namespace: h } : { type: B.Tag, name: p, namespace: h }) } } } return d(), t } function Kr(r) { return r.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;").replace(/\xA0/g, "&nbsp;").replace(/\xAD/g, "&shy;") } var Ks = r => P0(r); function q0(r, e, t, n) { if (typeof e == "function") return e({ props: { ...t, children: n }, attrs: t, children: n, h: r.h, context: r }); { let i = !0, s; if (e ? e.toLowerCase() === "fragment" ? (s = r.document.createDocumentFragment(), i = !1) : s = r.document.createElement(e) : s = r.document.createElement("div"), t && i) { const u = s; for (let [o, l] of Object.entries(t)) { o = o.toString(); const a = o.toLowerCase(); a === "classname" ? u.className = l : a === "on" ? Object.entries(l).forEach(([c, d]) => { u.setAttribute(`on${c}`, String(d)) }) : l !== !1 && l != null && (l === !0 ? u.setAttribute(o, o) : u.setAttribute(o, l.toString())) } } if (n) for (const u of n) { const o = Array.isArray(u) ? [...u] : [u]; for (const l of o) l && l !== !1 && l != null && (typeof l != "object" ? s.appendChild(r.document.createTextNode(l.toString())) : s.appendChild(l)) } return s } } function Zo(r, e, ...t) { return typeof r == "object" && (r = "fragment", t = r.children, e = r.attrs), Array.isArray(e) ? (t = [e], e = {}) : e ? e.attrs && (e = { ...e.attrs, ...e }, delete e.attrs) : e = {}, { tag: r, attrs: e, children: typeof t[0] == "string" ? t : t.flat(Number.POSITIVE_INFINITY) } } function H0(r) { return r.h = function (t, n, ...i) { const { tag: s, attrs: u, children: o } = Zo(t, n, i); return q0(r, s, u, o) }, r.h } var Gs = {}; function j0(r) { let e = Gs[r]; return e == null && (e = V0(r), Gs[r] = e), e } function W0(r, e, { debug: t = !1 } = {}) { for (const n of j0(r)) { const i = (s, u) => { var l, a, c, d; let o = !1; for (const f of u) { const { type: h, name: p, action: m, value: g, _ignoreCase: b = !0, data: w } = f; if (h === "attribute") m === "equals" ? o = s.getAttribute(p) === g : m === "start" ? o = !!((l = s.getAttribute(p)) != null && l.startsWith(g)) : m === "end" ? o = !!((a = s.getAttribute(p)) != null && a.endsWith(g)) : m === "element" ? p === "class" ? o = s.classList.contains(g) : o = !!((c = s.getAttribute(p)) != null && c.includes(g)) : m === "exists" ? o = s.hasAttribute(p) : m === "any" ? o = !!((d = s.getAttribute(p)) != null && d.includes(g)) : console.warn("Unknown CSS selector action", m); else if (h === "tag") o = s.tagName === p.toUpperCase(); else if (h === "universal") o = !0; else if (h === "pseudo") { if (p === "not") { let C = !0; w.forEach(O => { i(s, O) || (C = !1) }), o = !C } } else console.warn("Unknown CSS selector type", h, r, u); if (!o) break } return o }; if (i(e, n)) return !0 } return !1 } var U0 = Symbol.for("nodejs.util.inspect.custom"), Zs = { fontWeight: "bold" }, Qs = { fontStyle: "italic" }, Ys = { backgroundColor: "rgb(255, 250, 165)" }, Xs = { textDecorations: "underline" }, Er = { textDecorations: "line-through" }, J0 = { b: Zs, strong: Zs, em: Qs, i: Qs, mark: Ys, u: Xs, a: Xs, s: Er, del: Er, ins: Ys, strike: Er }; function eu(r) { return r.toLowerCase().replace(/[^a-z0-9]+(.)/gi, (e, t) => t.toUpperCase()) } var Pe = class Cn { constructor() { this.append = this.appendChild, this._parentNode = null, this._childNodes = [] } get nodeType() { return console.error("Subclasses should define nodeType!"), 0 } get nodeName() { return console.error("Subclasses should define nodeName!"), "" } get nodeValue() { return null } cloneNode(e = !1) { const t = new this.constructor; return e && (t._childNodes = this._childNodes.map(n => n.cloneNode(!0)), t._fixChildNodesParent()), t } _fixChildNodesParent() { this._childNodes.forEach(e => e._parentNode = this) } insertBefore(e, t) { if (e !== t) { let n = t ? this._childNodes.indexOf(t) : 0; n < 0 && (n = 0), this._childNodes.splice(n, 0, e), this._fixChildNodesParent() } } appendChild(e) { if (e != null) { if (e === this) { console.warn("Cannot appendChild to self"); return } if (e instanceof Ci && console.warn("No defined how to append a document to a node!", e), e instanceof Si) for (const t of [...e._childNodes]) this.appendChild(t); else if (Array.isArray(e)) for (const t of [...e]) this.appendChild(t); else if (e instanceof Cn) e.remove(), this._childNodes.push(e); else try { const t = typeof e == "string" ? e : JSON.stringify(e, null, 2); this._childNodes.push(new Tt(t)) } catch (t) { console.error(`The data ${e} to be added to ${this.render()} is problematic: ${t}`) } this._fixChildNodesParent() } } removeChild(e) { const t = this._childNodes.indexOf(e); t >= 0 && (e._parentNode = null, this._childNodes.splice(t, 1), this._fixChildNodesParent()) } remove() { var e; return (e = this == null ? void 0 : this.parentNode) == null || e.removeChild(this), this } replaceChildren(...e) { this._childNodes = e.map(t => typeof t == "string" ? new Tt(t) : t.remove()), this._fixChildNodesParent() } replaceWith(...e) { const t = this._parentNode; if (t) { const n = this._indexInParent(); n >= 0 && (e = e.map(i => typeof i == "string" ? new Tt(i) : i.remove()), t._childNodes.splice(n, 1, ...e), this._parentNode = null, t._fixChildNodesParent()) } } _indexInParent() { return this._parentNode ? this._parentNode.childNodes.indexOf(this) : -1 } get parentNode() { return this._parentNode } get childNodes() { return this._childNodes || [] } get children() { return this._childNodes || [] } get firstChild() { return this._childNodes[0] } get lastChild() { return this._childNodes[this._childNodes.length - 1] } get nextSibling() { const e = this._indexInParent(); return e != null && this.parentNode.childNodes[e + 1] || null } get previousSibling() { const e = this._indexInParent(); return e > 0 && this.parentNode.childNodes[e - 1] || null } flatten() { const e = []; this instanceof ye && e.push(this); for (const t of this._childNodes) e.push(...t.flatten()); return e } flattenNodes() { const e = []; e.push(this); for (const t of this._childNodes) e.push(...t.flattenNodes()); return e } render() { return "" } get textContent() { return this._childNodes.map(e => e.textContent).join("") } set textContent(e) { this._childNodes = [], e && this.appendChild(new Tt(e.toString())) } contains(e) { return e === this ? !0 : this._childNodes.some(t => t.contains(e)) } get ownerDocument() { var e; return this.nodeType === Cn.DOCUMENT_NODE || this.nodeType === Cn.DOCUMENT_FRAGMENT_NODE ? this : (e = this == null ? void 0 : this._parentNode) == null ? void 0 : e.ownerDocument } toString() { return `${this.nodeName}` } [U0]() { return `${this.constructor.name} "${this.render()}"` } }; Pe.ELEMENT_NODE = 1; Pe.TEXT_NODE = 3; Pe.CDATA_SECTION_NODE = 4; Pe.PROCESSING_INSTRUCTION_NODE = 7; Pe.COMMENT_NODE = 8; Pe.DOCUMENT_NODE = 9; Pe.DOCUMENT_TYPE_NODE = 10; Pe.DOCUMENT_FRAGMENT_NODE = 11; var Ze = Pe, Tt = class extends Ze { get nodeType() { return Ze.TEXT_NODE } get nodeName() { return "#text" } get nodeValue() { return this._text || "" } get textContent() { return this.nodeValue } constructor(r = "") { super(), this._text = r } render() { var e; const r = (e = this.parentNode) == null ? void 0 : e.tagName; return r === "SCRIPT" || r === "STYLE" ? this._text : Kr(this._text) } cloneNode(r = !1) { const e = super.cloneNode(r); return e._text = this._text, e } }, Qo = class extends Ze { getElementById(r) { return this.flatten().find(e => e._attributes.id === r) } getElementsByClassName(r) { return this.flatten().filter(e => e.classList.contains(r)) } matches(r) { return W0(r, this) } querySelectorAll(r) { return this.flatten().filter(e => e.matches(r)) } querySelector(r) { return this.flatten().find(e => e.matches(r)) } parent(r) { var e; return this.matches(r) ? this : this.parentNode == null ? null : (e = this.parentNode) == null ? void 0 : e.parent(r) } handle(r, e) { let t = 0; for (const n of this.querySelectorAll(r)) e(n, t++) } }, ye = class extends Qo { get nodeType() { return Ze.ELEMENT_NODE } get nodeName() { return this._nodeName } constructor(r = "div", e = {}) { super(), this._originalTagName = r, this._nodeName = (r || "").toUpperCase(), this._attributes = e || {} } cloneNode(r = !1) { const e = super.cloneNode(r); return e._originalTagName = this._originalTagName, e._nodeName = this._nodeName, e._attributes = Object.assign({}, this._attributes), e } get attributes() { return Object.entries(this._attributes).map(([r, e]) => ({ name: r, value: e })) } get attributesObject() { return { ...this._attributes } } _findAttributeName(r) { const e = r.toLowerCase(); return Object.keys(this._attributes).find(t => e === t.toLowerCase()) || null } setAttribute(r, e) { this.removeAttribute(r), this._attributes[r] = e, this._styles = void 0, this._dataset = void 0 } getAttribute(r) { const e = this._findAttributeName(r), t = e ? this._attributes[e] : null; return t == null ? null : typeof t == "string" ? t : "" } removeAttribute(r) { this._findAttributeName(String(r)) && delete this._attributes[r] } hasAttribute(r) { const e = this._findAttributeName(r); return e ? this._attributes[e] != null : !1 } get style() { if (this._styles == null) { const r = {}; let e = 0; const t = this.getAttribute("style"); if (t) { let n; const i = /\s*([\w-]+)\s*:\s*((url\(.*?\)[^;]*|[^;]+))/gi; for (; n = i.exec(t);) { ++e; const s = n[1], u = n[2].trim(); r[s] = u, r[eu(s)] = u } } this._styles = { get length() { return e }, getPropertyValue(n) { return r[n] }, ...J0[this.tagName.toLowerCase()], ...r } } return this._styles } get dataset() { if (this._dataset == null) { const r = {}; for (const [e, t] of Object.entries(this._attributes)) e.startsWith("data-") && (r[e.slice(5)] = t, r[eu(e.slice(5))] = t); this._dataset = r } return this._dataset } get tagName() { return this._nodeName } setTagName(r) { this._nodeName = r.toUpperCase() } get id() { return this._attributes.id || null } set id(r) { r == null ? delete this._attributes.id : this._attributes.id = r } get src() { return this._attributes.src } set src(r) { r == null ? delete this._attributes.src : this._attributes.src = r } getElementsByTagName(r) { r = r.toUpperCase(); const e = this.flatten(); return r !== "*" ? e.filter(t => t.tagName === r) : e } setInnerHTML(r) { } get innerHTML() { return this._childNodes.map(r => r.render(tr)).join("") } set innerHTML(r) { this.setInnerHTML(r) } get outerHTML() { return this.render(zn) } get className() { return this._attributes.class || "" } set className(r) { Array.isArray(r) ? r = r.filter(e => !!e).join(" ") : typeof r == "object" && (r = Object.entries(r).filter(([e, t]) => !!t).map(([e, t]) => e).join(" ")), this._attributes.class = r } get classList() { const r = String(this.className ?? "").trim().split(/\s+/g) || []; return { contains(e) { return r.includes(e) }, add: e => { r.includes(e) || (r.push(e), this.className = r) }, remove: e => { const t = r.indexOf(e); t >= 0 && (r.splice(t, 1), this.className = r) } } } render(r = zn) { return r(this._originalTagName || this.tagName, this._attributes, this._childNodes.map(e => e.render(r)).join("")) } }, Yo = class Xo extends Ze { get nodeName() { return super.nodeName } get nodeValue() { return super.nodeValue } get nodeType() { return Xo.DOCUMENT_TYPE_NODE } render() { return "<!DOCTYPE html>" } }, Si = class el extends Qo { get nodeType() { return Ze.DOCUMENT_FRAGMENT_NODE } get nodeName() { return "#document-fragment" } render(e = zn) { return this._childNodes.map(t => t.render(e) || []).join("") } get innerHTML() { return this._childNodes.map(e => e.render(tr)).join("") } createElement(e, t = {}) { return new ye(e, t) } createDocumentFragment() { return new el } createTextNode(e) { return new Tt(e) } }, Ci = class extends Si { get nodeType() { return Ze.DOCUMENT_NODE } get nodeName() { return "#document" } get documentElement() { return this.firstChild } render(r = zn) { let e = super.render(r); return this.docType && (e = this.docType.render() + e), e } }, K0 = class extends Ci { constructor(r = !1) { if (super(), this.docType = new Yo, !r) { const e = new ye("html"), t = new ye("body"), n = new ye("head"), i = new ye("title"); e.appendChild(n), n.appendChild(i), e.appendChild(t), this.appendChild(e) } } get body() { let r = this.querySelector("body"); if (!r) { let e = this.querySelector("html"); e || (e = new ye("html"), this.appendChild(e)), r = new ye("body"), e.appendChild(e) } return r } get title() { var r; return ((r = this.querySelector("title")) == null ? void 0 : r.textContent) || "" } set title(r) { const e = this.querySelector("title"); e && (e.textContent = r) } get head() { let r = this.querySelector("head"); if (!r) { let e = this.querySelector("html"); e || (e = new ye("html"), this.appendChild(e)), r = new ye("head"), e.insertBefore(e) } return r } }; function G0() { return new Ci } var tl = G0(); H0({ document: tl }); var Z0 = {}, Q0 = Z0.hasOwnProperty; function nl(r, e) { return Q0.call(r, e) } var rl = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr", "command"]; function il(r, e, t = {}, n) { const i = !(typeof n == "string" && n === "" || Array.isArray(n) && (n.length === 0 || n.length === 1 && n[0] === "") || n == null), s = []; if (e = e.replace(/__/g, ":"), e !== "noop" && e !== "") { e !== "cdata" ? s.push(`<${e}`) : s.push("<![CDATA["); for (let u in t) if (u && nl(t, u)) { const o = t[u]; if (u === "html") continue; u.toLowerCase() === "classname" && (u = "class"), u = u.replace(/__/g, ":"), o === !0 ? s.push(` ${u}`) : u === "style" && typeof o == "object" ? s.push(` ${u}="${Object.keys(o).filter(l => o[l] != null).map(l => { let a = o[l]; return a = typeof a == "number" ? `${a}px` : a, `${l.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${a}` }).join(";")}"`) : o !== !1 && o != null && s.push(` ${u}="${Kr(o.toString())}"`) } if (e !== "cdata") { if (r && !i) return s.push(" />"), s.join(""); s.push(">") } if (!r && rl.includes(e)) return s.join("") } if (i) { if (typeof n == "string") s.push(n); else if (n && n.length > 0) { for (let u of n) if (u != null && u !== !1) { Array.isArray(u) || (u = [u]); for (const o of u) o.startsWith("<") && o.endsWith(">") || e === "script" || e === "style" ? s.push(o) : s.push(Kr(o.toString())) } } } return t.html && s.push(t.html), e !== "noop" && e !== "" && (e !== "cdata" ? s.push(`</${e}>`) : s.push("]]>")), s.join("") } function tr(r, e, ...t) { const { tag: n, attrs: i, children: s } = Zo(r, e, t); return il(!1, n, i, s) } var zn = il.bind(null, !1); tr.firstLine = "<!DOCTYPE html>"; tr.html = !0; var Y0 = /([^=\s]+)(\s*=\s*(("([^"]*)")|('([^']*)')|[^>\s]+))?/g, X0 = /^<\/([^>\s]+)[^>]*>/m, ep = /^<([^>\s/]+)((\s+[^=>\s]+(\s*=\s*(("[^"]*")|('[^']*')|[^>\s]+))?)*)\s*(?:\/\s*)?>/m, tp = /\s*\/\s*>\s*$/m, np = class { constructor(r = {}) { this.attrRe = Y0, this.endTagRe = X0, this.startTagRe = ep, this.defaults = { ignoreWhitespaceText: !1 }, r.scanner && (this.scanner = r.scanner), this.options = Object.assign({}, this.defaults, r) } parse(r) { let e = !1, t, n, i; for (; r.length;) { if (r.substring(0, 4) === "<!--") t = r.indexOf("-->"), t !== -1 ? (this.scanner.comment(r.substring(4, t)), r = r.substring(t + 3), e = !1) : e = !0; else if (r.substring(0, 2) === "</") n = this.endTagRe.exec(r), n ? (r = RegExp.rightContext, e = !1, this.parseEndTag(RegExp.lastMatch, n[1])) : e = !0; else if (r.charAt(0) === "<") if (n = this.startTagRe.exec(r), n) { r = RegExp.rightContext, e = !1; const s = this.parseStartTag(RegExp.lastMatch, n[1], n); (s === "script" || s === "style") && (t = r.search(new RegExp(`</${s}`, "i")), t !== -1 ? (this.scanner.characters(r.substring(0, t)), r = r.substring(t), e = !1) : e = !0) } else e = !0; if (e) { t = r.indexOf("<"); let s = t; t === 0 && (t = r.substring(1).indexOf("<"), s = s + 1), t === -1 ? (i = r, r = "") : (i = r.substring(0, s), r = r.substring(s)), (!this.options.ignoreWhitespaceText || !/^\s*$/.test(i)) && this.scanner.characters(i) } e = !0, n = null } } parseStartTag(r, e, t) { const n = tp.test(r); let i = t[2]; n && (i = i.replace(/\s*\/\s*$/, "")); const s = this.parseAttributes(e, i); return this.scanner.startElement(e, s, n, t[0]), e.toLocaleLowerCase() } parseEndTag(r, e) { this.scanner.endElement(e) } parseAttributes(r, e) { const t = {}; return e.replace(this.attrRe, (...n) => { const [i, s, u, o, l, a, c, d] = n; t[s] = d ?? a ?? o ?? !0 }), t } }; function rp(r) { if (typeof r != "string") throw console.error("parseHTML requires string, found", r), new Error("parseHTML requires string"); const e = r.indexOf("<!") === 0 ? new K0(!0) : new Si, t = [e]; return new np({ scanner: { startElement(i, s, u) { if (i.toLowerCase() === "!doctype") { e.docType = new Yo; return } for (const a in s) if (nl(s, a)) { const c = s[a]; typeof c == "string" && (s[a] = Ks(c)) } const l = t[t.length - 1]; if (l) { const a = tl.createElement(i, s); l.appendChild(a), rl.includes(i.toLowerCase()) || u || t.push(a) } }, endElement(i) { t.pop() }, characters(i) { var u; i = Ks(i); const s = t[t.length - 1]; ((u = s == null ? void 0 : s.lastChild) == null ? void 0 : u.nodeType) === Ze.TEXT_NODE ? s.lastChild._text += i : s && s.appendChild(new Tt(i)) }, comment(i) { } } }).parse(r), e } ye.prototype.setInnerHTML = function (r) { const e = rp(r); this._childNodes = e._childNodes, this._fixChildNodesParent() }; function Ti() { return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null } } let bt = Ti(); function sl(r) { bt = r } const ul = /[&<>"']/, ip = new RegExp(ul.source, "g"), ol = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, sp = new RegExp(ol.source, "g"), up = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, tu = r => up[r]; function ce(r, e) { if (e) { if (ul.test(r)) return r.replace(ip, tu) } else if (ol.test(r)) return r.replace(sp, tu); return r } const op = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig; function lp(r) { return r.replace(op, (e, t) => (t = t.toLowerCase(), t === "colon" ? ":" : t.charAt(0) === "#" ? t.charAt(1) === "x" ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : "")) } const ap = /(^|[^\[])\^/g; function R(r, e) { let t = typeof r == "string" ? r : r.source; e = e || ""; const n = { replace: (i, s) => { let u = typeof s == "string" ? s : s.source; return u = u.replace(ap, "$1"), t = t.replace(i, u), n }, getRegex: () => new RegExp(t, e) }; return n } function nu(r) { try { r = encodeURI(r).replace(/%25/g, "%") } catch { return null } return r } const jt = { exec: () => null }; function ru(r, e) { const t = r.replace(/\|/g, (s, u, o) => { let l = !1, a = u; for (; --a >= 0 && o[a] === "\\";)l = !l; return l ? "|" : " |" }), n = t.split(/ \|/); let i = 0; if (n[0].trim() || n.shift(), n.length > 0 && !n[n.length - 1].trim() && n.pop(), e) if (n.length > e) n.splice(e); else for (; n.length < e;)n.push(""); for (; i < n.length; i++)n[i] = n[i].trim().replace(/\\\|/g, "|"); return n } function bn(r, e, t) { const n = r.length; if (n === 0) return ""; let i = 0; for (; i < n && r.charAt(n - i - 1) === e;)i++; return r.slice(0, n - i) } function cp(r, e) { if (r.indexOf(e[1]) === -1) return -1; let t = 0; for (let n = 0; n < r.length; n++)if (r[n] === "\\") n++; else if (r[n] === e[0]) t++; else if (r[n] === e[1] && (t--, t < 0)) return n; return -1 } function iu(r, e, t, n) { const i = e.href, s = e.title ? ce(e.title) : null, u = r[1].replace(/\\([\[\]])/g, "$1"); if (r[0].charAt(0) !== "!") { n.state.inLink = !0; const o = { type: "link", raw: t, href: i, title: s, text: u, tokens: n.inlineTokens(u) }; return n.state.inLink = !1, o } return { type: "image", raw: t, href: i, title: s, text: ce(u) } } function dp(r, e) {
    const t = r.match(/^(\s+)(?:```)/); if (t === null) return e; const n = t[1]; return e.split(`
`).map(i => { const s = i.match(/^\s+/); if (s === null) return i; const [u] = s; return u.length >= n.length ? i.slice(n.length) : i }).join(`
`)
} class $n {
    constructor(e) { L(this, "options"); L(this, "rules"); L(this, "lexer"); this.options = e || bt } space(e) { const t = this.rules.block.newline.exec(e); if (t && t[0].length > 0) return { type: "space", raw: t[0] } } code(e) {
        const t = this.rules.block.code.exec(e); if (t) {
            const n = t[0].replace(/^ {1,4}/gm, ""); return {
                type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : bn(n, `
`)
            }
        }
    } fences(e) { const t = this.rules.block.fences.exec(e); if (t) { const n = t[0], i = dp(n, t[3] || ""); return { type: "code", raw: n, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: i } } } heading(e) { const t = this.rules.block.heading.exec(e); if (t) { let n = t[2].trim(); if (/#$/.test(n)) { const i = bn(n, "#"); (this.options.pedantic || !i || / $/.test(i)) && (n = i.trim()) } return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) } } } hr(e) { const t = this.rules.block.hr.exec(e); if (t) return { type: "hr", raw: t[0] } } blockquote(e) {
        const t = this.rules.block.blockquote.exec(e); if (t) {
            const n = bn(t[0].replace(/^ *>[ \t]?/gm, ""), `
`), i = this.lexer.state.top; this.lexer.state.top = !0; const s = this.lexer.blockTokens(n); return this.lexer.state.top = i, { type: "blockquote", raw: t[0], tokens: s, text: n }
        }
    } list(e) {
        let t = this.rules.block.list.exec(e); if (t) {
            let n = t[1].trim(); const i = n.length > 1, s = { type: "list", raw: "", ordered: i, start: i ? +n.slice(0, -1) : "", loose: !1, items: [] }; n = i ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = i ? n : "[*+-]"); const u = new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`); let o = "", l = "", a = !1; for (; e;) {
                let c = !1; if (!(t = u.exec(e)) || this.rules.block.hr.test(e)) break; o = t[0], e = e.substring(o.length); let d = t[2].split(`
`, 1)[0].replace(/^\t+/, b => " ".repeat(3 * b.length)), f = e.split(`
`, 1)[0], h = 0; this.options.pedantic ? (h = 2, l = d.trimStart()) : (h = t[2].search(/[^ ]/), h = h > 4 ? 1 : h, l = d.slice(h), h += t[1].length); let p = !1; if (!d && /^ *$/.test(f) && (o += f + `
`, e = e.substring(f.length + 1), c = !0), !c) {
                    const b = new RegExp(`^ {0,${Math.min(3, h - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), w = new RegExp(`^ {0,${Math.min(3, h - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), C = new RegExp(`^ {0,${Math.min(3, h - 1)}}(?:\`\`\`|~~~)`), O = new RegExp(`^ {0,${Math.min(3, h - 1)}}#`); for (; e;) {
                        const A = e.split(`
`, 1)[0]; if (f = A, this.options.pedantic && (f = f.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), C.test(f) || O.test(f) || b.test(f) || w.test(e)) break; if (f.search(/[^ ]/) >= h || !f.trim()) l += `
`+ f.slice(h); else {
                            if (p || d.search(/[^ ]/) >= 4 || C.test(d) || O.test(d) || w.test(d)) break; l += `
`+ f
                        } !p && !f.trim() && (p = !0), o += A + `
`, e = e.substring(A.length + 1), d = f.slice(h)
                    }
                } s.loose || (a ? s.loose = !0 : /\n *\n *$/.test(o) && (a = !0)); let m = null, g; this.options.gfm && (m = /^\[[ xX]\] /.exec(l), m && (g = m[0] !== "[ ] ", l = l.replace(/^\[[ xX]\] +/, ""))), s.items.push({ type: "list_item", raw: o, task: !!m, checked: g, loose: !1, text: l, tokens: [] }), s.raw += o
            } s.items[s.items.length - 1].raw = o.trimEnd(), s.items[s.items.length - 1].text = l.trimEnd(), s.raw = s.raw.trimEnd(); for (let c = 0; c < s.items.length; c++)if (this.lexer.state.top = !1, s.items[c].tokens = this.lexer.blockTokens(s.items[c].text, []), !s.loose) { const d = s.items[c].tokens.filter(h => h.type === "space"), f = d.length > 0 && d.some(h => /\n.*\n/.test(h.raw)); s.loose = f } if (s.loose) for (let c = 0; c < s.items.length; c++)s.items[c].loose = !0; return s
        }
    } html(e) { const t = this.rules.block.html.exec(e); if (t) return { type: "html", block: !0, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] } } def(e) { const t = this.rules.block.def.exec(e); if (t) { const n = t[1].toLowerCase().replace(/\s+/g, " "), i = t[2] ? t[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", s = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3]; return { type: "def", tag: n, raw: t[0], href: i, title: s } } } table(e) {
        const t = this.rules.block.table.exec(e); if (!t || !/[:|]/.test(t[2])) return; const n = ru(t[1]), i = t[2].replace(/^\||\| *$/g, "").split("|"), s = t[3] && t[3].trim() ? t[3].replace(/\n[ \t]*$/, "").split(`
`) : [], u = { type: "table", raw: t[0], header: [], align: [], rows: [] }; if (n.length === i.length) { for (const o of i) /^ *-+: *$/.test(o) ? u.align.push("right") : /^ *:-+: *$/.test(o) ? u.align.push("center") : /^ *:-+ *$/.test(o) ? u.align.push("left") : u.align.push(null); for (const o of n) u.header.push({ text: o, tokens: this.lexer.inline(o) }); for (const o of s) u.rows.push(ru(o, u.header.length).map(l => ({ text: l, tokens: this.lexer.inline(l) }))); return u }
    } lheading(e) { const t = this.rules.block.lheading.exec(e); if (t) return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) } } paragraph(e) {
        const t = this.rules.block.paragraph.exec(e); if (t) {
            const n = t[1].charAt(t[1].length - 1) === `
`? t[1].slice(0, -1) : t[1]; return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) }
        }
    } text(e) { const t = this.rules.block.text.exec(e); if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) } } escape(e) { const t = this.rules.inline.escape.exec(e); if (t) return { type: "escape", raw: t[0], text: ce(t[1]) } } tag(e) { const t = this.rules.inline.tag.exec(e); if (t) return !this.lexer.state.inLink && /^<a /i.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: t[0] } } link(e) { const t = this.rules.inline.link.exec(e); if (t) { const n = t[2].trim(); if (!this.options.pedantic && /^</.test(n)) { if (!/>$/.test(n)) return; const u = bn(n.slice(0, -1), "\\"); if ((n.length - u.length) % 2 === 0) return } else { const u = cp(t[2], "()"); if (u > -1) { const l = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + u; t[2] = t[2].substring(0, u), t[0] = t[0].substring(0, l).trim(), t[3] = "" } } let i = t[2], s = ""; if (this.options.pedantic) { const u = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(i); u && (i = u[1], s = u[3]) } else s = t[3] ? t[3].slice(1, -1) : ""; return i = i.trim(), /^</.test(i) && (this.options.pedantic && !/>$/.test(n) ? i = i.slice(1) : i = i.slice(1, -1)), iu(t, { href: i && i.replace(this.rules.inline.anyPunctuation, "$1"), title: s && s.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer) } } reflink(e, t) { let n; if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) { const i = (n[2] || n[1]).replace(/\s+/g, " "), s = t[i.toLowerCase()]; if (!s) { const u = n[0].charAt(0); return { type: "text", raw: u, text: u } } return iu(n, s, n[0], this.lexer) } } emStrong(e, t, n = "") { let i = this.rules.inline.emStrongLDelim.exec(e); if (!i || i[3] && n.match(/[\p{L}\p{N}]/u)) return; if (!(i[1] || i[2] || "") || !n || this.rules.inline.punctuation.exec(n)) { const u = [...i[0]].length - 1; let o, l, a = u, c = 0; const d = i[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd; for (d.lastIndex = 0, t = t.slice(-1 * e.length + u); (i = d.exec(t)) != null;) { if (o = i[1] || i[2] || i[3] || i[4] || i[5] || i[6], !o) continue; if (l = [...o].length, i[3] || i[4]) { a += l; continue } else if ((i[5] || i[6]) && u % 3 && !((u + l) % 3)) { c += l; continue } if (a -= l, a > 0) continue; l = Math.min(l, l + a + c); const f = [...i[0]][0].length, h = e.slice(0, u + i.index + f + l); if (Math.min(u, l) % 2) { const m = h.slice(1, -1); return { type: "em", raw: h, text: m, tokens: this.lexer.inlineTokens(m) } } const p = h.slice(2, -2); return { type: "strong", raw: h, text: p, tokens: this.lexer.inlineTokens(p) } } } } codespan(e) { const t = this.rules.inline.code.exec(e); if (t) { let n = t[2].replace(/\n/g, " "); const i = /[^ ]/.test(n), s = /^ /.test(n) && / $/.test(n); return i && s && (n = n.substring(1, n.length - 1)), n = ce(n, !0), { type: "codespan", raw: t[0], text: n } } } br(e) { const t = this.rules.inline.br.exec(e); if (t) return { type: "br", raw: t[0] } } del(e) { const t = this.rules.inline.del.exec(e); if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) } } autolink(e) { const t = this.rules.inline.autolink.exec(e); if (t) { let n, i; return t[2] === "@" ? (n = ce(t[1]), i = "mailto:" + n) : (n = ce(t[1]), i = n), { type: "link", raw: t[0], text: n, href: i, tokens: [{ type: "text", raw: n, text: n }] } } } url(e) { var n; let t; if (t = this.rules.inline.url.exec(e)) { let i, s; if (t[2] === "@") i = ce(t[0]), s = "mailto:" + i; else { let u; do u = t[0], t[0] = ((n = this.rules.inline._backpedal.exec(t[0])) == null ? void 0 : n[0]) ?? ""; while (u !== t[0]); i = ce(t[0]), t[1] === "www." ? s = "http://" + t[0] : s = t[0] } return { type: "link", raw: t[0], text: i, href: s, tokens: [{ type: "text", raw: i, text: i }] } } } inlineText(e) { const t = this.rules.inline.text.exec(e); if (t) { let n; return this.lexer.state.inRawBlock ? n = t[0] : n = ce(t[0]), { type: "text", raw: t[0], text: n } } }
} const fp = /^(?: *(?:\n|$))+/, hp = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, pp = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, un = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, mp = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, ll = /(?:[*+-]|\d{1,9}[.)])/, al = R(/^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, ll).getRegex(), Ei = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, gp = /^[^\n]+/, Mi = /(?!\s*\])(?:\\.|[^\[\]\\])+/, bp = R(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", Mi).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), yp = R(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, ll).getRegex(), nr = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Ni = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, xp = R("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", Ni).replace("tag", nr).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), cl = R(Ei).replace("hr", un).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", nr).getRegex(), kp = R(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", cl).getRegex(), Ai = { blockquote: kp, code: hp, def: bp, fences: pp, heading: mp, hr: un, html: xp, lheading: al, list: yp, newline: fp, paragraph: cl, table: jt, text: gp }, su = R("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", un).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", nr).getRegex(), wp = { ...Ai, table: su, paragraph: R(Ei).replace("hr", un).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", su).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", nr).getRegex() }, Sp = {
    ...Ai, html: R(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Ni).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: jt, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: R(Ei).replace("hr", un).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", al).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, dl = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Cp = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, fl = /^( {2,}|\\)\n(?!\s*$)/, Tp = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, on = "\\p{P}$+<=>`^|~", Ep = R(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, on).getRegex(), Mp = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, Np = R(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, on).getRegex(), Ap = R("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, on).getRegex(), Op = R("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, on).getRegex(), vp = R(/\\([punct])/, "gu").replace(/punct/g, on).getRegex(), Dp = R(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Rp = R(Ni).replace("(?:-->|$)", "-->").getRegex(), Ip = R("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Rp).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), _n = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, Pp = R(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _n).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), hl = R(/^!?\[(label)\]\[(ref)\]/).replace("label", _n).replace("ref", Mi).getRegex(), pl = R(/^!?\[(ref)\](?:\[\])?/).replace("ref", Mi).getRegex(), Lp = R("reflink|nolink(?!\\()", "g").replace("reflink", hl).replace("nolink", pl).getRegex(), Oi = { _backpedal: jt, anyPunctuation: vp, autolink: Dp, blockSkip: Mp, br: fl, code: Cp, del: jt, emStrongLDelim: Np, emStrongRDelimAst: Ap, emStrongRDelimUnd: Op, escape: dl, link: Pp, nolink: pl, punctuation: Ep, reflink: hl, reflinkSearch: Lp, tag: Ip, text: Tp, url: jt }, Bp = { ...Oi, link: R(/^!?\[(label)\]\((.*?)\)/).replace("label", _n).getRegex(), reflink: R(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _n).getRegex() }, Gr = { ...Oi, escape: R(dl).replace("])", "~|])").getRegex(), url: R(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, zp = { ...Gr, br: R(fl).replace("{2,}", "*").getRegex(), text: R(Gr.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, yn = { normal: Ai, gfm: wp, pedantic: Sp }, Bt = { normal: Oi, gfm: Gr, breaks: zp, pedantic: Bp }; class Ee {
    constructor(e) { L(this, "tokens"); L(this, "options"); L(this, "state"); L(this, "tokenizer"); L(this, "inlineQueue"); this.tokens = [], this.tokens.links = Object.create(null), this.options = e || bt, this.options.tokenizer = this.options.tokenizer || new $n, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 }; const t = { block: yn.normal, inline: Bt.normal }; this.options.pedantic ? (t.block = yn.pedantic, t.inline = Bt.pedantic) : this.options.gfm && (t.block = yn.gfm, this.options.breaks ? t.inline = Bt.breaks : t.inline = Bt.gfm), this.tokenizer.rules = t } static get rules() { return { block: yn, inline: Bt } } static lex(e, t) { return new Ee(t).lex(e) } static lexInline(e, t) { return new Ee(t).inlineTokens(e) } lex(e) {
        e = e.replace(/\r\n|\r/g, `
`), this.blockTokens(e, this.tokens); for (let t = 0; t < this.inlineQueue.length; t++) { const n = this.inlineQueue[t]; this.inlineTokens(n.src, n.tokens) } return this.inlineQueue = [], this.tokens
    } blockTokens(e, t = []) {
        this.options.pedantic ? e = e.replace(/\t/g, "    ").replace(/^ +$/gm, "") : e = e.replace(/^( *)(\t+)/gm, (o, l, a) => l + "    ".repeat(a.length)); let n, i, s, u; for (; e;)if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(o => (n = o.call({ lexer: this }, e, t)) ? (e = e.substring(n.raw.length), t.push(n), !0) : !1))) {
            if (n = this.tokenizer.space(e)) {
                e = e.substring(n.raw.length), n.raw.length === 1 && t.length > 0 ? t[t.length - 1].raw += `
`: t.push(n); continue
            } if (n = this.tokenizer.code(e)) {
                e = e.substring(n.raw.length), i = t[t.length - 1], i && (i.type === "paragraph" || i.type === "text") ? (i.raw += `
`+ n.raw, i.text += `
`+ n.text, this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(n); continue
            } if (n = this.tokenizer.fences(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.heading(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.hr(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.blockquote(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.list(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.html(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.def(e)) {
                e = e.substring(n.raw.length), i = t[t.length - 1], i && (i.type === "paragraph" || i.type === "text") ? (i.raw += `
`+ n.raw, i.text += `
`+ n.raw, this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : this.tokens.links[n.tag] || (this.tokens.links[n.tag] = { href: n.href, title: n.title }); continue
            } if (n = this.tokenizer.table(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.lheading(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (s = e, this.options.extensions && this.options.extensions.startBlock) { let o = 1 / 0; const l = e.slice(1); let a; this.options.extensions.startBlock.forEach(c => { a = c.call({ lexer: this }, l), typeof a == "number" && a >= 0 && (o = Math.min(o, a)) }), o < 1 / 0 && o >= 0 && (s = e.substring(0, o + 1)) } if (this.state.top && (n = this.tokenizer.paragraph(s))) {
                i = t[t.length - 1], u && i.type === "paragraph" ? (i.raw += `
`+ n.raw, i.text += `
`+ n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(n), u = s.length !== e.length, e = e.substring(n.raw.length); continue
            } if (n = this.tokenizer.text(e)) {
                e = e.substring(n.raw.length), i = t[t.length - 1], i && i.type === "text" ? (i.raw += `
`+ n.raw, i.text += `
`+ n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(n); continue
            } if (e) { const o = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(o); break } else throw new Error(o) }
        } return this.state.top = !0, t
    } inline(e, t = []) { return this.inlineQueue.push({ src: e, tokens: t }), t } inlineTokens(e, t = []) { let n, i, s, u = e, o, l, a; if (this.tokens.links) { const c = Object.keys(this.tokens.links); if (c.length > 0) for (; (o = this.tokenizer.rules.inline.reflinkSearch.exec(u)) != null;)c.includes(o[0].slice(o[0].lastIndexOf("[") + 1, -1)) && (u = u.slice(0, o.index) + "[" + "a".repeat(o[0].length - 2) + "]" + u.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex)) } for (; (o = this.tokenizer.rules.inline.blockSkip.exec(u)) != null;)u = u.slice(0, o.index) + "[" + "a".repeat(o[0].length - 2) + "]" + u.slice(this.tokenizer.rules.inline.blockSkip.lastIndex); for (; (o = this.tokenizer.rules.inline.anyPunctuation.exec(u)) != null;)u = u.slice(0, o.index) + "++" + u.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex); for (; e;)if (l || (a = ""), l = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(c => (n = c.call({ lexer: this }, e, t)) ? (e = e.substring(n.raw.length), t.push(n), !0) : !1))) { if (n = this.tokenizer.escape(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.tag(e)) { e = e.substring(n.raw.length), i = t[t.length - 1], i && n.type === "text" && i.type === "text" ? (i.raw += n.raw, i.text += n.text) : t.push(n); continue } if (n = this.tokenizer.link(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.reflink(e, this.tokens.links)) { e = e.substring(n.raw.length), i = t[t.length - 1], i && n.type === "text" && i.type === "text" ? (i.raw += n.raw, i.text += n.text) : t.push(n); continue } if (n = this.tokenizer.emStrong(e, u, a)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.codespan(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.br(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.del(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.autolink(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (!this.state.inLink && (n = this.tokenizer.url(e))) { e = e.substring(n.raw.length), t.push(n); continue } if (s = e, this.options.extensions && this.options.extensions.startInline) { let c = 1 / 0; const d = e.slice(1); let f; this.options.extensions.startInline.forEach(h => { f = h.call({ lexer: this }, d), typeof f == "number" && f >= 0 && (c = Math.min(c, f)) }), c < 1 / 0 && c >= 0 && (s = e.substring(0, c + 1)) } if (n = this.tokenizer.inlineText(s)) { e = e.substring(n.raw.length), n.raw.slice(-1) !== "_" && (a = n.raw.slice(-1)), l = !0, i = t[t.length - 1], i && i.type === "text" ? (i.raw += n.raw, i.text += n.text) : t.push(n); continue } if (e) { const c = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(c); break } else throw new Error(c) } } return t }
} class Fn {
    constructor(e) { L(this, "options"); this.options = e || bt } code(e, t, n) {
        var s; const i = (s = (t || "").match(/^\S*/)) == null ? void 0 : s[0]; return e = e.replace(/\n$/, "") + `
`, i ? '<pre><code class="language-' + ce(i) + '">' + (n ? e : ce(e, !0)) + `</code></pre>
`: "<pre><code>" + (n ? e : ce(e, !0)) + `</code></pre>
`} blockquote(e) {
        return `<blockquote>
${e}</blockquote>
`} html(e, t) { return e } heading(e, t, n) {
        return `<h${t}>${e}</h${t}>
`} hr() {
        return `<hr>
`} list(e, t, n) {
        const i = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : ""; return "<" + i + s + `>
`+ e + "</" + i + `>
`} listitem(e, t, n) {
        return `<li>${e}</li>
`} checkbox(e) { return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">' } paragraph(e) {
        return `<p>${e}</p>
`} table(e, t) {
        return t && (t = `<tbody>${t}</tbody>`), `<table>
<thead>
`+ e + `</thead>
`+ t + `</table>
`} tablerow(e) {
        return `<tr>
${e}</tr>
`} tablecell(e, t) {
        const n = t.header ? "th" : "td"; return (t.align ? `<${n} align="${t.align}">` : `<${n}>`) + e + `</${n}>
`} strong(e) { return `<strong>${e}</strong>` } em(e) { return `<em>${e}</em>` } codespan(e) { return `<code>${e}</code>` } br() { return "<br>" } del(e) { return `<del>${e}</del>` } link(e, t, n) { const i = nu(e); if (i === null) return n; e = i; let s = '<a href="' + e + '"'; return t && (s += ' title="' + t + '"'), s += ">" + n + "</a>", s } image(e, t, n) { const i = nu(e); if (i === null) return n; e = i; let s = `<img src="${e}" alt="${n}"`; return t && (s += ` title="${t}"`), s += ">", s } text(e) { return e }
} class vi { strong(e) { return e } em(e) { return e } codespan(e) { return e } del(e) { return e } html(e) { return e } text(e) { return e } link(e, t, n) { return "" + n } image(e, t, n) { return "" + n } br() { return "" } } class Me {
    constructor(e) { L(this, "options"); L(this, "renderer"); L(this, "textRenderer"); this.options = e || bt, this.options.renderer = this.options.renderer || new Fn, this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new vi } static parse(e, t) { return new Me(t).parse(e) } static parseInline(e, t) { return new Me(t).parseInline(e) } parse(e, t = !0) {
        let n = ""; for (let i = 0; i < e.length; i++) {
            const s = e[i]; if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[s.type]) { const u = s, o = this.options.extensions.renderers[u.type].call({ parser: this }, u); if (o !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(u.type)) { n += o || ""; continue } } switch (s.type) {
                case "space": continue; case "hr": { n += this.renderer.hr(); continue } case "heading": { const u = s; n += this.renderer.heading(this.parseInline(u.tokens), u.depth, lp(this.parseInline(u.tokens, this.textRenderer))); continue } case "code": { const u = s; n += this.renderer.code(u.text, u.lang, !!u.escaped); continue } case "table": { const u = s; let o = "", l = ""; for (let c = 0; c < u.header.length; c++)l += this.renderer.tablecell(this.parseInline(u.header[c].tokens), { header: !0, align: u.align[c] }); o += this.renderer.tablerow(l); let a = ""; for (let c = 0; c < u.rows.length; c++) { const d = u.rows[c]; l = ""; for (let f = 0; f < d.length; f++)l += this.renderer.tablecell(this.parseInline(d[f].tokens), { header: !1, align: u.align[f] }); a += this.renderer.tablerow(l) } n += this.renderer.table(o, a); continue } case "blockquote": { const u = s, o = this.parse(u.tokens); n += this.renderer.blockquote(o); continue } case "list": { const u = s, o = u.ordered, l = u.start, a = u.loose; let c = ""; for (let d = 0; d < u.items.length; d++) { const f = u.items[d], h = f.checked, p = f.task; let m = ""; if (f.task) { const g = this.renderer.checkbox(!!h); a ? f.tokens.length > 0 && f.tokens[0].type === "paragraph" ? (f.tokens[0].text = g + " " + f.tokens[0].text, f.tokens[0].tokens && f.tokens[0].tokens.length > 0 && f.tokens[0].tokens[0].type === "text" && (f.tokens[0].tokens[0].text = g + " " + f.tokens[0].tokens[0].text)) : f.tokens.unshift({ type: "text", text: g + " " }) : m += g + " " } m += this.parse(f.tokens, a), c += this.renderer.listitem(m, p, !!h) } n += this.renderer.list(c, o, l); continue } case "html": { const u = s; n += this.renderer.html(u.text, u.block); continue } case "paragraph": { const u = s; n += this.renderer.paragraph(this.parseInline(u.tokens)); continue } case "text": {
                    let u = s, o = u.tokens ? this.parseInline(u.tokens) : u.text; for (; i + 1 < e.length && e[i + 1].type === "text";)u = e[++i], o += `
`+ (u.tokens ? this.parseInline(u.tokens) : u.text); n += t ? this.renderer.paragraph(o) : o; continue
                } default: { const u = 'Token with "' + s.type + '" type was not found.'; if (this.options.silent) return console.error(u), ""; throw new Error(u) }
            }
        } return n
    } parseInline(e, t) { t = t || this.renderer; let n = ""; for (let i = 0; i < e.length; i++) { const s = e[i]; if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[s.type]) { const u = this.options.extensions.renderers[s.type].call({ parser: this }, s); if (u !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(s.type)) { n += u || ""; continue } } switch (s.type) { case "escape": { const u = s; n += t.text(u.text); break } case "html": { const u = s; n += t.html(u.text); break } case "link": { const u = s; n += t.link(u.href, u.title, this.parseInline(u.tokens, t)); break } case "image": { const u = s; n += t.image(u.href, u.title, u.text); break } case "strong": { const u = s; n += t.strong(this.parseInline(u.tokens, t)); break } case "em": { const u = s; n += t.em(this.parseInline(u.tokens, t)); break } case "codespan": { const u = s; n += t.codespan(u.text); break } case "br": { n += t.br(); break } case "del": { const u = s; n += t.del(this.parseInline(u.tokens, t)); break } case "text": { const u = s; n += t.text(u.text); break } default: { const u = 'Token with "' + s.type + '" type was not found.'; if (this.options.silent) return console.error(u), ""; throw new Error(u) } } } return n }
} class Wt { constructor(e) { L(this, "options"); this.options = e || bt } preprocess(e) { return e } postprocess(e) { return e } processAllTokens(e) { return e } } L(Wt, "passThroughHooks", new Set(["preprocess", "postprocess", "processAllTokens"])); var mt, Zr, ml; class $p { constructor(...e) { Ri(this, mt); L(this, "defaults", Ti()); L(this, "options", this.setOptions); L(this, "parse", ln(this, mt, Zr).call(this, Ee.lex, Me.parse)); L(this, "parseInline", ln(this, mt, Zr).call(this, Ee.lexInline, Me.parseInline)); L(this, "Parser", Me); L(this, "Renderer", Fn); L(this, "TextRenderer", vi); L(this, "Lexer", Ee); L(this, "Tokenizer", $n); L(this, "Hooks", Wt); this.use(...e) } walkTokens(e, t) { var i, s; let n = []; for (const u of e) switch (n = n.concat(t.call(this, u)), u.type) { case "table": { const o = u; for (const l of o.header) n = n.concat(this.walkTokens(l.tokens, t)); for (const l of o.rows) for (const a of l) n = n.concat(this.walkTokens(a.tokens, t)); break } case "list": { const o = u; n = n.concat(this.walkTokens(o.items, t)); break } default: { const o = u; (s = (i = this.defaults.extensions) == null ? void 0 : i.childTokens) != null && s[o.type] ? this.defaults.extensions.childTokens[o.type].forEach(l => { const a = o[l].flat(1 / 0); n = n.concat(this.walkTokens(a, t)) }) : o.tokens && (n = n.concat(this.walkTokens(o.tokens, t))) } }return n } use(...e) { const t = this.defaults.extensions || { renderers: {}, childTokens: {} }; return e.forEach(n => { const i = { ...n }; if (i.async = this.defaults.async || i.async || !1, n.extensions && (n.extensions.forEach(s => { if (!s.name) throw new Error("extension name required"); if ("renderer" in s) { const u = t.renderers[s.name]; u ? t.renderers[s.name] = function (...o) { let l = s.renderer.apply(this, o); return l === !1 && (l = u.apply(this, o)), l } : t.renderers[s.name] = s.renderer } if ("tokenizer" in s) { if (!s.level || s.level !== "block" && s.level !== "inline") throw new Error("extension level must be 'block' or 'inline'"); const u = t[s.level]; u ? u.unshift(s.tokenizer) : t[s.level] = [s.tokenizer], s.start && (s.level === "block" ? t.startBlock ? t.startBlock.push(s.start) : t.startBlock = [s.start] : s.level === "inline" && (t.startInline ? t.startInline.push(s.start) : t.startInline = [s.start])) } "childTokens" in s && s.childTokens && (t.childTokens[s.name] = s.childTokens) }), i.extensions = t), n.renderer) { const s = this.defaults.renderer || new Fn(this.defaults); for (const u in n.renderer) { if (!(u in s)) throw new Error(`renderer '${u}' does not exist`); if (u === "options") continue; const o = u, l = n.renderer[o], a = s[o]; s[o] = (...c) => { let d = l.apply(s, c); return d === !1 && (d = a.apply(s, c)), d || "" } } i.renderer = s } if (n.tokenizer) { const s = this.defaults.tokenizer || new $n(this.defaults); for (const u in n.tokenizer) { if (!(u in s)) throw new Error(`tokenizer '${u}' does not exist`); if (["options", "rules", "lexer"].includes(u)) continue; const o = u, l = n.tokenizer[o], a = s[o]; s[o] = (...c) => { let d = l.apply(s, c); return d === !1 && (d = a.apply(s, c)), d } } i.tokenizer = s } if (n.hooks) { const s = this.defaults.hooks || new Wt; for (const u in n.hooks) { if (!(u in s)) throw new Error(`hook '${u}' does not exist`); if (u === "options") continue; const o = u, l = n.hooks[o], a = s[o]; Wt.passThroughHooks.has(u) ? s[o] = c => { if (this.defaults.async) return Promise.resolve(l.call(s, c)).then(f => a.call(s, f)); const d = l.call(s, c); return a.call(s, d) } : s[o] = (...c) => { let d = l.apply(s, c); return d === !1 && (d = a.apply(s, c)), d } } i.hooks = s } if (n.walkTokens) { const s = this.defaults.walkTokens, u = n.walkTokens; i.walkTokens = function (o) { let l = []; return l.push(u.call(this, o)), s && (l = l.concat(s.call(this, o))), l } } this.defaults = { ...this.defaults, ...i } }), this } setOptions(e) { return this.defaults = { ...this.defaults, ...e }, this } lexer(e, t) { return Ee.lex(e, t ?? this.defaults) } parser(e, t) { return Me.parse(e, t ?? this.defaults) } } mt = new WeakSet, Zr = function (e, t) { return (n, i) => { const s = { ...i }, u = { ...this.defaults, ...s }; this.defaults.async === !0 && s.async === !1 && (u.silent || console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored."), u.async = !0); const o = ln(this, mt, ml).call(this, !!u.silent, !!u.async); if (typeof n > "u" || n === null) return o(new Error("marked(): input parameter is undefined or null")); if (typeof n != "string") return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected")); if (u.hooks && (u.hooks.options = u), u.async) return Promise.resolve(u.hooks ? u.hooks.preprocess(n) : n).then(l => e(l, u)).then(l => u.hooks ? u.hooks.processAllTokens(l) : l).then(l => u.walkTokens ? Promise.all(this.walkTokens(l, u.walkTokens)).then(() => l) : l).then(l => t(l, u)).then(l => u.hooks ? u.hooks.postprocess(l) : l).catch(o); try { u.hooks && (n = u.hooks.preprocess(n)); let l = e(n, u); u.hooks && (l = u.hooks.processAllTokens(l)), u.walkTokens && this.walkTokens(l, u.walkTokens); let a = t(l, u); return u.hooks && (a = u.hooks.postprocess(a)), a } catch (l) { return o(l) } } }, ml = function (e, t) {
    return n => {
        if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) { const i = "<p>An error occurred:</p><pre>" + ce(n.message + "", !0) + "</pre>"; return t ? Promise.resolve(i) : i } if (t) return Promise.reject(n); throw n
    }
}; const pt = new $p; function D(r, e) { return pt.parse(r, e) } D.options = D.setOptions = function (r) { return pt.setOptions(r), D.defaults = pt.defaults, sl(D.defaults), D }; D.getDefaults = Ti; D.defaults = bt; D.use = function (...r) { return pt.use(...r), D.defaults = pt.defaults, sl(D.defaults), D }; D.walkTokens = function (r, e) { return pt.walkTokens(r, e) }; D.parseInline = pt.parseInline; D.Parser = Me; D.parser = Me.parse; D.Renderer = Fn; D.TextRenderer = vi; D.Lexer = Ee; D.lexer = Ee.lex; D.Tokenizer = $n; D.Hooks = Wt; D.parse = D; D.options; D.setOptions; D.use; D.walkTokens; D.parseInline; Me.parse; Ee.lex; function Mr(r) {
    return `
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M3 15C3 17.8284 3 19.2426 3.87868 20.1213C4.75736 21 6.17157 21 9 21H15C17.8284 21 19.2426 21 20.1213 20.1213C21 19.2426 21 17.8284 21 15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M12 16V3M12 3L16 7.375M12 3L8 7.375" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <span>${r}</span>
  `} function _p(r, e) { const t = r.schema.marks.errorHighlight, { tr: n } = r.state; r.state.doc.descendants((s, u) => { if (s.isText && s.marks.some(o => o.type === t)) { const o = u, l = u + s.nodeSize; n.removeMark(o, l, t) } }), e.forEach(s => { const u = s.position + 1, o = Math.min(s.position + s.original.length + 1, r.state.doc.content.size + 1); if (s.type === "error") { const l = t.create({ "data-correction": s.corrected }); n.addMark(u, o, l) } }), r.view.dispatch(n) }
function yg(r, e) { const t = r.schema.marks.errorHighlight, { tr: n } = r.state; r.state.doc.descendants((s, o) => { if (s.isText && s.marks.some(l => l.type === t)) { const l = o, a = o + s.nodeSize; n.removeMark(l, a, t) } }), e.forEach(s => { const o = s.position + 1, l = Math.min(s.position + s.original.length + 1, r.state.doc.content.size + 1); if (s.type === "error") { const a = t.create({ "data-correction": s.corrected }); n.addMark(o, l, a) } }), r.view.dispatch(n) }
async function Fp(r) {

    const e = r.getText();
    r.chain().setTextSelection({ from: 0, to: e.length }).setColor("#999999").run();
    const t = await fetch("http://192.168.8.193:8000/api/grammar-correct/", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ text: e, model: "gemma3n", stream: true }) });
    if (!t.ok) throw new Error(`Failed to create session: ${t.status}`);
    const i = (await t.json()).session_id, s = new EventSource(`http://192.168.8.193:8000/api/grammar-correct/${i}`);

    return new Promise((o, l) => {
        s.onmessage = function (a) {
            try {
                const c = JSON.parse(a.data);
                switch (c.type) {
                    case "update": r.chain().setTextSelection({ from: 0, to: c.content.length }).setColor("#000000").run(), c.diffs && yg(r, c.diffs); break;
                    case "final": s.close(), o(); break;
                    case "error": console.error("Error:", c.message), l("Error:", c.message), s.close(); break
                }
            } catch (c) { console.error("Error processing update:", c), l(c), s.close() }
        }, s.onerror = function (a) { console.error("Connection error occurred", a), s.close(), l(new Error("EventSource connection failed")) }
    })
} const Vp = we.create({ name: "errorHighlight", addAttributes() { return { "data-correction": { default: null } } }, parseHTML() { return [{ tag: "span.error-highlight", getAttrs: r => ({ "data-correction": r.getAttribute("data-correction") }) }] }, renderHTML({ HTMLAttributes: r }) { return ["span", { ...r, class: "error-highlight" }, 0] } }),
    v = new ph({
        element: document.querySelector("#editor"),
        editorProps: {
            attributes: { spellcheck: "false", autocorrect: "off", autocomplete: "off", autocapitalize: "off" }
        },
        extensions: [g0, w0.configure({ types: ["heading", "paragraph"] }), b0.configure({ placeholder: "Nhp vn bn cn kim tra " }), Vp, x0, k0]
    }); function Qr() { document.querySelectorAll(".highlight-popover").forEach(e => { e.classList.remove("show"), setTimeout(() => { e.remove() }, 200) }) } function K() { const r = v.isActive("bold"), e = v.isActive("italic"), t = v.isActive("underline"); v.isActive("heading", { level: 1 }), v.isActive("heading", { level: 2 }), v.isActive("heading", { level: 3 }); const n = v.isActive("bulletList"), i = v.isActive("orderedList"), s = v.isActive({ textAlign: "left" }), u = v.isActive({ textAlign: "center" }), o = v.isActive({ textAlign: "right" }); document.getElementById("bold-button").classList.toggle("active", r), document.getElementById("italic-button").classList.toggle("active", e), document.getElementById("underline-button").classList.toggle("active", t), document.getElementById("bullet-list-button").classList.toggle("active", n), document.getElementById("ordered-list-button").classList.toggle("active", i), document.getElementById("align-left-button").classList.toggle("active", s), document.getElementById("align-center-button").classList.toggle("active", u), document.getElementById("align-right-button").classList.toggle("active", o) } function qp(r, e, t) { document.querySelectorAll(".highlight-popover").forEach(a => a.remove()); const n = r.getAttribute("data-correction"), i = document.createElement("div"); i.className = "highlight-popover", i.style.position = "absolute", i.style.background = "#fff", i.style.border = "1px solid #ccc", i.style.padding = "4px 8px", i.style.borderRadius = "4px", i.style.boxShadow = "0 2px 8px rgba(0,0,0,0.1)", i.style.zIndex = 9999; const s = document.createElement("div"); s.className = "correction-text", s.textContent = ` xut: "${n}"`, i.appendChild(s); const u = document.createElement("button"); u.className = "apply-correction", u.textContent = "p dng", i.appendChild(u); const o = r.getBoundingClientRect(); i.style.left = `${o.left + window.scrollX}px`, i.style.top = `${o.bottom + window.scrollY + 4}px`, document.body.appendChild(i), u.addEventListener("click", function (a) { if (a.stopPropagation(), e !== -1) { const { state: c } = v, d = c.tr; d.delete(e, t), d.insertText(n, e), v.view.dispatch(d) } Qr() }); const l = a => { i.contains(a.target) || (i.remove(), document.removeEventListener("click", l)) }; document.addEventListener("click", l) } document.addEventListener("DOMContentLoaded", function () {
    document.getElementById("check-button").addEventListener("click", async () => { const e = document.getElementById("check-button"); e.innerText = "ang kim tra...", e.disabled = !0, document.addEventListener("click", function (t) { !t.target.closest(".error-highlight") && !t.target.closest(".correction-popover") && Qr() }), document.addEventListener("click", function (t) { const n = t.target; if (n.classList.contains("error-highlight")) { t.stopPropagation(), Qr(); const s = v.view.posAtDOM(n, 0); if (s == null) return; let u = s, o = s + n.textContent.length; n.getAttribute("data-correction") && qp(n, u, o) } }); try { await Fp(v) } catch (t) { console.error("Error checking grammar:", t) } finally { e.innerText = "Kim tra", e.disabled = !1 } })
});
